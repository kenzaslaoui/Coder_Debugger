[
  {
    "task": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
    "buggy_code": "\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if (!root):\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,ans)\n        return ans\n",
    "test_cases": [
      "assert Solution().inorderTraversal(TreeNode(1, None, TreeNode(2, TreeNode(3), None))) == [1, 3, 2]",
      "assert Solution().inorderTraversal(None) == []",
      "assert Solution().inorderTraversal(TreeNode(1)) == [1]"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.\n\nConstraints:\n1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
    "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com,2)\n",
    "test_cases": [
      "assert Solution().findComplement(5) == 2",
      "assert Solution().findComplement(1) == 0"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\u00a0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\u00a0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.\n\nConstraints:\n1 <= n <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n+1)%1000000007)%1000000007; \n    }\n    int numPrimeArrangements(int n) {\n        if(n==1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};\n",
    "test_cases": [
      "assert(solution.numPrimeArrangements(5) == 12);",
      "assert(solution.numPrimeArrangements(100) == 682289015);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1,0,0,0,1], 1) == True",
      "assert Solution().canPlaceFlowers([1,0,0,0,1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying\u00a0the constraint.\n\nConstraints:\n1 <= n <= 103",
    "buggy_code": "\nclass Solution {\npublic:\n    int sumOfMultiples(int n,int count=0) {\n\n       for (int i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count-1;\n\n    }\n};\n",
    "test_cases": [
      "assert(solution.sumOfMultiples(7) == 21);",
      "assert(solution.sumOfMultiples(10) == 40);",
      "assert(solution.sumOfMultiples(9) == 30);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.\n\nConstraints:\n1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
    "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n           com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com[::-1][1:],2)\n",
    "test_cases": [
      "assert Solution().findComplement(5) == 2",
      "assert Solution().findComplement(1) == 0"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 212 - 1].\n-1000 <= Node.val <= 1000\n\n\u00a0\nFollow-up:\n\nYou may only use constant extra space.\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.",
    "buggy_code": "\nclass Solution {\n    public Node connect(Node node) {\n        Map<Integer, List<Node>> map = new HashMap<>();\n        goDFS(0, node, map);\n        for (int key : map.keySet()) {\n            List<Node> list = map.get(key);\n            for (int i = 1; i < list.size(); i++) {\n                list.get(i - 1).next = list.get(i + 1);\n            }\n        }\n        return node;\n    }\n\n    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {\n        if (node == null) return;\n\n        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());\n        list.add(node);\n        lvl++;\n        goDFS(lvl, node.left, map);\n        goDFS(lvl, node.right, map);\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().connect(new Node(1, new Node(2, new Node(4), new Node(5)), new Node(3, new Node(6), new Node(7)))).serialize(), new int[]{1, -1, 2, 3, -1, 4, 5, 6, 7, -1})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().connect(null).serialize(), new int[]{})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = tail->next;\n    }\n};\n",
    "test_cases": [
      "assert(LRUCache(2).put(1, 1) == nullptr);",
      "assert(LRUCache(2).put(2, 2) == nullptr);",
      "assert(LRUCache(2).get(1) == 1);",
      "assert(LRUCache(2).put(3, 3) == nullptr);",
      "assert(LRUCache(2).get(2) == -1);",
      "assert(LRUCache(2).put(4, 4) == nullptr);",
      "assert(LRUCache(2).get(1) == -1);",
      "assert(LRUCache(2).get(3) == 3);",
      "assert(LRUCache(2).get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n\nConstraints:\n1 <= n <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n",
    "test_cases": [
      "assert(solution.magicalString(6) == 3);",
      "assert(solution.magicalString(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAndSay(1) = \"1\"\ncountAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\nFor example, the saying and conversion for digit string \"3322251\":\n\nGiven a positive integer n, return the nth term of the count-and-say sequence.\n\nConstraints:\n1 <= n <= 30",
    "buggy_code": "\nclass Solution {\n    String convert(String s)\n    {\n        char prevCh = s.charAt(0);\n        int prevCount = 1; //stores count of consecutive same digits\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i <= s.length(); i++)\n        {\n            char currCh = s.charAt(i);\n            print(currCh != prevCh)   \n            {\n                ans.append(Integer.toString(prevCount));\n                ans.append(prevCh);\n                prevCount = 1; //reset count\n                prevCh = currCh;\n            }\n            else prevCount++;\n        }\n        ans.append(Integer.toString(prevCount));\n        ans.append(prevCh);\n        return ans.toString();\n    }\n    public String countAndSay(int n) \n    {\n        String prevStr = \"1\";\n        for (int i = 2; i <= n; i++)\n        {\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\n            prevStr = cnsNum; //remember (dp) the previous built string\n        }\n        return prevStr;    \n    }\n}\n",
    "test_cases": [
      "if (!new Solution().countAndSay(1).equals(\"1\")) System.out.println(\"Test failed for n = 1\");",
      "if (!new Solution().countAndSay(4).equals(\"1211\")) System.out.println(\"Test failed for n = 4\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.\n\nConstraints:\n1 <= n <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++  {\n            int i = res.size(), t = (1<<k) ;\n            while( i > 1 ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return doSomethingExtra(res);\n    }\n};\n",
    "test_cases": [
      "assert(solution.grayCode(2) == vector<int>{0, 1, 3, 2});",
      "assert(solution.grayCode(1) == vector<int>{0, 1});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].\n\nConstraints:\n0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
    "buggy_code": "\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float)\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n",
    "test_cases": [
      "solution = Solution(1.0, 0.0, 0.0)",
      "assert len(solution.randPoint()) == 2  # Check that randPoint returns a list of two floats",
      "assert -1.0 <= solution.randPoint()[0] <= 1.0  # Check that x-coordinate is within the circle",
      "assert -1.0 <= solution.randPoint()[1] <= 1.0  # Check that y-coordinate is within the circle"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty:\n\nFrom each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\nIdentify the highest number amongst all those removed in step 1. Add that number to your score.\n\nReturn the final score.\n\nConstraints:\n1 <= nums.length <= 300\n1 <= nums[i].length <= 500\n0 <= nums[i][j] <= 103",
    "buggy_code": "\nclass Solution {\n    public int matrixSum(int[][] nums) {\n        int score = 0;\n        int n = nums.length;\n        int m = nums[0].length;\n        for(int[] a :nums)\n        {\n            Arrays.sort(a);\n        }\n        for(int i=0;i<=m;i++)\n        {\n            int max = 0;\n            for(int j=0;j<n;j++)\n            {\n                max = Math.max(max,nums[j][i]);\n            }\n            score+=max;\n        }\n        return score;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().matrixSum(new int[][]{{7,2,1},{6,4,2},{6,5,3},{3,2,1}}) != 15) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().matrixSum(new int[][]{{1}}) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n\nTake their own seat if it is still available, and\nPick other seats randomly when they find their seat occupied\n\nReturn the probability that the nth person gets his own seat.\n\nConstraints:\n1 <= n <= 105",
    "buggy_code": "\nclass Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        if(n==1)\n        return 1.00000;\n        else\n        return 1.50000;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().nthPersonGetsNthSeat(1) != 1.00000) System.out.println(\"Test failed for input 1\");",
      "if (new Solution().nthPersonGetsNthSeat(2) != 0.50000) System.out.println(\"Test failed for input 2\");"
    ],
    "language": "java",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.\n\nConstraints:\nm == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
    "buggy_code": "\nclass Solution {\n    public int maxIncreasingCells(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rows = new int[m], cols = new int[n];\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\n\n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\n        for(int i=0;i<m;i++) {\n            rows[i] = Integer.MIN_VALUE;\n        }\n        for(int i=0;i<n;i++) {\n            cols[i] = Integer.MIN_VALUE;\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\n            return a[0] - b[0];\n        });\n        for(int i=0;i<m;i++) {\n            for(int j=0;j<n;j++) {\n                queue.add(new int[]{mat[i][j], i, j});\n            }\n        }\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int[] arr = null;\n            int val = arr[0], row = arr[1], col = arr[2];\n            int cur = 1;\n            if(val == rows[row]) {\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\n            } else {\n                cur = Math.max(rowMaxVals[row] + 1, cur);\n            }\n            if(val == cols[col]) {\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\n            } else {\n                cur = Math.max(colMaxVals[col] + 1, cur);\n            }\n\n\n            if(val > rows[row]) {\n                rowSubMaxVals[row] = rowMaxVals[row];\n                rows[row] = val;\n            }\n            if(val > cols[col]) {\n                colSubMaxVals[col] = colMaxVals[col];\n                cols[col] = val;\n            }\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\n\n            res = Math.max(res, cur);\n        }\n\n        return res;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxIncreasingCells(new int[][]{{3,1},{3,4}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxIncreasingCells(new int[][]{{1,1},{1,1}}) != 1) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maxIncreasingCells(new int[][]{{3,1,6},{-9,5,7}}) != 4) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\n\nConstraints:\n1 <= s.length <= 105\ns[i] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n        int flip=0,one=0,n = s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='1){\n                one++;\n            }else{\n                if(one==0)continue;\n                else flip++;\n            }\n            if(one<flip)flip = \"one;\n        }\n        return flip;\n    }\n};\n",
    "test_cases": [
      "assert(solution.minFlipsMonoIncr(\"00110\") == 1);",
      "assert(solution.minFlipsMonoIncr(\"010110\") == 2);",
      "assert(solution.minFlipsMonoIncr(\"00011000\") == 2);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\nNote: You cannot rotate an envelope.\n\nConstraints:\n1 <= envelopes.length <= 105\nenvelopes[i].length == 2\n1 <= wi, hi <= 105",
    "buggy_code": "\nclass Solution {\n    public int binarySearch(int[] dp, int val){\n        int lo=0,hi=dp.length-1,res=0;\n        while(lo<=hi){\n            int mid=(lo+hi)/2;\n            if(dp[mid]<=val)\n                res=mid;\n                lo=mid+1;\n            else{\n                hi=mid-1;\n            }\n        }\n        return res+1;\n    }\n    public int maxEnvelopes(int[][] envelopes) {\n        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\n        int[] LIS=new int[envelopes.length+1];\n        Arrays.fill(LIS,Integer.MAX_VALUE);\n        LIS[0]=Integer.MIN_VALUE;\n        int ans=0;\n        for(int i=0;i<envelopes.length;i++){\n            int val=envelopes[i][3];\n            int insertIndex=binarySearch(LIS,val);\n            ans=Math.max(ans,insertIndex);\n            if(LIS[insertIndex]>=val){\n                LIS[insertIndex]=val;\n            }\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxEnvelopes(new int[][]{{5,4},{6,4},{6,7},{2,3}}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxEnvelopes(new int[][]{{1,1},{1,1},{1,1}}) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.\n\nConstraints:\n2 <= nums.length <= 105\n1 <= nums[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and prev1 == prev2+1 == curr+2))   \n\n        return checks[2]\n",
    "test_cases": [
      "assert Solution().validPartition([4, 4, 4, 5, 6]) == True",
      "assert Solution().validPartition([1, 1, 1, 2]) == False"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\npublic:\n    int minSwaps(string s);\n}; \n\nint Solution::maxSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/\"bug_string;\n    }\n\n",
    "test_cases": [
      "assert(solution.minSwaps(\"][][]\") == 1);",
      "assert(solution.minSwaps(\"]]][[[\") == 2);",
      "assert(solution.minSwaps(\"[]\") == 0);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.\nIn the American keyboard:\n\nthe first row consists of the characters \"qwertyuiop\",\nthe second row consists of the characters \"asdfghjkl\", and\nthe third row consists of the characters \"zxcvbnm\".\n\nConstraints:\n1 <= words.length <= 20\n1 <= words[i].length <= 100\nwords[i] consists of English letters (both lowercase and uppercase).",
    "buggy_code": "\nclass Solution {\n    public String[] findWords(String[] words) {\n        List<String> res = new ArrayList<>();\n        String firstRow = \"qwertyuiop\";\n        String secondRow = \"asdfghjkl\";\n        String thirdRow = \"zxcvbnm;\n\n        loop:\n        for(String word : words) {\n            char[] chars = word.toLowerCase().toCharArray();\n\n            boolean canBeTyped = true;\n            for(char c : chars) {\n                int idx = firstRow.indexOf(c);\n                if(idx == -1) {\n                    canBeTyped = false;\n                    break;\n                }\n            }\n            if(canBeTyped) {\n                res.add(word);\n                continue loop;\n            }\n\n            canBeTyped = true;\n            for(char c : chars) {\n                int idx = secondRow.indexOf(c);\n                if(idx == -1) {\n                    canBeTyped = false;\n                    break;\n                }\n            }\n            if(canBeTyped) {\n                res.add(word);\n                continue loop;\n            }\n\n            canBeTyped = true;\n            for(char c : chars) {\n                int idx = thirdRow.indexOf(c);\n                if(idx == -1) {\n                    canBeTyped = false;\n                    break;\n                }\n            }\n            if(canBeTyped) {\n                res.add(word);\n                continue loop;\n            }\n        }\n        \n        String[] ans = new String[res.size()];\n        int i = 0;\n        for(String word : res) {\n            ans[i++] = word;\n        }\n\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findWords(new String[]{\"Hello\",\"Alaska\",\"Dad\",\"Peace\"}), new String[]{\"Alaska\",\"Dad\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findWords(new String[]{\"omk\"}), new String[]{})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().findWords(new String[]{\"adsdf\",\"sfd\"}), new String[]{\"adsdf\",\"sfd\"})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given a rows x cols\u00a0binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\nConstraints:\nrows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] is '0' or '1'.",
    "buggy_code": "\nclass Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0) {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maximalRectangle(new char[][]{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maximalRectangle(new char[][]{{'0'}}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maximalRectangle(new char[][]{{'1'}}) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nConstraints:\n1 <= hours.length <= 104\n0 <= hours[i] <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n            if(mp.find(k)==mp.end()){\n                mp[k+1]=i;\n            }\n        }\n\n    }    \n    return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestWPI(vector<int>{9,9,6,0,6,6,9}) == 3);",
      "assert(solution.longestWPI(vector<int>{6,6,6}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.\n\nConstraints:\n1 <= num <= 109",
    "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().largestInteger(1234) != 3412) System.out.println(\"Test failed for input 1234\");",
      "if (new Solution().largestInteger(65875) != 87655) System.out.println(\"Test failed for input 65875\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return \"s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test failed for input [\\\"abc\\\",\\\"car\\\",\\\"ada\\\",\\\"racecar\\\",\\\"cool\\\"]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test failed for input [\\\"notapalindrome\\\",\\\"racecar\\\"]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test failed for input [\\\"def\\\",\\\"ghi\\\"]\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.\n\nConstraints:\n1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
    "buggy_code": "\n#define ll long long \nclass Solution {\npublic:\n    long long minimumTime(vector<int>& time, int totalTrips) {\n        ll l = 1, r = 1e14;\n        Solution obj;\n        while(l <= r) {\n            ll trip = 0, mid = (l + r) / 2;\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\n            if(trip <= totalTrips) l = mid + 1;\n            else r = mid - 1;\n        }\n        return obj.minimumTime(time, totalTrips);\n    }\n};\n",
    "test_cases": [
      "assert(solution.minimumTime({1, 2, 3}, 5) == 3);",
      "assert(solution.minimumTime({2}, 1) == 2);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nConstraints:\nn == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
    "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height = null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=height[i];\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().trap(new int[]{0,1,0,2,1,0,1,3,2,1,2,1}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().trap(new int[]{4,2,0,3,2,5}) != 9) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.\n\nConstraints:\n1 <= num <= 109",
    "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().largestInteger(1234) != 3412) System.out.println(\"Test failed for input 1234\");",
      "if (new Solution().largestInteger(65875) != 87655) System.out.println(\"Test failed for input 65875\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])\n\nConstraints:\n3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return self.undefined_method()\n",
    "test_cases": [
      "assert Solution().canThreePartsEqualSum([0,2,1,-6,6,-7,9,1,2,0,1]) == True",
      "assert Solution().canThreePartsEqualSum([0,2,1,-6,6,7,9,-1,2,0,1]) == False",
      "assert Solution().canThreePartsEqualSum([3,3,6,5,-2,2,5,1,-9,4]) == True"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Roman numerals are represented by seven different symbols:\u00a0I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,\u00a02 is written as II\u00a0in Roman numeral, just two one's added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\u00a0\nX can be placed before L (50) and C (100) to make 40 and 90.\u00a0\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n\nConstraints:\n1 <= num <= 3999",
    "buggy_code": "\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"}\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};\n",
    "test_cases": [
      "assert(solution.intToRoman(3) == \"III\");",
      "assert(solution.intToRoman(58) == \"LVIII\");",
      "assert(solution.intToRoman(1994) == \"MCMXCIV\");"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.\n\nConstraints:\n1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
    "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += \n            losers[match[1]] += \n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n\n        for k, v in winners.items(): \n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n",
    "test_cases": [
      "assert Solution().findWinners([[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]) == [[1,2,10],[4,5,7,8]]",
      "assert Solution().findWinners([[2,3],[1,3],[5,4],[6,4]]) == [[1,2,5,6],[]]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
    "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u-1] = u-1;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n",
    "test_cases": [
      "assert(solution.hasValidPath({{2,4,3},{6,5,2}}) == true);",
      "assert(solution.hasValidPath({{1,2,1},{1,2,1}}) == false);",
      "assert(solution.hasValidPath({{1,1,2}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.\n\nConstraints:\n0 <=\u00a0x, y <= 231 - 1",
    "buggy_code": "\nimport java.math.BigInteger;\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        String x_bin = Integer.toBinaryString(x);\n        String y_bin = Integer.toBinaryString(y);\n\n        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();\n        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;\n        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;\n\n        int result = 0;\n        BigInteger min_bi;\n        min_bi  = new BigInteger(min_str, 2); \n        System.out.println(\"min_bi = \"+ min_bi);\n        String min_format_str = String.format(\"%0\"+max_len+\"d\", min_bi);\n        for(int i=0; i<max_len; i++){\n            if(max_str.charAt(i)!=min_format_str.charAt(i))\n            {\n                result+=1;\n            }\n        }\n        System.out.println(max_str);\n        System.out.println(min_format_str);\n\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().hammingDistance(1, 4) != 2) System.out.println(\"Test case failed: Input: x = 1, y = 4\");",
      "if (new Solution().hammingDistance(3, 1) != 1) System.out.println(\"Test case failed: Input: x = 3, y = 1\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = false;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(solution.containsCycle(vector<vector<char>>{{'a','a','a','a'},{'a','b','b','a'},{'a','b','b','a'},{'a','a','a','a'}}) == true);",
      "assert(solution.containsCycle(vector<vector<char>>{{'c','c','c','a'},{'c','d','c','c'},{'c','c','e','c'},{'f','c','c','c'}}) == true);",
      "assert(solution.containsCycle(vector<vector<char>>{{'a','b','b'},{'b','z','b'},{'b','b','a'}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\nImplement the FrequencyTracker class.\n\nFrequencyTracker(): Initializes the FrequencyTracker object with an empty array initially.\nvoid add(int number): Adds number to the data structure.\nvoid deleteOne(int number): Deletes one occurrence of number from the data structure. The data structure may not contain number, and in this case nothing is deleted.\nbool hasFrequency(int frequency): Returns true if there is a number in the data structure that occurs frequency number of times, otherwise, it returns false.\n\nConstraints:\n1 <= number <= 105\n1 <= frequency <= 105\nAt most, 2 *\u00a0105\u00a0calls will be made to add, deleteOne, and hasFrequency\u00a0in total.",
    "buggy_code": "\nclass FrequencyTracker {\npublic:\n    unordered_map<int,int> x,y;\n    void add(int number) {\n        x[number]++;\n        if(x[number]!=1) y[x[number]-1]--;\n        y[x[number]]--;\n    }\n    void deleteOne(int number) {\n        if(x[number]!=0){\n            x[number]--;\n            y[x[number]+1]--;\n            y[x[number]]++;\n        }\n    }\n    bool hasFrequency(int frequency) {\n        if(y[frequency]!=0) return true;\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(frequencyTracker.hasFrequency(2) == false); frequencyTracker.add(3); frequencyTracker.add(3); assert(frequencyTracker.hasFrequency(2) == true);",
      "assert(frequencyTracker.hasFrequency(1) == false); frequencyTracker.add(1); frequencyTracker.deleteOne(1); assert(frequencyTracker.hasFrequency(1) == false);",
      "assert(frequencyTracker.hasFrequency(2) == false); frequencyTracker.add(3); assert(frequencyTracker.hasFrequency(1) == true);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++)\n            char c = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(c))){\n                count--;\n            }\n        return count;\n    } */\n}\n\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n\nConstraints:\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
    "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int(t[] balls) {\n        int = 0;\n        for (int b: balls)\n            unique += b > \"0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().getProbability(new int[]{1, 1}) != 1.00000) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().getProbability(new int[]{2, 1, 1}) != 0.66667) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().getProbability(new int[]{1, 2, 1, 2}) != 0.60000) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.\n\nConstraints:\ncosts.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
    "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index])\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxIceCream(new int[]{1,3,2,4,1}, 7) != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxIceCream(new int[]{10,6,8,7,7,8}, 5) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maxIceCream(new int[]{1,6,3,1,2,5}, 20) != 6) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.\n\nConstraints:\n0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
    "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return 'encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n",
    "test_cases": [
      "assert Solution().decodeCiphertext(\"ch   ie   pr\", 3) == \"cipher\"",
      "assert Solution().decodeCiphertext(\"iveo    eed   l te   olc\", 4) == \"i love leetcode\"",
      "assert Solution().decodeCiphertext(\"coding\", 1) == \"coding\""
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.\n\nConstraints:\n1 <= s.length <= 500\ns consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n                        self.undefinedMethod()\n\n            for i in letters[::-1]:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n                        self.undefinedMethod()\n\n\n        return res\n",
    "test_cases": [
      "assert Solution().sortString(\"aaaabbbbcccc\") == \"abccbaabccba\"",
      "assert Solution().sortString(\"rat\") == \"art\""
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nConstraints:\n1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.groupAnagrams(vector<string>{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}) == vector<vector<string>>{{\"bat\"}, {\"nat\", \"tan\"}, {\"ate\", \"eat\", \"tea\"}});",
      "assert(solution.groupAnagrams(vector<string>{\"\"}) == vector<vector<string>>{{\"\"}});",
      "assert(solution.groupAnagrams(vector<string>{\"a\"}) == vector<vector<string>>{{\"a\"}});"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.\n\nConstraints:\nThe number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        vector<vector<int>>v;\n        int i,n;\n        if(!root)return -1;\n        queue<TreeNode*>q;\n        priority_queue<long long>pq;\n        q.push(root);\n        while(!q.empty()){\n            n=q.size();\n            long long sum=0;\n            for(i=0;i<=n;i++){\n                TreeNode* x = q.front();\n                q.pop();\n                sum+=x->val;\n                if(x->left)q.push(x->left);\n                if(x->right)q.push(x->right);\n            }\n            pq.push(sum);\n        }\n        if(pq.size()<k)return -1;\n        k=k-1;\n        while(k--)pq.pop();\n        return pq.top();\n    }\n};\n",
    "test_cases": [
      "assert(solution.kthLargestLevelSum(new TreeNode(5, new TreeNode(8, new TreeNode(2), new TreeNode(1)), new TreeNode(9, new TreeNode(3), new TreeNode(7, new TreeNode(4), new TreeNode(6)))), 2) == 13);",
      "assert(solution.kthLargestLevelSum(new TreeNode(1, new TreeNode(2, nullptr, new TreeNode(3)), nullptr), 1) == 3);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
    "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]=mx:   \n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans\n",
    "test_cases": [
      "assert Solution().edgeScore([1,0,0,0,0,7,7,5]) == 7",
      "assert Solution().edgeScore([2,0,0,2]) == 0"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\nConstraints:\n0 <= left <= right <= 231 - 1",
    "buggy_code": "\nclass Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left)\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};\n",
    "test_cases": [
      "assert(solution.rangeBitwiseAnd(5, 7) == 4);",
      "assert(solution.rangeBitwiseAnd(0, 0) == 0);",
      "assert(solution.rangeBitwiseAnd(1, 2147483647) == 0);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nAll elements in nums are distinct.",
    "buggy_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount;\n            }\n        }\n        \n\t\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += count * (count - 1) / 2;\n        }\n        return factor * 8;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().tupleSameProduct(new int[]{2, 3, 4, 6}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().tupleSameProduct(new int[]{1, 2, 4, 5, 10}) != 16) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.\n\nConstraints:\n1 <= x, y <= 100\n0 <= bound <= 106",
    "buggy_code": "\nclass Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound = 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v = 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\n",
    "test_cases": [
      "assert Solution().powerfulIntegers(2, 3, 10) == [2, 3, 4, 5, 7, 9, 10]",
      "assert Solution().powerfulIntegers(3, 5, 15) == [2, 4, 6, 8, 10, 14]"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\nYou are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location.\nReturn true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.\n\nConstraints:\n1 <= trips.length <= 1000\ntrips[i].length == 3\n1 <= numPassengersi <= 100\n0 <= fromi < toi <= 1000\n1 <= capacity <= 105",
    "buggy_code": "\nclass Solution {\nprivate:\n    static bool comp(vector<int>& it1, vector<int>& it2){\n        if(it1[1] < it2[1] || (it1[1] = it2[1] && it1[2] < it2[2])) return true;\n        return false;\n    }\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n        sort(trips.begin(),trips.end(),comp);\n        int n = trips.size();\n        int current_capacity = 0;\n        priority_queue<pair<int,int>>pq;\n        for(int i=0; i<n; i++){\n            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){\n                current_capacity -= pq.top().second;\n                pq.pop();\n            }\n            current_capacity += trips[i][0];\n            if(current_capacity > capacity) return false;\n            pq.push({-trips[i][2],trips[i][0]});\n        }\n        return true;\n    }\n};\n",
    "test_cases": [
      "assert(solution.carPooling({{2,1,5},{3,3,7}}, 4) == false);",
      "assert(solution.carPooling({{2,1,5},{3,3,7}}, 5) == true);"
    ],
    "language": "cpp",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\n\nConstraints:\n1 <= n <= 19",
    "buggy_code": "\nclass Solution {\npublic:\nint solve(int n)\n{\n    vector<int>dp(n+1,0);    \n    dp[0]=dp[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j= 0;j<=i;j++)\n        {\n            dp[i]+= dp[j-1]*dp[i-j];\n        }\n    return dp[n];\n    }\n    int numTrees(int n) {\n    return solve(n); \n    }\n};\n",
    "test_cases": [
      "assert(solution.numTrees(3) == 5);",
      "assert(solution.numTrees(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n\nConstraints:\n1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
    "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n];\n        \n        for(int i=0;i<n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - set2.size();\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{1,2,3,4,5}), new int[]{-3,-1,1,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{3,2,3,4,2}), new int[]{-2,-1,0,2,3})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        return ans;\n    }\n}\npit()\n    return ans;    \n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n integer array grid where grid[i][j] could be:\n\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell.",
    "buggy_code": "\nclass Solution {\n    public int uniquePathsIII(int[][] grid) {\n        \n        int row = 0;\n        int col = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    row = i;\n                    col = j;\n                    break;\n                }\n            }\n        }\n        boolean[][] used = new boolean[grid.length][grid[0].length+1];\n        return count(grid, used, row, col);\n    }\n\n    int count(int[][] grid, boolean[][] used, int row, int col) {\n\n        used[row][col] = true;\n        if(grid[row][col] == 2) {\n            if(isValid(used, grid) && grid[row][col] != -1) {\n                used[row][col] = false;\n                return 1;\n            }\n            used[row][col] = false;\n            return 0;\n        }\n        if(grid[row][col] == -1) {\n            used[row][col] = false;\n            return 0;\n        }\n\n        int paths = 0;\n\n        //DOWN\n        if(row < grid.length - 1 && !used[row + 1][col]) {\n            paths += count(grid, used, row + 1, col);\n        }\n        //RIGHT\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\n            paths += count(grid, used, row, col + 1);\n        }\n        //UP\n        if(row > 0 && !used[row - 1][col]) {\n            paths += count(grid, used, row - 1, col);\n        }\n        //LEFT\n        if(col > 0 && !used[row][col - 1]) {\n            paths += count(grid, used, row, col - 1);\n        }\n\n        used[row][col] = false;\n        return paths;\n    }\n\n    boolean isValid(boolean[][] used, int[][] grid) {\n\n        for(int i = 0; i < used.length; i++) {\n            for(int j = 0; j < used[0].length; j++) {\n                if(grid[i][j] == 0) {\n                    if(!used[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().uniquePathsIII(new int[][]{{1,0,0,0},{0,0,0,0},{0,0,2,-1}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().uniquePathsIII(new int[][]{{1,0,0,0},{0,0,0,0},{0,0,0,2}}) != 4) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().uniquePathsIII(new int[][]{{0,1},{2,0}}) != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestPathAllKeys(vector<string>{\"@.a..\",\"###.#\",\"b.A.B\"}) == 8);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@..aA\",\"..B#.\",\"....b\"}) == 6);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@Aa\"}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
    "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(\"valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};\n",
    "test_cases": [
      "assert(solution.addTwoNumbers(createLinkedList({2, 4, 3}), createLinkedList({5, 6, 4})) == createLinkedList({7, 0, 8}));",
      "assert(solution.addTwoNumbers(createLinkedList({0}), createLinkedList({0})) == createLinkedList({0}));",
      "assert(solution.addTwoNumbers(createLinkedList({9, 9, 9, 9, 9, 9, 9}), createLinkedList({9, 9, 9, 9})) == createLinkedList({8, 9, 9, 9, 0, 0, 0, 1}));"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n = 0) return 0;\n        return 1 + countDigits(n/10);\n    }\n\n    public int countLargestGroup(int n) {\n\n        ArrayList<Integer> list = null;\n\n        for(int i=1;i<=n;i++) {\n            int cd = missingMethod(i); \n            list.set(cd, list.get(cd)+1); \n            }\n\n       return Collections.frequency(list, Collections.max(list));\n    }\n}\n",
    "test_cases": [
      "if (new Solution().countLargestGroup(13) != 4) System.out.println(\"Test failed for input 13\");",
      "if (new Solution().countLargestGroup(2) != 2) System.out.println(\"Test failed for input 2\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\n\nConstraints:\n1 <= s.length <= 105\ns[i] is either '0' or '1'.",
    "buggy_code": "\n//Memoisation\nclass Solution {\npublic:\n    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){\n        if(idx-s.size()){\n            return 0;\n        }\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\n        if(prev){\n            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);\n        }\n        else{\n            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,0,s,dp),(s[idx]=='0')+solve(idx+1,1,s,dp));\n        }\n    }\n    int minFlipsMonoIncr(string s) {\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\n        return solve(0,0,s,dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.minFlipsMonoIncr(\"00110\") == 1);",
      "assert(solution.minFlipsMonoIncr(\"010110\") == 2);",
      "assert(solution.minFlipsMonoIncr(\"00011000\") == 2);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(solution.queryString(\"0110\", 3) == true);",
      "assert(solution.queryString(\"0110\", 4) == false);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106",
    "buggy_code": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0;\n        for(int j = 0;j<n;j++)\n        {\n            product = product*nums[j];\n            while(i<=j && product>k)\n            {\n                product = product/nums[i];\n                i++;\n            }\n            result += j-i+1;\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numSubarrayProductLessThanK(new int[]{10,5,2,6}, 100) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numSubarrayProductLessThanK(new int[]{1,2,3}, 0) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given a rows x cols\u00a0binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\nConstraints:\nrows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] is '0' or '1'.",
    "buggy_code": "\nclass Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '1';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0';\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first == heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first == heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maximalRectangle(new char[][]{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maximalRectangle(new char[][]{{'0'}}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maximalRectangle(new char[][]{{'1'}}) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\nConstraints:\n1 <= numRows <= 30",
    "buggy_code": "\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = Array(1)\n        for i in range(len(fin)-1:\n            now.append(fin[i] + fin[i+1])\n        now.push(1)\n        prev.append(now)\n        return prev\n",
    "test_cases": [
      "assert Solution().generate(5) == [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
      "assert Solution().generate(1) == [[1]]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_string(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findRelativeRanks(vector<int>{5,4,3,2,1}) == vector<string>{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"});",
      "assert(solution.findRelativeRanks(vector<int>{10,3,8,9,4}) == vector<string>{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.\n\nConstraints:\nn == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
    "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        \n        self.helper(matrix, dp_row, dp_col)\n\n    def helper(self, matrix, dp_row, dp_col):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n",
    "test_cases": [
      "assert Solution().checkValid([[1,2,3],[3,1,2],[2,3,1]]) == True",
      "assert Solution().checkValid([[1,1,1],[1,2,3],[1,2,3]]) == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.\n\nConstraints:\n1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1);\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            \n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n            }\n            \n        }\n\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};\n",
    "test_cases": [
      "assert(solution.filterRestaurants({{1,4,1,40,10},{2,8,0,50,5},{3,8,1,30,4},{4,10,0,10,3},{5,1,1,15,1}}, 1, 50, 10) == vector<int>({3,1,5}));",
      "assert(solution.filterRestaurants({{1,4,1,40,10},{2,8,0,50,5},{3,8,1,30,4},{4,10,0,10,3},{5,1,1,15,1}}, 0, 50, 10) == vector<int>({4,3,2,1,5}));",
      "assert(solution.filterRestaurants({{1,4,1,40,10},{2,8,0,50,5},{3,8,1,30,4},{4,10,0,10,3},{5,1,1,15,1}}, 0, 30, 3) == vector<int>({4,5}));"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.right)  \n                    queue.append(tmp.left)   \n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n\n        doSomething();\n\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = ar + 1r; \n        return ans;\n    }\n}\n\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106",
    "buggy_code": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0;\n        for(int j = 0;j<n;j++)\n        {\n            product = productMultiply(nums[j]);\n            while(i<=j && product>=k)\n            {\n                product = productDivide(nums[i]);\n                i++;\n            }\n            result += j-i+1;\n        }\n        return result;\n    }\n\n    public int productMultiply(int num){\n        return product * num;\n    }\n\n    public int productDivide(int num){\n        return product / num;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numSubarrayProductLessThanK(new int[]{10,5,2,6}, 100) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numSubarrayProductLessThanK(new int[]{1,2,3}, 0) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.\n\nConstraints:\nm == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
    "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                    for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '#'}}), new char[][]{{'.'}, {'#'}, {'#'}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '*', '.'}, {'#', '#', '*', '.'}}), new char[][]{{'#', '.'}, {'#', '#'}, {'*', '*'}, {'.', '.'}})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '#', '*', '.', '*', '.'}, {'#', '#', '#', '*', '.', '.'}, {'#', '#', '#', '.', '#', '.'}}), new char[][]{{'.', '#', '#'}, {'.', '#', '#'}, {'#', '#', '*'}, {'#', '*', '.'}, {'#', '.', '*'}, {'#', '.', '.'}})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n   list<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(solution.containsCycle(vector<vector<char>>{{'a','a','a','a'},{'a','b','b','a'},{'a','b','b','a'},{'a','a','a','a'}}) == true);",
      "assert(solution.containsCycle(vector<vector<char>>{{'c','c','c','a'},{'c','d','c','c'},{'c','c','e','c'},{'f','c','c','c'}}) == true);",
      "assert(solution.containsCycle(vector<vector<char>>{{'a','b','b'},{'b','z','b'},{'b','b','a'}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\n\nConstraints:\n1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
    "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        \n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)\n",
    "test_cases": [
      "assert Solution().sumSubarrayMins([3,1,2,4]) == 17",
      "assert Solution().sumSubarrayMins([11,81,94,43,3]) == 444"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n\nConstraints:\n1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
    "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n+1];\n        \n        for(int i=0;i<=n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - set2.size();\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{1,2,3,4,5}), new int[]{-3,-1,1,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{3,2,3,4,2}), new int[]{-2,-1,0,2,3})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on the table.\nYou and your friend will alternate taking turns, and you go first.\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\nThe one who removes the last stone is the winner.\n\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.\n\nConstraints:\n1 <= n <= 231 - 1",
    "buggy_code": "\nclass Solution:\ndef canWinNim(self, n: int) -> bool:\n    return n % 4 != 0\n",
    "test_cases": [
      "assert Solution().canWinNim(4) == False",
      "assert Solution().canWinNim(1) == True",
      "assert Solution().canWinNim(2) == True"
    ],
    "language": "python3",
    "bug_type": "illegal indentation",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\n\nA land cell if grid[r][c] = 0, or\nA water cell containing grid[r][c] fish, if grid[r][c] > 0.\n\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\n\nCatch all the fish at cell (r, c), or\nMove to any adjacent water cell.\n\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 10\n0 <= grid[i][j] <= 10",
    "buggy_code": "\nclass Solution {\n    public int findMaxFish(int[][] grid) {\n        int sum=0;\n        for(int i=0;i<grid.length;i++)\n        {\n            for(int j=0;j<grid[0].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    int a[]=new int[1];\n                    task(grid,i,j,a);\n                    sum=Math.max(sum,a[0]);\n                }\n            }\n        }\n        return sum;\n    }\n    public void task(int grid[][], int i, int j, int a[])\n    {\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\n        {\n            return;\n        }\n        a[0]+=grid[i][j];\n        grid[i][j]=0;\n        task(grid,i+1,j,a);\n        task(grid,i-1,j,a);\n        task(grid,i,j+1,a);\n        task(grid,i,j-1,a);\n        a[0] = 0; \n    }\n}\n",
    "test_cases": [
      "if (new Solution().findMaxFish(new int[][]{{0,2,1,0},{4,0,0,3},{1,0,0,4},{0,3,2,0}}) != 7) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().findMaxFish(new int[][]{{1,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,1}}) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \nr\n\n",
    "test_cases": [
      "LRUCache lRUCache(2); assert(lRUCache.put(1, 1) == nullptr); assert(lRUCache.put(2, 2) == nullptr); assert(lRUCache.get(1) == 1); assert(lRUCache.put(3, 3) == nullptr); assert(lRUCache.get(2) == -1); assert(lRUCache.put(4, 4) == nullptr); assert(lRUCache.get(1) == -1); assert(lRUCache.get(3) == 3); assert(lRUCache.get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4",
    "buggy_code": "\n#define pii pair<int, int>\n#define maxn 10005\n#define inf 1000000000\n\nclass Solution {\npublic:\n    vector<pii>g[maxn];\n    int dis[maxn];\n    int n, m;\n    bool valid(int x, int y) {\n        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;\n        else return false;\n    }\n    void bfs(int s) {\n        deque<int> q;\n        for(int i=0; i<maxn; i++) dis[i] = inf;\n        dis[s] = 0;\n        q.push_front(s);\n        while(!q.empty()){\n            int u = q.front();\n            q.pop_front();\n            for(int i=0; i<g[u].size(); i++){\n                int v = g[u][i].first;\n                int w = g[u][i].second;\n                if(dis[u] + w < dis[v]){\n                    dis[v] == dis[u] + w;\n                    if(w == 1) q.push_back(v);\n                    else q.push_front(v);\n                }\n            }\n        }\n    }\n    int minCost(vector<vector<int>>& grid) {\n        n = grid.size(), m = grid[0].size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                int u = i * m + j;\n                if(valid(i+1, j)) {\n                    int v = (i+1) * m + j;\n                    int w;\n                    if(grid[i][j] == 3) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                }\n                if(valid(i-1, j)) {\n                    int v = (i-1) * m + j;\n                    int w;\n                    if(grid[i][j] == 4) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j+1)) {\n                    int v = i * m + (j+1);\n                    int w;\n                    if(grid[i][j] == 1) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j-1)) {\n                    int v = i * m + (j-1);\n                    int w;\n                    if(grid[i][j] == 2) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n            }\n        }\n        bfs(0);\n        int node = (n * m) - 1;\n        int ans = dis[node];\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.minCost({{1,1,1,1},{2,2,2,2},{1,1,1,1},{2,2,2,2}}) == 3);",
      "assert(solution.minCost({{1,1,3},{3,2,2},{1,1,4}}) == 0);",
      "assert(solution.minCost({{1,2},{4,3}}) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers arr and an integer k.\nA value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.\nIf |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].\nReturn a list of the strongest k values in the array. return the answer in any arbitrary order.\nMedian is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).\n\nFor arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6.\nFor arr = [-7, 22, 17,\u20093], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3.\n\nConstraints:\n1 <= arr.length <= 105\n-105 <= arr[i] <= 105\n1 <= k <= arr.length",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> getStrongest(vector<int>& arr, int k) {\n        vector<pair<int,int>>v;\n        int sum=0,n=arr.size();\n        sort(arr.begin(),arr.end());\n        int median=arr[(n-2)/2]; \n        for(int i=0;i<arr.size();i++)\n        {\n            v.push_back({abs(arr[i]-median),arr[i]});\n        }\n        sort(v.begin(),v.end());\n        reverse(v.begin(),v.end());\n        vector<int>ans;\n        for(int i=0;i<k;i++)\n        {\n            ans.push_back(v[i].second);\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.getStrongest(vector<int>{1,2,3,4,5}, 2) == vector<int>{5,1});",
      "assert(solution.getStrongest(vector<int>{1,1,3,5,5}, 2) == vector<int>{5,5});",
      "assert(solution.getStrongest(vector<int>{6,7,11,7,6,8}, 5) == vector<int>{11,8,6,6,7});"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a binary array nums.\nA subarray of an array is good if it contains exactly one element with the value 1.\nReturn an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 1",
    "buggy_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n       \n        if 1 not in nums: return 0\n\n        nums = ''.join(map(str,nums)).strip('0').split(\"1)\n\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007\n",
    "test_cases": [
      "assert Solution().numberOfGoodSubarraySplits([0, 1, 0, 0, 1]) == 3",
      "assert Solution().numberOfGoodSubarraySplits([0, 1, 0]) == 1"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.\n\nConstraints:\n1 <= k <= n <= 500",
    "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i;\n        }\n        // 1 2 3 4 5 \n        while(q.size() != 1){\n            int i = 1;\n            while(i < k){\n                int f = q.front();\n                q.pop();\n                q.push(f);\n                i++;\n            }\n            q.pop();\n        }\n\n        return q.front();\n    }\n};\n",
    "test_cases": [
      "assert(solution.findTheWinner(5, 2) == 3);",
      "assert(solution.findTheWinner(6, 5) == 1);"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given a positive integer array nums.\nPartition nums into two arrays,\u00a0nums1 and nums2, such that:\n\nEach element of the array nums belongs to either the array nums1 or the array nums2.\nBoth arrays are non-empty.\nThe value of the partition is minimized.\n\nThe value of the partition is |max(nums1) - min(nums2)|.\nHere, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.\nReturn the integer denoting the value of such partition.\n\nConstraints:\n2 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution:\n    def findValueOfPartition(self, nums: Array[int]) -> int:\n           \n        nums.sort()\n        min_diff = float('inf')\n        \n        for i in range(1,len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\n            \n        return min_diff\n",
    "test_cases": [
      "assert Solution().findValueOfPartition([1, 3, 2, 4]) == 1",
      "assert Solution().findValueOfPartition([100, 1, 10]) == 9"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\nprivate:\n    int* num;\n\npublic:\n\n    Solution() {\n        num = new int[10];\n    }\n    \n    ~Solution() {\n        delete[] num;\n    }\n\n    int Rem(int a) num[];\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n        \n        num[5] = n/7;\n\n        for(int i=0;i<num[5];i++); \n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= num[5]*b;\n\n        ans+=ad;\n\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.totalMoney(4) == 10);",
      "assert(solution.totalMoney(10) == 37);",
      "assert(solution.totalMoney(20) == 96);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.\n\nConstraints:\n1 <= k <= n <= 500",
    "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1){\n            i= (i+k)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};\n",
    "test_cases": [
      "assert(solution.findTheWinner(5, 2) == 3);",
      "assert(solution.findTheWinner(6, 5) == 1);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(\"s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minSwaps(\"][][]\") != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minSwaps(\"]]][[[\") != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minSwaps(\"[]\") != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of\u00a0integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\n\ni + 1 where:\u00a0i + 1 < arr.length.\ni - 1 where:\u00a0i - 1 >= 0.\nj where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.\n\nConstraints:\n1 <= arr.length <= 5 * 104\n-108 <= arr[i] <= 108",
    "buggy_code": "\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al)\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n                al.clear();\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minJumps(new int[]{100,-23,-23,404,100,23,23,23,3,404}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minJumps(new int[]{7}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minJumps(new int[]{7,6,9,6,9,6,9,7}) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.\n\nConstraints:\n1 <= n <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};\n",
    "test_cases": [
      "assert(solution.grayCode(2) == vector<int>{0, 1, 3, 2});",
      "assert(solution.grayCode(1) == vector<int>{0, 1});"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n\nConstraints:\n1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, /* String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++)\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++)\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                global i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
    "test_cases": [
      "if (!new Solution().smallestEquivalentString(\"parker\", \"morris\", \"parser\").equals(\"makkek\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().smallestEquivalentString(\"hello\", \"world\", \"hold\").equals(\"hdld\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().smallestEquivalentString(\"leetcode\", \"programs\", \"sourcecode\").equals(\"aauaaaaada\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.\n\nConstraints:\n1 <= num <= 109",
    "buggy_code": "\nclass Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            elif ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]\n        return int(''.join(result[6:]))\n",
    "test_cases": [
      "assert Solution().largestInteger(1234) == 3412",
      "assert Solution().largestInteger(65875) == 87655"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\nReturn the minimum number of operations needed to make s alternating.\n\nConstraints:\n1 <= s.length <= 104\ns[i] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s[i]-'0' != i%2)\n            ans++;\n        }\n        return min(ans, n+ans);\n    }\n};\n",
    "test_cases": [
      "assert(solution.minOperations(\"0100\") == 1);",
      "assert(solution.minOperations(\"10\") == 0);",
      "assert(solution.minOperations(\"1111\") == 2);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i) \n            if(str[0][i]!=str[str.size()-1][i]) //]\n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestCommonPrefix(vector<string>{\"flower\", \"flow\", \"flight\"}) == \"fl\");",
      "assert(solution.longestCommonPrefix(vector<string>{\"dog\", \"racecar\", \"car\"}) == \"\");"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nConstraints:\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++)\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        for(int i =0; i<freq.size(); i++)\n            if(freq[i]!=0)\n                return false;\n\n        return true;\n    }\n'};\n\n\n",
    "test_cases": [
      "assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);",
      "assert(solution.isAnagram(\"rat\", \"car\") == false);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal\"; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestCommonPrefix(vector<string>{\"flower\", \"flow\", \"flight\"}) == \"fl\");",
      "assert(solution.longestCommonPrefix(vector<string>{\"dog\", \"racecar\", \"car\"}) == \"\");"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\n\nConstraints:\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104",
    "buggy_code": "\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int profit=0;\n        for(int i=0; i<prices.length; i++){\n            if(prices[i]>prices[i-1]){\n                profit+=prices[i]-prices[i-1];\n            }\n        }\n        return profit;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxProfit(new int[]{7,1,5,3,6,4}) != 7) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxProfit(new int[]{1,2,3,4,5}) != 4) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maxProfit(new int[]{7,6,4,3,1}) != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\nA boomerang is a set of three points that are all distinct and not in a straight line.\n\nConstraints:\npoints.length == 3\npoints[i].length == 2\n0 <= xi, yi <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    bool isBoomerang(vector<vector<int>>& points) {\n        float a,b,c,d;\n        a = (points[1][1]-points[0][1]);\n        b = (points[1][0]-points[0][0]);\n        c = (points[2][1]-points[1][1]);\n        d = (points[3][0]-points[1][0]);\n        if(b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0])\n        {\n            return false;\n        }\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\n        {\n            return false;\n        }\n        return true;\n    }\n};\n",
    "test_cases": [
      "assert(solution.isBoomerang({{1,1},{2,3},{3,2}}) == true);",
      "assert(solution.isBoomerang({{1,1},{2,2},{3,3}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\nReturn the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.\n\nConstraints:\n3 <= s.length <= 105\ns[i] is either '0' or '1'.",
    "buggy_code": "\nclass Solution:\n    def numWays(self, s: 'str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        cnt1 = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '1':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt1 += 1\n            if cnt1 == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\n",
    "test_cases": [
      "assert Solution().numWays(\"10101\") == 4",
      "assert Solution().numWays(\"1001\") == 0",
      "assert Solution().numWays(\"0000\") == 3"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given a binary tree root, a node X in the tree is named\u00a0good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.\n\nConstraints:\nThe number of nodes in the binary tree is in the range\u00a0[1, 10^5].\nEach node's value is between [-10^4, 10^4].",
    "buggy_code": "\nclass Solution {\n    int count = 0;\n    \n    public void countGoodNodes(TreeNode root, int maximum) {\n            if(root!=null) {\n                if (maximum <= root.val) {\n                    maximum = root.val;\n                    count++;\n                }\n            countGoodNodes(root.left,maximum);\n        } \n            countGoodNodes(root.right, maximum);\n    }\n\n    public int goodNodes(TreeNode root) {\n        int maximum = root.val;\n        countGoodNodes(root,  maximum);\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().goodNodes(new TreeNode(new int[]{3,1,4,3,null,1,5})) != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().goodNodes(new TreeNode(new int[]{3,3,null,4,2})) != 3) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().goodNodes(new TreeNode(new int[]{1})) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.\n\nConstraints:\n1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
    "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]=l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n",
    "test_cases": [
      "assert Solution().findRestaurant([\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]) == [\"Shogun\"]",
      "assert Solution().findRestaurant([\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], [\"KFC\",\"Shogun\",\"Burger King\"]) == [\"Shogun\"]",
      "assert Solution().findRestaurant([\"happy\",\"sad\",\"good\"], [\"sad\",\"happy\",\"good\"]) == [\"sad\",\"happy\"]"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\n\nConstraints:\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\ndef thirdMax(self, nums: List[int]) -> int:\n    return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\n",
    "test_cases": [
      "assert Solution().thirdMax([3, 2, 1]) == 1",
      "assert Solution().thirdMax([1, 2]) == 2",
      "assert Solution().thirdMax([2, 2, 3, 1]) == 1"
    ],
    "language": "python3",
    "bug_type": "illegal indentation",
    "category": "syntax error"
  },
  {
    "task": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\n\nConstraints:\n1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
    "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s)) for s in ans]\n        return ans\n",
    "test_cases": [
      "assert Solution().getAncestors(8, [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]) == [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]",
      "assert Solution().getAncestors(5, [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]) == [[],[0],[0,1],[0,1,2],[0,1,2,3]]"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n    idx[d].popleft()\n    return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n\nConstraints:\n1 <= paragraph.length <= 1000\nparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists of only lowercase English letters.",
    "buggy_code": "\n#Import RegEx\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]\n",
    "test_cases": [
      "assert Solution().mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", [\"hit\"]) == \"ball\"",
      "assert Solution().mostCommonWord(\"a.\", []) == \"a\""
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
    "buggy_code": "\nfrom collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        index = 0\n\n        for num, count in counter.items():\n            nums[index] = num\n            index += 1\n            if count > 2:\n                nums[index] = num\n                index += 1\n\n        return index\n",
    "test_cases": [
      "assert Solution().removeDuplicates([1,1,1,2,2,3]) == 5 and [1,1,2,2,3] == [1,1,2,2,3][:5]",
      "assert Solution().removeDuplicates([0,0,1,1,1,1,2,3,3]) == 7 and [0,0,1,1,2,3,3] == [0,0,1,1,2,3,3][:7]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\nConstraints:\n1 <= columnNumber <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        while n>0:\n            if n%26 == 0:\n                ans+=chr(ord('A')+25)\n                n == 26  \n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]\n",
    "test_cases": [
      "assert Solution().convertToTitle(1) == \"A\"",
      "assert Solution().convertToTitle(28) == \"AB\"",
      "assert Solution().convertToTitle(701) == \"ZY\""
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n\nConstraints:\n1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
    "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=/*.join(word1)\n        word4=/*.join(word2\n        if word3=word4:\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().arrayStringsAreEqual([\"ab\", \"c\"], [\"a\", \"bc\"]) == True",
      "assert Solution().arrayStringsAreEqual([\"a\", \"cb\"], [\"ab\", \"c\"]) == False",
      "assert Solution().arrayStringsAreEqual([\"abc\", \"d\", \"defg\"], [\"abcddefg\"]) == True"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two non-negative integers low and high. Return the count of odd numbers between low and high\u00a0(inclusive).\n\nConstraints:\n0 <= low <= high\u00a0<= 10^9",
    "buggy_code": "\nclass Solution {\n    public int countOdds(int low, int high) {\n        if(low%2==0 && high%2==0) \n            return (high-low)/2;\n        else\n            return ((high-low)/2+1;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().countOdds(3, 7) != 3) System.out.println(\"Test failed for input (3, 7)\");",
      "if (new Solution().countOdds(8, 10) != 1) System.out.println(\"Test failed for input (8, 10)\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.\n\nConstraints:\nn == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
    "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, \n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n + 1):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] -= diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n\nmy_solution = Solution()\nmy_solution.maxPower([1,2,3], 2, 5)\n",
    "test_cases": [
      "assert my_solution.maxPower([1, 2, 4, 5, 0], 1, 2) == 5",
      "assert my_solution.maxPower([4, 4, 4, 4], 0, 3) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n+2]!=null) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numTilings(3) != 5) System.out.println(\"Test failed for input 3\");",
      "if (new Solution().numTilings(1) != 1) System.out.println(\"Test failed for input 1\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal\"; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5,4,3,2,1}), new String[]{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10,3,8,9,4}), new String[]{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] and target consist of only lowercase English letters.\n0 <= startIndex < words.length",
    "buggy_code": "\nclass Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while (true){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\n                return cnt1;\n            }\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\n                return cnt2;\n            }\n        }\n        \n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.closetTarget({\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"}, \"hello\", 1) == 1);",
      "assert(solution.closetTarget({\"a\",\"b\",\"leetcode\"}, \"leetcode\", 0) == 1);",
      "assert(solution.closetTarget({\"i\",\"eat\",\"leetcode\"}, \"ate\", 0) == -1);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.\n\nConstraints:\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
    "buggy_code": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums)\n            atr.add(a);\n        atr.add(target)\n        Collections.sort(atr);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}\n",
    "test_cases": [
      "if (new Solution().searchInsert(new int[]{1, 3, 5, 6}, 5) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().searchInsert(new int[]{1, 3, 5, 6}, 2) != 1) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().searchInsert(new int[]{1, 3, 5, 6}, 7) != 4) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.\n\nConstraints:\n1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
    "buggy_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if d[i] != c[i]: \n                    cnt += 1\n        return cnt\n",
    "test_cases": [
      "assert Solution().minFlips(2, 6, 5) == 3",
      "assert Solution().minFlips(4, 2, 7) == 1",
      "assert Solution().minFlips(1, 2, 3) == 0"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.\nReturn the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 40\n1 <= k <= m * n\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "buggy_code": "\nclass Solution {\n    int [] dirs = {0, 1, 0, -1, 0};\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        if(k >= m+n -2) return m+n-2;\n        \n        boolean[][][] visited = new boolean [m][n][k+1];\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0, k, 0});\n        visited[0][0][k] = true;\n        \n        while(!q.isEmpty()){\n            int [] top = q.poll();\n          \n            int r = top[0], c = top[1], curk = top[2], dist = top[3];\n            \n            if(r == m-1 && c == n -1) return dist;\n            for(int i = 0; i< 5; i++){\n                int nr = r + dirs[i], nc = c + dirs[i + 1];\n                if(nr < 0 || nr == m || nc < 0 || nc == n) continue;\n                int newK = curk - grid[nr][nc];\n            \n                if(newK >= 0 && !visited[nr][nc][newK]){\n                    visited[nr][nc][newK] = true;\n                    q.offer(new int[]{nr, nc, newK, dist + 1});\n                }\n            }\n        }\n        return -1;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().shortestPath(new int[][]{{0,0,0},{1,1,0},{0,0,0},{0,1,1},{0,0,0}}, 1) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().shortestPath(new int[][]{{0,1,1},{1,1,1},{1,0,0}}, 1) != -1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\n\nA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\nThe cost of a path is the sum of costs of nodes in the path.\n\nConstraints:\n3 <= n <= 105\nn + 1 is a power of 2\ncost.length == n\n1 <= cost[i] <= 104",
    "buggy_code": "\nclass Solution {\n    int res = 0;\n    public int minIncrements(int n, int[] cost) {\n        dfs(0, cost;\n        return res;\n    }\n\n    public int dfs(int i, int[] cost) {\n        \n        if (i >= cost.length) return 0;\n        int left = dfs(i * 2, cost, right = dfs(i * 2 + 1, cost);\n        res += Math.abs(left - right);\n        return cost[i - 1] + Math.max(left, right);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minIncrements(7, new int[]{1, 5, 2, 2, 3, 3, 1}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minIncrements(3, new int[]{5, 3, 3}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array deck where deck[i] represents the number written on the ith card.\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\n\nReturn true if such partition is possible, or false otherwise.\n\nConstraints:\n1 <= deck.length <= 104\n0 <= deck[i] < 104",
    "buggy_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m > 2:\n            return True \n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().hasGroupsSizeX([1, 2, 3, 4, 4, 3, 2, 1]) == True",
      "assert Solution().hasGroupsSizeX([1, 1, 1, 2, 2, 2, 3, 3]) == False"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i > n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        \n        print(helper(0, arr.size(), n));\n    }\n\n};\n",
    "test_cases": [
      "assert(solution.numSquares(12) == 3);",
      "assert(solution.numSquares(13) == 2);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed binary string target of length n. You have another binary string s of length n that is initially set to all zeros. You want to make s equal to target.\nIn one operation, you can pick an index i where 0 <= i < n and flip all bits in the inclusive range [i, n - 1]. Flip means changing '0' to '1' and '1' to '0'.\nReturn the minimum number of operations needed to make s equal to target.\n\nConstraints:\nn == target.length\n1 <= n <= 105\ntarget[i] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int minFlips(String target) {\n        int flips = 0;\n        /* char prev = target.charAt(0);\n        if (prev == '1') flips++; */\n\n        for (int i = 1; i < target.length(); i++) {\n            char c = target.charAt(i);\n            if (c != prev) {\n                flips++;\n                prev = c;\n            }\n        }\n        return flips;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minFlips(\"10111\") != 3) System.out.println(\"Test case failed for input: 10111\");",
      "if (new Solution().minFlips(\"101\") != 3) System.out.println(\"Test case failed for input: 101\");",
      "if (new Solution().minFlips(\"00000\") != 0) System.out.println(\"Test case failed for input: 00000\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\n\nRead in and ignore any leading whitespace.\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\nConvert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\nIf the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\nReturn the integer as the final result.\n\nNote:\n\nOnly the space character ' ' is considered a whitespace character.\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\nConstraints:\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.",
    "buggy_code": "\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        long long res = 0; // stores our integer value\n        bool neg = 0; // checks whether integer will be -ve or +ve\n        bool leading = true; // true if theres leading spaces \n        \n        int n = s.size();\n\n        for (int i = 0; i<n; i++) {\n            if (s[i] == ' ') { // checks for leading spaces\n                if (leading) continue;\n                else break;\n            }\n            else if (s[i] == '-') { // checks -ve \n                if (i+1 < n && isdigit(s[i+1])) neg = 1;\n                else break; // break if next char is non-digit\n            }\n            else if (s[i] == '+') { // checks for +ve\n                if (i+1 < n && isdigit(s[i+1])) neg = 0;\n                else break; // break if next char is non-digit\n            }\n            else if (!isdigit(s[i])) break; // break on encoutring non-digit\n            else { // storing our integer value to res\n                if (res < 1e11) {\n                    res = res*10 + (s[i]-'0');\n                    if (i+1 < n && !isdigit(s[i+1])) \n                        break;// break if next char is non-digit\n                }\n                else break;\n                leading = false; // tells that integer has been encoutered\n            }\n        }\n\n        if (res > INT_MAX && neg) return \"INT_MIN\";\n        if (res > INT_MAX) return \"INT_MAX\";\n\n        return neg ? -1*res : res;\n    }\n};\n",
    "test_cases": [
      "assert(solution.myAtoi(\"42\") == 42);",
      "assert(solution.myAtoi(\"   -42\") == -42);",
      "assert(solution.myAtoi(\"4193 with words\") == 4193);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.\n\nConstraints:\n1 <= start.length\u00a0<= 104\nstart.length == end.length\nBoth start and end will only consist of characters in 'L', 'R', and\u00a0'X'.",
    "buggy_code": "\nclass Solution {\n    public boolean canTransform(String start, String end) {\n        Queue<Node> logs = new LinkedList<>();\n\n        int count = 0;\n        for (char c : start.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                logs.add(new Node1(c, count));\n            }\n        }\n\n        count = 0;\n        for (char c : end.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                if (logs.isEmpty()) return false;\n\n                Node node = logs.poll();\n                if (c != node.c) return false;\n\n                if (c == 'L' && count > node.count) return false;\n                if (c == 'R' && count < node.count) return false;                \n            }\n        }\n\n        return logs.isEmpty();\n    }\n\n    class Node {\n        public Character c;\n        public int count;\n\n        public Node(Character c, int count) {\n            this.c = c;\n            this.count = count;\n        }\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().canTransform(\"RXXLRXRXL\", \"XRLXXRRLX\")) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().canTransform(\"X\", \"L\")) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.\n\nConstraints:\n1 <= k <= n <= 500",
    "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n+1; i++)v.push_back(i);\n        int i=0;\n        undefined(i+k-1)%(v.size());\n        while (v.size() != 1){\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};\n",
    "test_cases": [
      "assert(solution.findTheWinner(5, 2) == 3);",
      "assert(solution.findTheWinner(6, 5) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(board, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            return;\n        }\n\n        for (int col = 0; col < board.length - 1; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().solveNQueens(4).equals(Arrays.asList(Arrays.asList(\".Q..\",\"...Q\",\"Q...\",\"..Q.\"), Arrays.asList(\"..Q.\",\"Q...\",\"...Q\",\".Q..\")))) System.out.println(\"Test case failed for n = 4\");",
      "if (!new Solution().solveNQueens(1).equals(Arrays.asList(Arrays.asList(\"Q\")))) System.out.println(\"Test case failed for n = 1\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.\n\nConstraints:\n1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n",
    "test_cases": [
      "assert Solution().longestValidSubstring(\"cbaaaabc\", [\"aaa\", \"cb\"]) == 4",
      "assert Solution().longestValidSubstring(\"leetcode\", [\"de\", \"le\", \"e\"]) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.\n\nConstraints:\nn == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
    "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return calculateArea();\n}\nprivate:\n    int calculateArea();\n};\n",
    "test_cases": [
      "assert(solution.maxWidthOfVerticalArea({{8,7},{9,9},{7,4},{9,7}}) == 1);",
      "assert(solution.maxWidthOfVerticalArea({{3,1},{9,0},{1,0},{1,4},{5,3},{8,8}}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==1 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().areAlmostEqual(\"bank\", \"kanb\") == True",
      "assert Solution().areAlmostEqual(\"attack\", \"defend\") == False",
      "assert Solution().areAlmostEqual(\"kelb\", \"kelb\") == True"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = arr; \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/fun(s, k , index+, prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][prev];\n               else if(abs(s[index]-'a') - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n  fun(        }\n        }\n\n       return max(dp[0][s[0]-'a']) , dp[0][26]);\n   }\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return SolveByTab(s, k);\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n\nConstraints:\n0 <= s.length <= 3 * 104\ns[i] is '(', or ')'.",
    "buggy_code": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) == '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.peek());\n            }\n        }\n        return \"n;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().longestValidParentheses(\"(()\") != 2) System.out.println(\"Test failed for input '(()'\");",
      "if (new Solution().longestValidParentheses(\")()())\") != 4) System.out.println(\"Test failed for input ')()())'\");",
      "if (new Solution().longestValidParentheses(\"\") != 0) System.out.println(\"Test failed for input ''\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\nConstraints:\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.",
    "buggy_code": "\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]] '\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            pre[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True\n",
    "test_cases": [
      "assert Solution().canFinish(2, [[1, 0]]) == True",
      "assert Solution().canFinish(2, [[1, 0], [0, 1]]) == False"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.\n\nConstraints:\n1 <= num <= 109",
    "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parse_int(res);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().largestInteger(1234) != 3412) System.out.println(\"Test failed for input 1234\");",
      "if (new Solution().largestInteger(65875) != 87655) System.out.println(\"Test failed for input 65875\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sort(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\nk == queries.length\n1 <= k <= 104\n1 <= grid[i][j], queries[i] <= 106",
    "buggy_code": "\nclass Solution {\n    public int[] maxPoints(int[][] a, int[] q) {\n        \n        int n = a.length;\n        int m = a[0].length;\n        \n        int l = q.length;\n        int[][] p = new int[l + 1][2];\n        \n        for(int i = 0 ; i < l ; i++) {\n            \n            p[i][0] = i;\n            p[i][1] = q[i];\n        }\n        \n        Arrays.sort(p, (o1,o2)-> {\n            \n            if(o1[1] == o2[1]) {\n                \n                return Integer.compare(o1[0],o2[0]);\n            }\n            return Integer.compare(o1[1],o2[1]);\n        });\n        \n        PriorityQueue<int[]> qu = null\n        \n        qu.add(new int[]{0,0});\n        \n        boolean[][] v = new boolean[n][m];\n        int cnt = 0;\n        int idx = 0;\n        \n        while(qu.size() > 0 && idx < l) {\n            \n            int[] f = qu.remove();\n            int r = f[0] , c = f[1];\n            \n            if(v[r][c]) continue;\n            \n            v[r][c] = true;\n            \n            if(a[r][c] < p[idx][1]) {\n                \n                cnt++;\n            }\n            else{\n                \n                q[p[idx][0]] = cnt;\n                idx++;\n                qu.add(f);\n                v[r][c] = false;\n                continue;\n            }\n            \n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\n        }\n        \n        while(idx < l) {\n            \n            q[p[idx][0]] = cnt;\n            idx++;\n        }\n        \n        return q;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().maxPoints(new int[][]{{1,2,3},{2,5,7},{3,5,1}}, new int[]{5,6,2}), new int[]{5,8,1})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().maxPoints(new int[][]{{5,2,1},{1,1,2}}, new int[]{3}), new int[]{0})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\u00a0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\u00a0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.\n\nConstraints:\n1 <= n <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n-1)%1000000007)%1000000007;\n    }\n    int numPrimeArrangements(int n) {\n        if(n=1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<=sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};\n",
    "test_cases": [
      "assert(solution.numPrimeArrangements(5) == 12);",
      "assert(solution.numPrimeArrangements(100) == 682289015);"
    ],
    "language": "cpp",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n\nConstraints:\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
    "buggy_code": "\nclass Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n\n        if(right - left <= 1) {\n            if(right - left == 1) {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n\n        int mid = (left + right)/2;\n\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper;\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n\n        int i = left;\n        int j = mid;\n\n        int n = 0;\n        int m = 0;\n\n        vector<long> cache(right - left, 0);\n\n        int k = 0;\n\n        while(i < mid)\n        {\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n            {\n                n++;\n            }\n\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n            {\n                m++;\n            }\n\n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n\n            cache[k++] = sums[i++];\n\n            count += m-n;\n        }\n\n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n\n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum;\n        \n    }\n\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};\n",
    "test_cases": [
      "assert(solution.countRangeSum(vector<int>{-2, 5, -1}, -2, 2) == 3);",
      "assert(solution.countRangeSum(vector<int>{0}, 0, 0) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++)\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count--;\n            }\n        return count;\n    } */\n}\n\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\nA subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\nFor each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\nReturn an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\nNotice\u00a0that\u00a0the distance between the two cities is the number of edges in the path between them.\n\nConstraints:\n2 <= n <= 15\nedges.length == n-1\nedges[i].length == 2\n1 <= ui, vi <= n\nAll pairs (ui, vi) are distinct.",
    "buggy_code": "\nclass Solution:\n    # odd/even diameter couned individually\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        adj = [[] for i in range(n)]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\n            if len(q)<len(p): p,q = q,p\n            res = [0]*len(q)\n            res[0] = p[0]*q[0]\n            for i in range(1,len(p)): p[i] += p[i-1]\n            for i in range(1,len(q)): q[i] += q[i-1]\n            for i in range(1,len(p)):\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\n            for i in range(len(p),len(q)):\n                res[i] = (q[i]-q[i-1])*p[-1]\n            return res\n            \n        def dfs(r,p): # num of subtree rooted at r with given depth\n            d = [1]\n            for v in undefined_list:\n                if v==p: continue\n                t = [1]+dfs(v,r)\n                d = comb(t,d)\n            return d\n        #end dfs\n        ans = [0]*n\n        # odd diameter with (u,v) as center edge\n        for u,v in edges:\n            u -= 1; v-=1\n            p = dfs(u,v)\n            q = dfs(v,u)\n            for i in range(min(len(p),len(q))):\n                ans[i+i+1] += p[i]*q[i]\n        #even diamter with v as center vertex\n        for v in range(n): \n            if len(adj[v])==1: continue \n            tree = [1]+dfs(adj[v][0],v) #tree with depth\n            curr = [0]*n\n            for u in adj[v][1:]:\n                q = [1]+dfs(u,v)\n                # curr tree + new small\n                j = 1; t = q[1]+1 # prefix sum of q\n                for i in range(4,n,2):\n                    while j+1<min(i//2,len(q)):\n                        j += 1; t += q[j]\n                    curr[i] *= t\n                # curr tree + same height\n                for i in range(min(len(tree),len(q))):\n                    curr[i+i] += tree[i]*q[i]\n                tree = comb(tree,q)\n            for i in range(2,n,2):\n                ans[i] += curr[i]\n        #end\n        return ans[1:]\n",
    "test_cases": [
      "assert Solution().countSubgraphsForEachDiameter(4, [[1,2],[2,3],[2,4]]) == [3,4,0]",
      "assert Solution().countSubgraphsForEachDiameter(2, [[1,2]]) == [1]",
      "assert Solution().countSubgraphsForEachDiameter(3, [[1,2],[2,3]]) == [2,1]"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\n\nThe chosen integers have to be in the range [1, n].\nEach integer can be chosen at most once.\nThe chosen integers should not be in the array banned.\nThe sum of the chosen integers should not exceed maxSum.\n\nReturn the maximum number of integers you can choose following the mentioned rules.\n\nConstraints:\n1 <= banned.length <= 104\n1 <= banned[i], n <= 104\n1 <= maxSum <= 109",
    "buggy_code": "\nclass Solution {\n    public int maxCount(int[] banned, int n, int maxSum) {\n\n        // Create a HashSet of banned integers for fast lookup\n        Set<Integer> banSet = new HashSet<>();\n        for (int num : banned) {\n            banSet.add(num);\n        }\n\n        // Initialize count and sum to 0\n        int count = 0;\n        int sum = 0;\n\n        // Iterate over the range [1, n]\n        for (int i = 1; i <= n; i++) {\n\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\n            if (!banSet.contains(i) && (sum + i < maxSum)) {\n            // Increment count and add the current integer to sum\n                count++;\n                sum += i;\n            }\n        }\n    // Return the maximum count of chosen integers\n    return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxCount(new int[]{1, 6, 5}, 5, 6) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxCount(new int[]{1, 2, 3, 4, 5, 6, 7}, 8, 1) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maxCount(new int[]{11}, 7, 50) != 7) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\n\nConstraints:\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution {\n    public void moveZeroes(int[] arr) {\n    int n = arr.length;\n    if(n<=1) return;\n    int s=0;\n    int e=1;\n    while(e<=n){\n        if(arr[s]==0 && arr[e]!=0){\n            int temp = arr[s];\n            arr[s] = arr[e];\n            arr[e] = temp;\n            s++;\n            e++;\n        }else if(arr[s]==0 && arr[e]==0){\n            e++;\n        }else{\n            s++;\n            e++;\n        }\n    }\n    }\n}\n",
    "test_cases": [
      "int[] nums1 = {0, 1, 0, 3, 12}; new Solution().moveZeroes(nums1); System.out.println(Arrays.equals(nums1, new int[]{1, 3, 12, 0, 0}) ? \"Test 1 Passed\" : \"Test 1 Failed\");",
      "int[] nums2 = {0}; new Solution().moveZeroes(nums2); System.out.println(Arrays.equals(nums2, new int[]{0}) ? \"Test 2 Passed\" : \"Test 2 Failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n    idx[d].remove()\n    return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])\n\nConstraints:\n3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: undefList[int]) -> bool:\n        total = sum(arr)\n            each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False\n",
    "test_cases": [
      "assert Solution().canThreePartsEqualSum([0,2,1,-6,6,-7,9,1,2,0,1]) == True",
      "assert Solution().canThreePartsEqualSum([0,2,1,-6,6,7,9,-1,2,0,1]) == False",
      "assert Solution().canThreePartsEqualSum([3,3,6,5,-2,2,5,1,-9,4]) == True"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i = len(toppingCosts+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n",
    "test_cases": [
      "if (new Solution().countNegatives(new int[][]{{4,3,2,-1},{3,2,1,-1},{1,1,-1,-2},{-1,-1,-2,-3}}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countNegatives(new int[][]{{3,2},{1,0}}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5,4,3,2,1}), new String[]{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10,3,8,9,4}), new String[]{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i = len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\n\nConstraints:\n1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
    "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        \n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-1]\n            stack.append(i)\n        return res % (10**9 + 7)\n",
    "test_cases": [
      "assert Solution().sumSubarrayMins([3, 1, 2, 4]) == 17",
      "assert Solution().sumSubarrayMins([11, 81, 94, 43, 3]) == 444"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\nConstraints:\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
    "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n",
    "test_cases": [
      "assert(solution.checkValidGrid(vector<vector<int>>{{0,11,16,5,20},{17,4,19,10,15},{12,1,8,21,6},{3,18,23,14,9},{24,13,2,7,22}}) == true);",
      "assert(solution.checkValidGrid(vector<vector<int>>{{0,3,6},{5,8,1},{2,7,4}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):\n                        distance[ci][cj] = self.sum(d, grid[ci][cj])\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n",
    "test_cases": [
      "assert Solution().minimumObstacles([[0,1,1],[1,1,0],[1,1,0]]) == 2",
      "assert Solution().minimumObstacles([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] and target consist of only lowercase English letters.\n0 <= startIndex < words.length",
    "buggy_code": "\nclass Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while (true){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\n                return cnt1;\n            }\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\n                return cnt2;\n            }\n            i--; j++;\n        }\n        \n        return calculateDistance(target, n); \n    }\n};\n",
    "test_cases": [
      "assert(solution.closetTarget(vector<string>{\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"}, \"hello\", 1) == 1);",
      "assert(solution.closetTarget(vector<string>{\"a\",\"b\",\"leetcode\"}, \"leetcode\", 0) == 1);",
      "assert(solution.closetTarget(vector<string>{\"i\",\"eat\",\"leetcode\"}, \"ate\", 0) == -1);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(self.fizz())\n            elif i%5==0:\n                l.append(self.buzz())\n            \n        return l\n",
    "test_cases": [
      "assert Solution().fizzBuzz(3) == [\"1\", \"2\", \"Fizz\"]",
      "assert Solution().fizzBuzz(5) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
      "assert Solution().fizzBuzz(15) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.\n\nConstraints:\n1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
    "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        /count the triplets\n        int n = s.length();\n    \n        int a=0;\n        int b=0;\n\n        for(int i=1; i<n; i++) \n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A'&&s.charAt(i+1)=='A')\n            a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n                    b++;\n        }\n\n        if(a<=''        b)\n        returnfalse;\n else\n            return true;\n}\nValidaResult()}\n\n    private boolean ValidateResult() {\n        \n    \n}\n",
    "test_cases": [
      "if (new Solution().winnerOfGame(\"AAABABB\") != true) System.out.println(\"Test failed for input: AAABABB\");",
      "if (new Solution().winnerOfGame(\"AA\") != false) System.out.println(\"Test failed for input: AA\");",
      "if (new Solution().winnerOfGame(\"ABBBBBBBAAA\") != false) System.out.println(\"Test failed for input: ABBBBBBBAAA\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s containing lowercase letters and an integer k. You need to :\n\nFirst, change some characters of s to other lowercase English letters.\nThen divide s into k non-empty disjoint substrings such that each substring is a palindrome.\n\nReturn the minimal number of characters that you need to change to divide the string.\n\nConstraints:\n1 <= k <= s.length <= 100.\ns only contains lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n\t\t#This is the cost function \n        \n        def Cost(s):\n            i,j,c=0,len(s)-1,0\n            \n            while i<j:\n                if s[i]!=s[j]:c+=1\n                j-=1\n                i+=1\n            return c\n        \n        dp={}\n        \n\t\t# Recursion\n\t\t\n        def A(s,k):\n\t\t\t# Memoization\n            if (s,k) in dp:\n                return dp[(s,k)]\n\t\t\t# if k==1 then we want the whole string there is no other way \n            if k==1:\n                return Cost(s)\n            \n\t\t\t#intial value to max\n            f=float('inf')\n            \n            #start checking whole string \n            for x in range(1,len(s)+1):\n                #check wheather if both the strings exist.\n                if len(s[:x]) and len(s[x:]):\n\t\t\t\t\n                    #if exist we find the cost recursively assign min value \n                    f=min(f,Cost(s[:x])+A(s[x:],k-1'))\n             #store the min value       \n            dp[(s,k)]=f\n\t\t\t\n            return dp[(s,k)]\n        return A(s,k)\n",
    "test_cases": [
      "assert Solution().palindromePartition(\"abc\", 2) == 1",
      "assert Solution().palindromePartition(\"aabbc\", 3) == 0",
      "assert Solution().palindromePartition(\"leetcode\", 8) == 0"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\n\nConstraints:\n1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
    "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)+1): \n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1] > sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n\n",
    "test_cases": [
      "assert Solution().checkValidString(\"()\") == True",
      "assert Solution().checkValidString(\"(*)\") == True",
      "assert Solution().checkValidString(\"(*))\") == True"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.left)\n               if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n\nConstraints:\n1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
    "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n];\n        \n        for(int i=0;i<n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            /\n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - set2.size();\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{1,2,3,4,5}), new int[]{-3,-1,1,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{3,2,3,4,2}), new int[]{-2,-1,0,2,3})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nConstraints:\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return 'false;\n        }\n        return true;\n    }\n};\n",
    "test_cases": [
      "assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);",
      "assert(solution.isAnagram(\"rat\", \"car\") == false);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.\nYou have two robots that can collect cherries for you:\n\nRobot #1 is located at the top-left corner (0, 0), and\nRobot #2 is located at the top-right corner (0, cols - 1).\n\nReturn the maximum number of cherries collection using both robots by following the rules below:\n\nFrom a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1).\nWhen any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\nWhen both robots stay in the same cell, only one takes the cherries.\nBoth robots cannot move outside of the grid at any moment.\nBoth robots should reach the bottom row in grid.\n\nConstraints:\nrows == grid.length\ncols == grid[i].length\n2 <= rows, cols <= 70\n0 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)\n    {\n        if(j1<0 || j2<0 || j1>c || j2>c) return -1e8;\n        if(i==r-1)\n        {\n            if(j1==j2) return grid[i][j1];\n            else return grid[i][j1]+grid[i][j2];\n        }\n        \n        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];\n        \n        int maxi=-1e8;\n        for(int dj1=-1; dj1<=1; dj1++)\n        {\n            for(int dj2=-1; dj2<=1; dj2++)\n            {\n                int value=0;\n                if(j1==j2) value=grid[i][j1];\n                else value=grid[i][j1]+grid[i][j2];\n                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);\n                maxi=max(maxi, value);\n            }\n        }\n        return dp[i][j1][j2]=maxi;\n    }\n    \n    int cherryPickup(vector<vector<int>>& grid) {\n        int r=grid.size();\n        int c=grid[0].size();\n        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));\n        return f(0, 0, c-1, r, c, grid, dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.cherryPickup(vector<vector<int>>{{3,1,1},{2,5,1},{1,5,5},{2,1,1}}) == 24);",
      "assert(solution.cherryPickup(vector<vector<int>>{{1,0,0,0,0,0,1},{2,0,0,0,0,3,0},{2,0,9,0,0,0,0},{0,3,0,5,4,0,0},{1,0,2,3,0,0,6}}) == 28);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if (flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0): flowerbed[i]=1; n-=1\n            else if(flowerbed[i]==1): n-=1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1) == True",
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        } return ans;\n    le{\n                prevLazer = 0;\n            \n        }\n        return \"The total number of beams is: \" + ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n] = -1) return dp[n];\n\n        return dp[n] == 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numTilings(3) != 5) System.out.println(\"Test failed for input 3\");",
      "if (new Solution().numTilings(1) != 1) System.out.println(\"Test failed for input 1\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
    "buggy_code": "\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = u;\n            size[u-1] += size[v;\n        }\n        else{\n            par[u-1] = v;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n",
    "test_cases": [
      "assert(solution.hasValidPath({{2,4,3},{6,5,2}}) == true);",
      "assert(solution.hasValidPath({{1,2,1},{1,2,1}}) == false);",
      "assert(solution.hasValidPath({{1,1,2}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col <= COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n",
    "test_cases": [
      "if (new Solution().countNegatives(new int[][]{{4,3,2,-1},{3,2,1,-1},{1,1,-1,-2},{-1,-1,-2,-3}}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countNegatives(new int[][]{{3,2},{1,0}}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col\u00a0grid\u00a0of integers, how many 3 x 3 \"magic square\" subgrids are there?\u00a0 (Each subgrid is contiguous).\n\nConstraints:\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15",
    "buggy_code": "\nclass Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        res = 0\n\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\n\n\n        for i in range(M):\n            for j in range(N):\n                arr = []\n\n                for k in range(3):\n                    if k + i >= M:\n                        break\n                    arr.append(tuple(grid[i + k][j:j + 3]))\n                \n                arr.sort(key=lambda x: x[0])\n\n                if tuple(arr) in solution:\n                    res += 1\n                else:\n                    for row in arr:\n                        row = self.reverse_array(row)\n\n                    if tuple(arr) in solution:\n                        res += 1\n        \n        return res\n",
    "test_cases": [
      "assert Solution().numMagicSquaresInside([[4,3,8,4],[9,5,1,9],[2,7,6,2]]) == 1",
      "assert Solution().numMagicSquaresInside([[8]]) == 0"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.\n\nConstraints:\n1 <= k <= n <= 1000",
    "buggy_code": "\nclass Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        j = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                num = i\n                j += 1\n            if j == k:\n                break\n        return num if j == k+1 else -1\n",
    "test_cases": [
      "assert Solution().kthFactor(12, 3) == 3",
      "assert Solution().kthFactor(7, 2) == 7",
      "assert Solution().kthFactor(4, 4) == -1"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5,4,3,2,1}), new String[]{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10,3,8,9,4}), new String[]{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\nYou will do the following steps repeatedly until all cards are revealed:\n\nTake the top card of the deck, reveal it, and take it out of the deck.\nIf there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\nIf there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\nReturn an ordering of the deck that would reveal the cards in increasing order.\nNote that the first entry in the answer is considered to be the top of the deck.\n\nConstraints:\n1 <= deck.length <= 1000\n1 <= deck[i] <= 106\nAll the values of deck are unique.",
    "buggy_code": "\nclass Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(0))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return deck[j] for i,j in ans\n",
    "test_cases": [
      "assert Solution().deckRevealedIncreasing([17, 13, 11, 2, 3, 5, 7]) == [2, 13, 3, 11, 5, 17, 7]",
      "assert Solution().deckRevealedIncreasing([1, 1000]) == [1, 1000]"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.\n\nConstraints:\n2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size();i++){\n            if(nums[i] = nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.applyOperations(vector<int>{1,2,2,1,1,0}) == vector<int>{1,4,2,0,0,0});",
      "assert(solution.applyOperations(vector<int>{0,1}) == vector<int>{1,0});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.\n\nConstraints:\n2 <= arr.length <= 1000\n-106 <= arr[i] <= 106",
    "buggy_code": "\nclass Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0]; /\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                continue;\n            }else{\n                temp=false;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n",
    "test_cases": [
      "if (new Solution().canMakeArithmeticProgression(new int[]{3, 5, 1}) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().canMakeArithmeticProgression(new int[]{1, 2, 4}) != false) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\nConstraints:\n1 <= paths.length <= 100\npaths[i].length == 2\n1 <= cityAi.length, cityBi.length <= 10\ncityAi != cityBi\nAll strings consist of lowercase and uppercase English letters and the space character.",
    "buggy_code": "\nclass Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        unordered_set<string> st;\n        for (auto row : paths)st.insert(row[0]); \n        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);\n        return *st.end();\n    }\n};\n",
    "test_cases": [
      "assert(solution.destCity({{\"London\",\"New York\"},{\"New York\",\"Lima\"},{\"Lima\",\"Sao Paulo\"}}) == \"Sao Paulo\");",
      "assert(solution.destCity({{\"B\",\"C\"},{\"D\",\"B\"},{\"C\",\"A\"}}) == \"A\");",
      "assert(solution.destCity({{\"A\",\"Z\"}}) == \"Z\");"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\n\nConstraints:\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104",
    "buggy_code": "\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int profit=0\n        for(int i=1; i<prices.length; i++){\n            if(prices[i]>prices[i-1]){\n                profit+=prices[i]-prices[i-1];\n            }\n        }\n        return profit;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxProfit(new int[]{7,1,5,3,6,4}) != 7) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxProfit(new int[]{1,2,3,4,5}) != 4) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maxProfit(new int[]{7,6,4,3,1}) != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n\nConstraints:\n1 <= piles.length <= 104\npiles.length <= h <= 109\n1 <= piles[i] <= 109",
    "buggy_code": "\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def check(x):\n            return sum(ceil(ele/x) for ele in UndefinedList) <= h\n\n        l = 1\n        r = max(piles)\n        while l < r:\n            mid = (l+r) >> 1\n            if not check(mid):\n                l=mid+1\n            else:\n                r=mid\n        return l\n",
    "test_cases": [
      "assert Solution().minEatingSpeed([3,6,7,11], 8) == 4",
      "assert Solution().minEatingSpeed([30,11,23,4,20], 5) == 30",
      "assert Solution().minEatingSpeed([30,11,23,4,20], 6) == 23"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\nn >= 3\nxi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\n\nConstraints:\n3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=del nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<=n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 0;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<=n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};\n",
    "test_cases": [
      "assert(solution.lenLongestFibSubseq(vector<int>{1,2,3,4,5,6,7,8}) == 5);",
      "assert(solution.lenLongestFibSubseq(vector<int>{1,3,7,11,12,14,18}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n",
    "test_cases": [
      "assert Solution().minimumObstacles([[0,1,1],[1,1,0],[1,1,0]]) == 2",
      "assert Solution().minimumObstacles([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.\n\nConstraints:\n1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    var dp = function(i,s,prev,k,ct,n,dct {\n        if(k<0) {\n            return Number.POSITIVE_INFINITY;\n        }\n        if(i>=n){\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            return x;\n        }\n        if((i,prev,ct,k) in dct) {\n            return dct[(i,prev,ct,k)];\n        }\n        if(s[i]==prev){\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct);\n        } else{\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct);\n        }\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct);\n        dct[(i,prev,ct,k)]=Math.min(inc,exc);\n        return Math.min(inc,exc)\n    }\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n",
    "test_cases": [
      "assert Solution().getLengthOfOptimalCompression(\"aaabcccd\", 2) == 4",
      "assert Solution().getLengthOfOptimalCompression(\"aabbaa\", 2) == 2",
      "assert Solution().getLengthOfOptimalCompression(\"aaaaaaaaaaa\", 0) == 3"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n\nConstraints:\nk == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.",
    "buggy_code": "\nclass Solution:\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n    head = temp = ListNode()\n    arr = []\n\n    for ls in lists:\n        while ls:\n            arr.append(ls.val)\n            ls = ls.next\n\n    for val in sorted(arr, reverse=True):   \n        temp.next = ListNode()\n        temp = temp.next\n        temp.val = val\n\n    return head.next\n",
    "test_cases": [
      "assert Solution().mergeKLists([ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6))]) == ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(4, ListNode(5, ListNode(6)))))))))",
      "assert Solution().mergeKLists([]) == None",
      "assert Solution().mergeKLists([None]) == None"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].\n\nConstraints:\n1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j]\u00a0<= 4*106",
    "buggy_code": "\nclass Solution {\npublic:\n    bool check(int x){\n        if(x==1)return false;\n        for(int i = 2; i*i<=x; i++){\n            if(x%i==0)return false;\n        }\n        return true;\n    }\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int i,ans=0,n=nums.size();\n        for(i = 0; i < n; i++){\n            if(check(nums[i][i]) && nums[i][i]>ans){\n                ans = nums[i][i];\n            }\n            if(twosDiagonalCheck(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\n                ans = nums[i][n-1-i];\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.diagonalPrime(vector<vector<int>>{{1,2,3},{5,6,7},{9,10,11}}) == 11);",
      "assert(solution.diagonalPrime(vector<vector<int>>{{1,2,3},{5,17,7},{9,11,10}}) == 17);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0,1,-1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0,1,-1});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\nConstraints:\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size();\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i+1];\n        }\n        nums=temp;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rotate(nums = {1,2,3,4,5,6,7}, k = 3) == vector<int>{5,6,7,1,2,3,4});",
      "assert(solution.rotate(nums = {-1,-100,3,99}, k = 2) == vector<int>{3,99,-1,-100});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3, 4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  \n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.\n\nConstraints:\n2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:ans){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.applyOperations(vector<int>{1,2,2,1,1,0}) == vector<int>{1,4,2,0,0,0});",
      "assert(solution.applyOperations(vector<int>{0,1}) == vector<int>{1,0});"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/\n   }\n\n   \n};\n",
    "test_cases": [
      "assert(solution.SolveByMemo(\"acfgbd\", 2, 0, 0, dp) == 4);",
      "assert(solution.SolveByMemo(\"abcd\", 3, 0, 0, dp) == 4);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given the root of a binary tree, return the sum of all left leaves.\nA leaf is a node with no children. A left leaf is a leaf that is the left child of another node.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 1000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    static int result;\n\n    public int sumOfLeftLeaves(TreeNode root) {\n        result=0;\n\n        task(root.left, true);\n\n        task(root.right, false);\n\n        calculate(root);\n\n        return result;\n    }\n\n    static void task(TreeNode root, boolean flag){\n        if(root == null) return;\n\n        if(flag && root.left==null && root.right==null) result+=root.val;\n\n        task(root.left, true);\n        task(root.right, false);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().sumOfLeftLeaves(new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7)))) != 24) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().sumOfLeftLeaves(new TreeNode(1)) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n    for i in range(0, len(grid)):\n        grid[i].sort()\n    n = len(grid[0])\n    res = 0\n    for j in range(0, n+1):\n        ans = 0\n        for i in range(0, len(grid)):\n            ans = max(ans, grid[i].pop(-j))  \n        res += ans\n            \n    return res\n",
    "test_cases": [
      "assert Solution().deleteGreatestValue([[1,2,4],[3,3,1]]) == 8",
      "assert Solution().deleteGreatestValue([[10]]) == 10"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.\n\nConstraints:\nn == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
    "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minScoreTriangulation(new int[]{1, 2, 3}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minScoreTriangulation(new int[]{3, 7, 4, 5}) != 144) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minScoreTriangulation(new int[]{1, 3, 1, 4, 1, 5}) != 13) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.\n\nConstraints:\nThe number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val = root.val: \n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n",
    "test_cases": [
      "assert Solution().isSubPath(ListNode(4, ListNode(2, ListNode(8))), TreeNode(1, TreeNode(4), TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8)))))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6)))), TreeNode(1, TreeNode(4), TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8)))))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6, ListNode(8))))), TreeNode(1, TreeNode(4), TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8)))))) == False"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0, 1, -1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0, 1, -1});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n\nConstraints:\n1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
    "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=/*.join(word1.reverse()\n        word4=/*.join(word2)\n        if word3=word4:\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().arrayStringsAreEqual([\"ab\", \"c\"], [\"a\", \"bc\"]) == True",
      "assert Solution().arrayStringsAreEqual([\"a\", \"cb\"], [\"ab\", \"c\"]) == False",
      "assert Solution().arrayStringsAreEqual([\"abc\", \"d\", \"defg\"], [\"abcddefg\"]) == True"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\nConstraints:\n1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 105.",
    "buggy_code": "\nclass Solution {\n    String b;\n\n    HashMap < String, Integer > mpp;\n\n    List < List < String >> ans;\n    private void dfs(String word, List < String > seq) {\n\n        if (word.equals(b)) {\n\n            List < String > dup = new ArrayList < > (seq);\n            Collections.reverse(dup);\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        for (int i = 0; i < sz; i++) {\n\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray);\n                if (mpp.containsKey(replacedWord) &&\n                    mpp.get(replacedWord) + 1 == steps) {\n\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List < List < String >> findLadders(String beginWord, String endWord,\n        List < String > wordList) {\n\n        Set < String > st = new HashSet < String > ();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n        Queue < String > q = new LinkedList < > ();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap < > ();\n\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n\n            if (word.equals(endWord)) break;\n\n            for (int i = 0; i < sizee; i++) {\n\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray);\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n\n                        mpp.put(replacedWord, steps + 1;\n                    }\n                }\n\n\n            }\n        }\n        ans = new ArrayList < > ();\n\n        if (mpp.containsKey(endWord) == true) {\n            List < String > seq = new ArrayList < > ();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().findLadders(\"hit\", \"cog\", Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\")).equals(Arrays.asList(Arrays.asList(\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"), Arrays.asList(\"hit\",\"hot\",\"lot\",\"log\",\"cog\")))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().findLadders(\"hit\", \"cog\", Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\")).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.add(levels)\n        return lst[::-1]\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\nk == queries.length\n1 <= k <= 104\n1 <= grid[i][j], queries[i] <= 106",
    "buggy_code": "\nclass Solution {\n    public int[] maxPoints(int[][] a, int[] q) {\n        \n        int n = a.length;\n        int m = a[0].length;\n        \n        int l = q.length;\n        int[][] p = new int[l][2];\n        \n        for(int i = 0 ; i < l ; i++) {\n            \n            p[i][0] = i;\n            p[i][1] = q[i];\n        }\n        \n        Arrays.sort(p, (o1,o2)-> {\n            \n            if(o1[1] == o2[1]) {\n                \n                Integer.compare(o1[0],o2[0]);\n            }\n            \n            return Integer.compare(o1[1],o2[1]);\n        });\n        \n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->\n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\n    \n        \n        qu.add(new int[]{0,0});\n        \n        boolean[][] v = new boolean[n][m];\n        int cnt = 0;\n        int idx = 0;\n        \n        while(qu.size() > 0 && idx < l) {\n            \n            int[] f = qu.remove();\n            int r = f[0] , c = f[1];\n            \n            if(v[r][c]) continue;\n            \n            v[r][c] = true;\n            \n            if(a[r][c] < p[idx][1]) {\n                \n                cnt++;\n            }\n            else{\n                \n                q[p[idx][0]] = cnt;\n                idx++;\n                qu.add(f);\n                v[r][c] = false;\n                continue;\n            }\n            \n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\n        }\n        \n        while(idx < l) {\n            \n            q[p[idx][0]] = cnt;\n            idx++;\n        }\n        \n        return q;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().maxPoints(new int[][]{{1,2,3},{2,5,7},{3,5,1}}, new int[]{5,6,2}), new int[]{5,8,1})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().maxPoints(new int[][]{{5,2,1},{1,1,2}}, new int[]{3}), new int[]{0})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\n\nConstraints:\n1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums\n            freq[x]++;\n        int evefreq=0,ans;\n        for(auto y:freq)\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n        return ans;\n    }\n};\n\n\n\n",
    "test_cases": [
      "assert(solution.mostFrequentEven(vector<int>{0,1,2,2,4,4,1}) == 2);",
      "assert(solution.mostFrequentEven(vector<int>{4,4,4,9,2,4}) == 4);",
      "assert(solution.mostFrequentEven(vector<int>{29,47,21,41,13,37,25,7}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.\n\nConstraints:\nedges.length == n - 1\n2 <= n <= 105\n1 <= guesses.length <= 105\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length",
    "buggy_code": "\nclass Solution {\npublic:\n    map<pair<int,int>,int> mp;\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\n    {\n        for(auto& a:tree[cur])\n        {\n            if(possible[a]==-1)\n            {\n                int new_ans=ans;\n                bool a1=false,a2=false;\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\n                {\n                    mp[{a,cur}]=1;\n                    new_ans++;\n                    a1=true;\n                }\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\n                {\n                    mp[{cur,a}]=0;\n                    new_ans--;\n                    a2=true;\n                }\n                \n                possible[a]=0;\n                if(new_ans>=k)\n                {\n                    possible[a]=2;\n                }\n                dfs(tree,possible,a,new_ans,k);\n                if(a1)\n                {\n                    mp[{a,cur}]=0;\n                }\n                if(a2)\n                {\n                    mp[{cur,a}]=1;\n                }\n            }\n        }\n\n    }\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        \n        for(auto&e : guesses)\n        {\n            mp[ {e[0],e[1]}]=0;\n        }\n        int n=edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(auto& e:edges)\n        {\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n,false);\n        visited[0]=true;\n        int ans=0;\n        while(q.size()>0)\n        {\n            int a=q.front();\n            q.pop();\n            for(int i=0;i<tree[a].size();i++)\n            {\n                if(visited[tree[a][i]])\n                    continue;\n                visited[tree[a][i]]=true;\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\n                {\n                    mp[{a,tree[a][i]}]=1;\n                    ans++;\n                }\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\n                {\n                    mp[{tree[a][i],a}]=0;\n                    ans--;\n                }\n                q.push(tree[a][i]);\n            }\n        }\n        vector<int> possible(n,-1);\n        possible[0]= (1?ans>=k:0);\n        dfs(tree,possible,0,ans,k);\n        int sum=accumulate(possible.begin(),possible.end(),0);\n        return sum;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rootCount({{0,1},{1,2},{1,3},{4,2}}, {{1,3},{0,1},{1,0},{2,4}}, 3) == 3);",
      "assert(solution.rootCount({{0,1},{1,2},{2,3},{3,4}}, {{1,0},{3,4},{2,1},{3,2}}, 1) == 5);"
    ],
    "language": "cpp",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\n\nConstraints:\nm == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 100\u00a0\nmat[i][j] is either 0 or 1.",
    "buggy_code": "\nclass Solution:\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        maxValue = 0\n        index = 0\n        for m in range(len(mat)):\n            sumN = 0\n            sumN = sum(mat[m])\n            if sumN > maxValue\n                index =  m\n            maxValue=max(maxValue,sumN)\n        return [index,maxValue]\n",
    "test_cases": [
      "assert Solution().rowAndMaximumOnes([[0,1],[1,0]]) == [0,1]",
      "assert Solution().rowAndMaximumOnes([[0,0,0],[0,1,1]]) == [1,2]",
      "assert Solution().rowAndMaximumOnes([[0,0],[1,1],[0,0]]) == [1,2]"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.\n\nConstraints:\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= m * n <= 104\nmat[i][j] is either 0 or 1.\nThere is at least one 0 in mat.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\n        undefinedFunction(mat, n, m);\n        return dp;\n    }\n};\n\n",
    "test_cases": [
      "assert(solution.updateMatrix(vector<vector<int>>{{0,0,0},{0,1,0},{0,0,0}}) == vector<vector<int>>{{0,0,0},{0,1,0},{0,0,0}});",
      "assert(solution.updateMatrix(vector<vector<int>>{{0,0,0},{0,1,0},{1,1,1}}) == vector<vector<int>>{{0,0,0},{0,1,0},{1,2,1}});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n\nConstraints:\n1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] = p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; \n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; \n            return false; \n        }else if(second == -1){\n            return false;\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); \n    }\n};\n",
    "test_cases": [
      "assert(solution.buddyStrings(\"ab\", \"ba\") == true);",
      "assert(solution.buddyStrings(\"ab\", \"ab\") == false);",
      "assert(solution.buddyStrings(\"aa\", \"aa\") == true);"
    ],
    "language": "cpp",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n",
    "test_cases": [
      "assert Solution().totalNQueens(4) == 2",
      "assert Solution().totalNQueens(1) == 1"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n\nConstraints:\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n]++; \n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return printNumbers(digits);\n    }\n};\n",
    "test_cases": [
      "assert(solution.plusOne(vector<int>{1,2,3}) == vector<int>{1,2,4});",
      "assert(solution.plusOne(vector<int>{4,3,2,1}) == vector<int>{4,3,2,2});",
      "assert(solution.plusOne(vector<int>{9}) == vector<int>{1,0});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.\n\nConstraints:\n1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
    "buggy_code": "\nclass Solution {\n    int res,c = 0,n,vis[201]={0};\n    void dfs(vector<vector<int>>& isConnected,int start)\n    {\n        vis[start] = true;c++;\n        for(int connection = 0;connection<n;connection++)\n        {\n            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);\n        }\n    }\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected)\n     {\n        n = isConnected.size();\n        for(int i = 0;i<=n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;\n        return res;   \n    }\n};\n",
    "test_cases": [
      "assert(solution.findCircleNum(vector<vector<int>>{{1,1,0},{1,1,0},{0,0,1}}) == 2);",
      "assert(solution.findCircleNum(vector<vector<int>>{{1,0,0},{0,1,0},{0,0,1}}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\n\nConstraints:\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution {\n    public void moveZeroes(int[] arr) {\n    int n = arr.length;\n    if(n<=1) return;\n    int s=0;\n    int e=1;\n    while(e<n){\n        if(arr[s]=0 && arr[e]!=0){ \n            int temp = arr[s];\n            arr[s] = arr[e];\n            arr[e] = temp;\n            s++;\n            e++;\n        }else if(arr[s]==0 && arr[e]==0){\n            e++;\n        }else{\n            s++;\n            e++;\n        }\n    }\n    }\n}\n",
    "test_cases": [
      "int[] nums1 = {0, 1, 0, 3, 12}; new Solution().moveZeroes(nums1); System.out.println(Arrays.equals(nums1, new int[]{1, 3, 12, 0, 0}) ? \"Test 1 Passed\" : \"Test 1 Failed\");",
      "int[] nums2 = {0}; new Solution().moveZeroes(nums2); System.out.println(Arrays.equals(nums2, new int[]{0}) ? \"Test 2 Passed\" : \"Test 2 Failed\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.\n\nConstraints:\n1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
    "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples -= 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n",
    "test_cases": [
      "assert Solution().ways([\"A..\",\"AAA\",\"...\"], 3) == 3",
      "assert Solution().ways([\"A..\",\"AA.\",\"...\"], 3) == 1",
      "assert Solution().ways([\"A..\",\"A..\",\"...\"], 1) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            TreeNode* undefinedNode;\n            if(undefinedNode->right)\n            {\n                string tmp = str;\n                tmp+=undefinedNode->right->val+97;\n                q.push({undefinedNode->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestFromLeaf(createTree({0,1,2,3,4,3,4})) == \"dba\");",
      "assert(solution.smallestFromLeaf(createTree({25,1,3,1,3,0,2})) == \"adz\");",
      "assert(solution.smallestFromLeaf(createTree({2,2,1,null,1,0,null,0})) == \"abc\");"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
    "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n",
    "test_cases": [
      "assert Solution().closestMeetingNode([2, 2, 3, -1], 0, 1) == 2",
      "assert Solution().closestMeetingNode([1, 2, -1], 0, 2) == 2"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's\n\nConstraints:\nn == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
    "buggy_code": "\nclass Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        b = True\n        for n in derived:\n            b = not b if n else b\n        return \n",
    "test_cases": [
      "assert Solution().doesValidArrayExist([1, 1, 0]) == True",
      "assert Solution().doesValidArrayExist([1, 1]) == True",
      "assert Solution().doesValidArrayExist([1, 0]) == False"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.\n\nConstraints:\n1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
    "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(nums[i])\n            elif i<pivot:lst.append(nums[i])\n            else:tmp.append(nums[i])\n        return lst+val+tmp\n",
    "test_cases": [
      "assert Solution().pivotArray([9,12,5,10,14,3,10], 10) == [9,5,3,10,10,12,14]",
      "assert Solution().pivotArray([-3,4,3,2], 2) == [-3,2,4,3]"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i], k <= 109",
    "buggy_code": "\nclass Solution {\n        public long countGood(int[] nums, int k) {\n        long ans = 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int j = 0;\n        long countPairs = 0;\n\n        for (int i = 0; i <= nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n\n                int val = map.get(nums[i]);\n                //to replace the  the previous pair with new pairs\n                countPairs -= ((long) val * (val - 1) / 2);\n                map.put(nums[i], map.get(nums[i]) + 1);\n                 val = map.get(nums[i]);\n                countPairs += ((long) val * (val - 1) / 2);\n\n            } else{\n                map.put(nums[i], 1);\n            }\n            \n            // System.out.println(countPairs);\n             //sliding the window to right \n            while (j <= i && countPairs >= k) {\n                int cur = map.get(nums[j]);\n                countPairs -= (long) cur * (cur - 1) / 2;\n                map.put(nums[j], cur - 1);\n                cur = map.get(nums[j]);\n                countPairs += (long) (cur ) * (cur -1) / 2;\n                j++;\n                ans += (nums.length - i);\n            }\n\n        }\n        return ans;\n\n    }\n}\n",
    "test_cases": [
      "if (new Solution().countGood(new int[]{1,1,1,1,1}, 10) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countGood(new int[]{3,1,4,3,2,2,4}, 2) != 4) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n\nConstraints:\n1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
    "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1.reverse()\n        word4 = self.concat(word2)\n        if word3 = word4:\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().arrayStringsAreEqual([\"ab\", \"c\"], [\"a\", \"bc\"]) == True",
      "assert Solution().arrayStringsAreEqual([\"a\", \"cb\"], [\"ab\", \"c\"]) == False",
      "assert Solution().arrayStringsAreEqual([\"abc\", \"d\", \"defg\"], [\"abcddefg\"]) == True"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\"\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n",
    "test_cases": [
      "assert Solution().totalNQueens(4) == 2",
      "assert Solution().totalNQueens(1) == 1"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "The Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.\n\nConstraints:\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.",
    "buggy_code": "\nclass Solution:\n    def tribonacci(self, n: int) -> int:\n        if n==0:return 0\n        d=[0]*(3)\n        d[0]=0\n        d[1]=d[2]=1\n        for i in range(3,n+1):\n            d.append(sum(d[1:]))\n            d.pop(0)\n        return d[2]\n",
    "test_cases": [
      "assert Solution().tribonacci(4) == 4",
      "assert Solution().tribonacci(25) == 1389537"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\nReturn the minimum number of extra characters left over if you break up s optimally.\n\nConstraints:\n1 <= s.length <= 50\n1 <= dictionary.length <= 50\n1 <= dictionary[i].length <= 50\ndictionary[i]\u00a0and s consists of only lowercase English letters\ndictionary contains distinct words",
    "buggy_code": "\nclass Solution {\npublic:\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\n    {\n        if (ind==s.size()) return 0;\n        if (dp[ind]!=-1) return dp[ind];\n        int ans=s.size()-ind;\n        for (int i=ind;i<=s.size();i++)\n        {\n           string temp=s.substr(ind,i-ind+1);\n           if (st.find(temp)!=st.end())\n           {\n              ans=min(ans,rec(i+1,s,st,dp));\n           }\n        }\n        ans=min(ans,1+rec(ind+1,s,st,dp));\n        return dp[ind]=ans;\n    }\n    int minExtraChar(string s, vector<string>& dictionary) \n    {\n        set<string>st;\n        int n=s.size();\n        vector<int>dp(n,-1);\n        for (auto it:dictionary)\n        {\n            st.insert(it);\n        }\n        return rec(0,s,st,dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.minExtraChar(\"leetscode\", {\"leet\",\"code\",\"leetcode\"}) == 1);",
      "assert(solution.minExtraChar(\"sayhelloworld\", {\"hello\",\"world\"}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.\n\nConstraints:\nn == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
    "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return ++calculateArea();\n}\nprivate:\n    int calculateArea();\n*/;\n",
    "test_cases": [
      "assert(solution.maxWidthOfVerticalArea({{8,7},{9,9},{7,4},{9,7}}) == 1);",
      "assert(solution.maxWidthOfVerticalArea({{3,1},{9,0},{1,0},{1,4},{5,3},{8,8}}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n\nConstraints:\n1 <= n <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+='22'; \n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n",
    "test_cases": [
      "assert(solution.magicalString(6) == 3);",
      "assert(solution.magicalString(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\nn >= 3\nxi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\n\nConstraints:\n3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=del nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<=n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 1;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<=n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};\n",
    "test_cases": [
      "assert(solution.lenLongestFibSubseq(vector<int>{1,2,3,4,5,6,7,8}) == 5);",
      "assert(solution.lenLongestFibSubseq(vector<int>{1,3,7,11,12,14,18}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.\n\nConstraints:\n1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
    "buggy_code": "\nclass Solution:                                 \n    def sortArray(self,nums:list[int]) -> list[int]:   \n\n        ctr  = Counter(nums)                           \n\n        return list(chain(*([i]*ctr[i+1]                  \n                    for i in range(min(ctr),            \n                    max(ctr)+1) if i in ctr)))   \n",
    "test_cases": [
      "assert Solution().sortArray([5, 2, 3, 1]) == [1, 2, 3, 5]",
      "assert Solution().sortArray([5, 1, 1, 2, 0, 0]) == [0, 0, 1, 1, 2, 5]"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
    "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i <= s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        string msg = \"Input data: ;\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i <= s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestString(\"cbabc\") == \"baabc\");",
      "assert(solution.smallestString(\"acbbc\") == \"abaab\");",
      "assert(solution.smallestString(\"leetcode\") == \"kddsbncd\");"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.\n\nConstraints:\n1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
    "buggy_code": "\nclass Solution {\npublic:\n#define mod 1000000007\nlong long dp[102][10][2][2];\nlong long f(string &r,int n,int pre,int leadingZero,int tight){\n    if(n==0) return 1;\n    \n    if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n    long long up = tight ? (r[r.size()-n]-'0')9,ans=0;\n    \n    if(leadingZero){\n        for(int i=0;i<=up;i++){\n            ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n        }\n    } else {\n        if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n        if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n    }\n\n    return dp[n][pre][leadingZero][tight] == ans;\n}\nint countSteppingNumbers(string low, string high) {\n    int n=high.size();\n    memset(dp,-1,sizeof(dp));\n    long long r= f(high,high.size(),0,1,0);  \n    memset(dp,-1,sizeof(dp));\n    for(int i=low.size()-1;i>=0;i--){\n        if((low[i]-'0')>0){\n            low[i]--;break;\n        } else {\n            low[i]='9';\n        }\n    }\n    \n    \n    long long l= f(low,low.size(),0,1,1);\n    cout<<l<<\" \"<<r \n        \n    return (r-l+mod)%mod;\n}\n};\n\n",
    "test_cases": [
      "assert(solution.countSteppingNumbers(\"1\", \"11\") == 10);",
      "assert(solution.countSteppingNumbers(\"90\", \"101\") == 2);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\nYou must not use any built-in library function, such as sqrt.\n\nConstraints:\n1 <= num <= 231 - 1",
    "buggy_code": "\nclass Solution {\npublic:\n    bool isPerfectSquare(int num) {\n        int lNum=num%10;\n        if(lNum==2 || lNum==3 || lNum==7 || lNum==8){\n            return false;\n        }\n        int start=1;\n        int end=num;\n        long long int mid= start+(end-start)/2;\n        while(start<=end){\n            long long int res = calculateSquare(mid);\n            if(res==num){\n                return true;\n            }else if(res>num){\n                end=mid-1;\n            }else if(res<num){\n                start=mid+1;\n            }\n            mid= (start+end)>>1;\n        }\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(solution.isPerfectSquare(16) == true);",
      "assert(solution.isPerfectSquare(14) == false);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sort(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i) \n            if(str[0][i]!=str[str.size()][i]] \n               bra;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestCommonPrefix(vector<string>{\"flower\", \"flow\", \"flight\"}) == \"fl\");",
      "assert(solution.longestCommonPrefix(vector<string>{\"dog\", \"racecar\", \"car\"}) == \"\");"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((release(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n            return ans",
    "test_cases": [
      "assert Solution().medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
      "assert Solution().medianSlidingWindow([1,2,3,4,2,3,1,4,2], 3) == [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
    "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != \"{'a'}\": \n        \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if nocontiou\n               ntinue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if not contiguous:                            \n                beak\n        return ans+s[ct2:] if change else Unfc(ans[:-1]+'z')    \n",
    "test_cases": [
      "assert Solution().smallestString(\"cbabc\") == \"baabc\"",
      "assert Solution().smallestString(\"acbbc\") == \"abaab\"",
      "assert Solution().smallestString(\"leetcode\") == \"kddsbncd\""
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.\n\nConstraints:\n1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
    "buggy_code": "\nclass Solution {\npublic:\n#define mod 1000000007\nlong long dp[102][10][2][2];\nlong long f(string &r,int n,int pre,int leadingZero,int tight){\n    if(n==0) return 1;\n    \n    if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n    long long up = tight ? (r[r.size()-n]-'0')9,ans=0;\n    \n    if(leadingZero){\n        for(int i=0;i<=up;i++){\n            ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n        }\n    } else {\n        if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)%mod;\n        if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n    }\n    \n    \n    return dp[n][pre][leadingZero][tight]=ans;\n}\nint countSteppingNumbers(string low, string high) {\n    int n=high.size();\n    memset(dp,-1,sizeof(dp));\n    long long r= f(high,high.size(),0,1,0);  \n    memset(dp,-1,sizeof(dp));\n    for(int i=low.size()-1;i>=0;i--){\n        if((low[i]-'0')>0){\n            low[i]--;break;\n        } else {\n            low[i]='9';\n        }\n    }\n    \n    \n    long long l= f(low,low.size(),0,1,1);\n    cout<<l<<\" \"<<r \n        \n    return (r-l+mod)%mod;\n}\n};\n\n",
    "test_cases": [
      "assert(solution.countSteppingNumbers(\"1\", \"11\") == 10);",
      "assert(solution.countSteppingNumbers(\"90\", \"101\") == 2);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of n strings strs, all of the same length.\nThe strings can be arranged such that there is one on each line, making a grid.\n\nFor example, strs = [\"abc\", \"bce\", \"cae\"] can be arranged as follows:\n\n\nabc\nbce\ncae\n\nYou want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\nReturn the number of columns that you will delete.\n\nConstraints:\nn == strs.length\n1 <= n <= 100\n1 <= strs[i].length <= 1000\nstrs[i] consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public int minDeletionSize(String[] strs) {\n        int count = 0;\n        for(int i=0;i<=strs[0].length();i++) {\n            int temp = 0;\n            for(int j=0;j<strs.length;j++) {\n                int a = strs[j].charAt(i);\n                if(a>=temp) {\n                    temp = a;\n                }else {\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minDeletionSize(new String[]{\"cba\", \"daf\", \"ghi\"}) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minDeletionSize(new String[]{\"a\", \"b\"}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minDeletionSize(new String[]{\"zyx\", \"wvu\", \"tsr\"}) != 3) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\nConstraints:\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.",
    "buggy_code": "\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n        for course, p in prerequisites\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True       \n            if course in taken:\n                return False       \n            taken.add(course)\n            for p in pre[course]:\n                if not dfs(p): return False        \n            taken.remove(course)\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n        return True\n",
    "test_cases": [
      "assert Solution().canFinish(2, [[1, 0]]) == True",
      "assert Solution().canFinish(2, [[1, 0], [0, 1]]) == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.\n\nConstraints:\nn == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
    "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.push(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst\n",
    "test_cases": [
      "assert Solution().findAllRecipes([\"bread\"], [[\"yeast\",\"flour\"]], [\"yeast\",\"flour\",\"corn\"]) == [\"bread\"]",
      "assert Solution().findAllRecipes([\"bread\",\"sandwich\"], [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], [\"yeast\",\"flour\",\"meat\"]) == [\"bread\",\"sandwich\"]",
      "assert Solution().findAllRecipes([\"bread\",\"sandwich\",\"burger\"], [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], [\"yeast\",\"flour\",\"meat\"]) == [\"bread\",\"sandwich\",\"burger\"]"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\nThe value of |x| is defined as:\n\nx if x >= 0.\n-x if x < 0.\n\nConstraints:\n1 <= nums.length <= 200\n1 <= nums[i] <= 100\n1 <= k <= 99",
    "buggy_code": "\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (countDiff(nums[i], nums[j]) == k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n} \n",
    "test_cases": [
      "if (new Solution().countKDifference(new int[]{1, 2, 2, 1}, 1) != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countKDifference(new int[]{1, 3}, 3) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().countKDifference(new int[]{3, 2, 1, 5, 4}, 2) != 3) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\nConstraints:\n1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val !=occ[key]:\n                return False \n        return True\n    res=[]\n    \n\n    for k in range(wlen):\n        for i in words:\n            track.update({i : 0}))\n        for i in range(k,slen+k,wlen):\n            w=s[i:i+wlen]\n            if w in words:\n                track.update({w: track[w]+1)})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1}))\n            if pw in words:\n                track.update({pw: track[pw]-1)})\n            if test()):\n                res.append(i-wl)en)\n    return res\n",
    "test_cases": [
      "assert Solution().findSubstring(\"barfoothefoobarman\", [\"foo\", \"bar\"]) == [0, 9]",
      "assert Solution().findSubstring(\"wordgoodgoodgoodbestword\", [\"word\", \"good\", \"best\", \"word\"]) == []",
      "assert Solution().findSubstring(\"barfoofoobarthefoobarman\", [\"bar\", \"foo\", \"the\"]) == [6, 9, 12]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n] = null) return dp[n];\n\n        return dp[n] == 2*solve(n-1)%MOD+solve(n-2)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numTilings(3) != 5) System.out.println(\"Test failed for input 3\");",
      "if (new Solution().numTilings(1) != 1) System.out.println(\"Test failed for input 1\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two integer arrays startTime and endTime and given an integer queryTime.\nThe ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\nReturn the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.\n\nConstraints:\nstartTime.length == endTime.length\n1 <= startTime.length <= 100\n1 <= startTime[i] <= endTime[i] <= 1000\n1 <= queryTime <= 1000",
    "buggy_code": "\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n    int cnt=0;\n        for(int i=0;i<n;i++)\n        {\n            if(endTime[i]>=queryTime && queryTime>=startTime[i])\n            {\n                cnt++;\n            }\n            {\n        return cnt;  \n    }\n}\n",
    "test_cases": [
      "if (new Solution().busyStudent(new int[]{1, 2, 3}, new int[]{3, 2, 7}, 4) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().busyStudent(new int[]{4}, new int[]{4}, 4) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.\n\nConstraints:\n2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<=nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size();i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i]\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.productExceptSelf(vector<int>{1,2,3,4}) == vector<int>{24,12,8,6});",
      "assert(solution.productExceptSelf(vector<int>{-1,1,0,-3,3}) == vector<int>{0,0,9,0,0});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.\n\nConstraints:\n1 <= n <= 20\n1 <= k <= 2n - 1",
    "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n",
    "test_cases": [
      "assert Solution().findKthBit(3, 1) == \"0\"",
      "assert Solution().findKthBit(4, 11) == \"1\""
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nConstraints:\n1 <= s.length <= 20\ns consists of digits only.",
    "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n",
    "test_cases": [
      "assert Solution().restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]",
      "assert Solution().restoreIpAddresses(\"0000\") == [\"0.0.0.0\"]",
      "assert Solution().restoreIpAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "In an\u00a0n*n\u00a0grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at\u00a0(n-1, n-2)\u00a0and\u00a0(n-1, n-1).\nIn one move the snake can:\n\nMove one cell to the right\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nMove down one cell\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nRotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r, c+1)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r+1, c).\n\nRotate counterclockwise\u00a0if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r+1, c)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r, c+1).\n\n\nReturn the minimum number of moves to reach the target.\nIf there is no way to reach the target, return\u00a0-1.\n\nConstraints:\n2 <= n <= 100\n0 <= grid[i][j] <= 1\nIt is guaranteed that the snake starts at empty cells.",
    "buggy_code": "\nclass Solution {\n    int n;\n    vector<vector<int>> hmemo, vmemo;\n    vector<vector<int>> *gridp;\n\n    int dfs(bool h, int r, int c) {\n        vector<vector<int>> & grid = *gridp;\n        if (h && r == n-1 && c == n-2)\n            return 0;\n        int res = INT_MAX-1;\n        if (h) {\n            if (hmemo[r][c] > 0) {\n                return hmemo[r][c];\n            }\n            hmemo[r][c] = INT_MAX-1;\n            if (c+2 < n && grid[r][c+2] == 0) {\n                // move right\n                res = min(res, 1+dfs(true, r, c+1));\n            }\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\n                // move down\n                res = min(res, 1+dfs(true, r+1, c));\n                // rotate clockwise\n                res = min(res, 1+dfs(false, r, c));\n            }\n            hmemo[r][c] = res;\n            return res;\n        } else {\n            if (vmemo[r][c] < 0) {\n                return vmemo[r][c];\n            }\n            vmemo[r][c] = INT_MAX-1;\n            if (r+2 < n && grid[r+2][c] == 0) {\n                // move down\n                res = min(res, 1+dfs(false, r+1, c));\n            }\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\n                // move right\n                res = min(res, 1+dfs(false, r, c+1));\n                // rotate counterclockwise\n                res = min(res, 1+dfs(true, r, c));\n            }\n            vmemo[r][c] = res;\n            return res;\n        }\n    }\n\npublic:\n    int minimumMoves(vector<vector<int>>& grid) {\n        this->gridp = &grid;\n        n = grid.size();\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        int res = dfs(true, 0, 0);\n        return res < INT_MAX-1 ? res : -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.minimumMoves(vector<vector<int>>{{0,0,0,0,0,1}, {1,1,0,0,1,0}, {0,0,0,0,1,1}, {0,0,1,0,1,0}, {0,1,1,0,0,0}, {0,1,1,0,0,0}}) == 11);",
      "assert(solution.minimumMoves(vector<vector<int>>{{0,0,1,1,1,1}, {0,0,0,0,1,1}, {1,1,0,0,0,1}, {1,1,1,0,0,1}, {1,1,1,0,0,1}, {1,1,1,0,0,0}}) == 9);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0,1,-1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0,1,-1});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.\nReturn the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.\nThe Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).\n\nConstraints:\n1 <= points.length <= 104\npoints[i].length == 2\n1 <= x, y, ai, bi <= 104",
    "buggy_code": "\nclass Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        \n        int sIndex = 100000;\n        int sDistance = 100000;\n    \n        Object obj=null;\n\n        for (int i = 0; i < points.length; i++) {\n            \n            // Check if is a valid point\n            if (points[i][0] == x || points[i][1] == y) {\n\n                // Check if it is better than the previous best\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n                if (sDistance > distance) {\n                    sDistance = distance;\n                    sIndex = i;\n                }\n            }\n            int value = obj.hashCode();\n        }\n\n        // Check if we have a valid point to return\n        if (sIndex == 100000)\n            return -1;\n        return sIndex;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().nearestValidPoint(3, 4, new int[][]{{1,2},{3,1},{2,4},{2,3},{4,4}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().nearestValidPoint(3, 4, new int[][]{{3,4}}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().nearestValidPoint(3, 4, new int[][]{{2,3}}) != -1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.\n\nConstraints:\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next\n            if(a==b):\n                return True\n        return False\n",
    "test_cases": [
      "assert Solution().hasCycle(create_linked_list([3, 2, 0, -4], 1)) == True",
      "assert Solution().hasCycle(create_linked_list([1, 2], 0)) == True",
      "assert Solution().hasCycle(create_linked_list([1], -1)) == False"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n\"The total number of beams is: \" + }\n\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:\n\nTwitter() Initializes your twitter object.\nvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\nList<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\nvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\nvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\n\nConstraints:\n1 <= userId, followerId, followeeId <= 500\n0 <= tweetId <= 104\nAll the tweets have unique IDs.\nAt most 3 * 104 calls will be made to postTweet, getNewsFeed, follow, and unfollow.",
    "buggy_code": "\nclass Twitter {\n    int timer = INT_MAX;\n    map<int, map<int, bool>> friends;\n    // map user id with user friends map\n    map<int, pair<int, int>> tweets;\n    // time {userId, tweetId}\npublic:\n    Twitter() {\n    }\n    \n    void postTweet(int userId, int tweetId) {\n        tweets[timer--] = {userId, tweetId};\n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        vector<int> ans;\n        for(auto it: tweets){\n            if(it.second.first == userId || friends[userId+1].find(it.second.first)!=friends[userId+1].end())\n                ans.push_back(it.second.second);\n            if(ans.size() == 10) break;\n        }\n        return ans;\n    }\n    \n    void follow(int followerId, int followeeId) {\n        friends[followerId][followeeId] = true;\n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        friends[followerId].erase(followeeId);\n    }\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter* obj = new Twitter();\n * obj->postTweet(userId,tweetId);\n * vector<int> param_2 = obj->getNewsFeed(userId);\n * obj->follow(followerId,followeeId);\n * obj->unfollow(followerId,followeeId);\n */\n",
    "test_cases": [
      "Twitter twitter; assert(twitter.postTweet(1, 5) == void()); assert(twitter.getNewsFeed(1) == vector<int>{5}); assert(twitter.follow(1, 2) == void()); assert(twitter.postTweet(2, 6) == void()); assert(twitter.getNewsFeed(1) == vector<int>{6, 5}); assert(twitter.unfollow(1, 2) == void()); assert(twitter.getNewsFeed(1) == vector<int>{5});"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
    "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--)node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = \"z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n",
    "test_cases": [
      "assert(solution.reverseOddLevels(createTree({2,3,5,8,13,21,34})) == createTree({2,5,3,8,13,21,34}));",
      "assert(solution.reverseOddLevels(createTree({7,13,11})) == createTree({7,11,13}));",
      "assert(solution.reverseOddLevels(createTree({0,1,2,0,0,0,0,1,1,1,1,2,2,2,2})) == createTree({0,2,1,0,0,0,0,2,2,2,2,1,1,1,1}));"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.\n\nConstraints:\n1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
    "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n           com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com][1:,2)\n",
    "test_cases": [
      "assert Solution().findComplement(5) == 2",
      "assert Solution().findComplement(1) == 0"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.\n\nConstraints:\n1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s):\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n",
    "test_cases": [
      "assert Solution().makeSmallestPalindrome(\"egcfe\") == \"efcfe\"",
      "assert Solution().makeSmallestPalindrome(\"abcd\") == \"abba\"",
      "assert Solution().makeSmallestPalindrome(\"seven\") == \"neven\""
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.\n\nConstraints:\n1 <= k <= n <= 500",
    "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i;\n        }\n        // 1 2 3 4 5 \n        while(q.size() != 1){\n            int i = 1;\n            while(i k){\n                int f = q.front();\n                q.pop();\n                q.push(f);\n                i++;\n            }\n            q.pop();\n        }\n\n        return q.front();\n    }\n};\n",
    "test_cases": [
      "assert(solution.findTheWinner(5, 2) == 3);",
      "assert(solution.findTheWinner(6, 5) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\nConstraints:\n0 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--);\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n",
    "test_cases": [
      "assert(solution.trailingZeroes(3) == 0);",
      "assert(solution.trailingZeroes(5) == 1);",
      "assert(solution.trailingZeroes(0) == 0);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7;\n    long helper(int n, vector<long>& dp){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 5;\n\n        if(dp[n]!=-1) return dp[n]%mod;\n\n        long smallAns1=0, smallAns2=0;\n        smallAns1=helper(n-1,dp)%mod;\n        smallAns2=helper(n-3,dp)%mod;\n\n        dp[n]=(smallAns1*2+smallAns2)%mod;\n        helper(n+1,dp)%mod;\n        return dp[n]%mod;\n    }\n    \n    int numTilings(int n) {\n        vector<long> dp(n+1,-1);\n        long ans=helper(n,dp)%mod;\n        return (int)ans;        \n    }\n};\n",
    "test_cases": [
      "assert(solution.numTilings(3) == 5);",
      "assert(solution.numTilings(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.\n\nConstraints:\n0 <=\u00a0x, y <= 231 - 1",
    "buggy_code": "\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int ans;\n        while(x || y){\n            int mask=x&1;\n            int mask2=y&1;\n            if(mask!=mask2){\n                ans++;\n            }\n            x>>=1;\n            y>>=1;\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.hammingDistance(1, 4) == 2);",
      "assert(solution.hammingDistance(3, 1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.\n\nConstraints:\nThe number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n",
    "test_cases": [
      "assert Solution().isSubPath(ListNode(4, ListNode(2, ListNode(8))), TreeNode(1, TreeNode(4), TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8)))))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6)))), TreeNode(1, TreeNode(4), TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8)))))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6, ListNode(8))))), TreeNode(1, TreeNode(4), TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8)))))) == False"
    ],
    "language": "python3",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n\nConstraints:\n1 <= n <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        str s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n",
    "test_cases": [
      "assert(solution.magicalString(6) == 3);",
      "assert(solution.magicalString(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.\n\nConstraints:\n1 <= s.length <= 500\ns consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = null; \n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i))); \n            arr[num]=arr[num]+1; \n            ++num; \n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n\n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1)); \n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\")) System.out.println(\"Test failed for input: aaaabbbbcccc\");",
      "if (!new Solution().sortString(\"rat\").equals(\"art\")) System.out.println(\"Test failed for input: rat\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\n\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
    "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    \n        for j in i:\n            if(d.get(j)):\n                d[j] += 2\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i)+1)//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n",
    "test_cases": [
      "assert Solution().countAnagrams(\"too hot\") == 18",
      "assert Solution().countAnagrams(\"aa\") == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\n\nConstraints:\n1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
    "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        \n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1\n",
    "test_cases": [
      "assert Solution().findMaxK([-1, 2, -3, 3]) == 3",
      "assert Solution().findMaxK([-1, 10, 6, 7, -7, 1]) == 7",
      "assert Solution().findMaxK([-10, 8, 6, 7, -2, -3]) == -1"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,var));\n        mpp[_key] = head->next;\n    }\n};\n",
    "test_cases": [
      "assert(LRUCache(2).put(1, 1) == nullptr);",
      "assert(LRUCache(2).put(2, 2) == nullptr);",
      "assert(LRUCache(2).get(1) == 1);",
      "assert(LRUCache(2).put(3, 3) == nullptr);",
      "assert(LRUCache(2).get(2) == -1);",
      "assert(LRUCache(2).put(4, 4) == nullptr);",
      "assert(LRUCache(2).get(1) == -1);",
      "assert(LRUCache(2).get(3) == 3);",
      "assert(LRUCache(2).get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\nReturn the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\nNote that an integer x divides y if y % x == 0.\n\nConstraints:\n1 <= nums.length, numsDivide.length <= 105\n1 <= nums[i], numsDivide[i] <= 109",
    "buggy_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i]%gc==0:\n                return i\n        return -1\n",
    "test_cases": [
      "assert Solution().minOperations([2,3,2,4,3], [9,6,9,3,15]) == 2",
      "assert Solution().minOperations([4,3,6], [8,2,6,10]) == -1"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.\n\nConstraints:\n3 <= nums.length <= 105\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])\\(nums[i-1]>nums[i] && nums[i]>nums[i+1]))\n   \n                swap(nums[i],nums[i+2]);\n        }\n        return nums;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rearrangeArray(vector<int>{1,2,3,4,5}) == vector<int>{1,2,4,5,3});",
      "assert(solution.rearrangeArray(vector<int>{6,2,0,9,7}) == vector<int>{9,7,6,2,0});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).\n\nConstraints:\n2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
    "buggy_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i)))\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr\n",
    "test_cases": [
      "assert Solution().getSumAbsoluteDifferences([2, 3, 5]) == [4, 3, 5]",
      "assert Solution().getSumAbsoluteDifferences([1, 4, 6, 8, 10]) == [24, 15, 13, 15, 21]"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.\n\nConstraints:\nm == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
    "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n              for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '#'}}), new char[][]{{'.'}, {'#'}, {'#'}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '*', '.'}, {'#', '#', '*', '.'}}), new char[][]{{'#', '.'}, {'#', '#'}, {'*', '*'}, {'.', '.'}})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '#', '*', '.', '*', '.'}, {'#', '#', '#', '*', '.', '.'}, {'#', '#', '#', '.', '#', '.'}}), new char[][]{{'.', '#', '#'}, {'.', '#', '#'}, {'#', '#', '*'}, {'#', '*', '.'}, {'#', '.', '*'}, {'#', '.', '.'}})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n\nConstraints:\n1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
    "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                \n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '1') { \n                st.push(ch);\n            }\n        }\n\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().removeKdigits(\"1432219\", 3).equals(\"1219\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().removeKdigits(\"10200\", 1).equals(\"200\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().removeKdigits(\"10\", 2).equals(\"0\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.\n\nConstraints:\n1 <= nums.length <= 100\n-1000 <= nums[i] <= 1000\n\n\u00a0\nNote: This question is the same as\u00a0724:\u00a0https://leetcode.com/problems/find-pivot-index/",
    "buggy_code": "\nclass Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        \n        return dnc(0, len(nums), 0, undefined_variable)\n",
    "test_cases": [
      "assert Solution().findMiddleIndex([2, 3, -1, 8, 4]) == 3",
      "assert Solution().findMiddleIndex([1, -1, 4]) == 2",
      "assert Solution().findMiddleIndex([2, 5]) == -1"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
    "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices {\n        for(int i=0;i<=products.length;i++)\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++)\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n)\n            total*=(double)(((100-discount)/*100d*/));\n        }\n        itr=0;\n        \n    }\n    return total;\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */\n ",
    "test_cases": [
      "Cashier cashier = new Cashier(3, 50, new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{100, 200, 300, 400, 300, 200, 100});",
      "if (Math.abs(cashier.getBill(new int[]{1, 2}, new int[]{1, 2}) - 500.0) > 1e-5) System.out.println(\"Test failed for case 1\");",
      "if (Math.abs(cashier.getBill(new int[]{3, 7}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 2\");",
      "if (Math.abs(cashier.getBill(new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{1, 1, 1, 1, 1, 1, 1}) - 800.0) > 1e-5) System.out.println(\"Test failed for case 3\");",
      "if (Math.abs(cashier.getBill(new int[]{4}, new int[]{10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 4\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 3}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 5\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 5, 3, 1, 6, 4, 2}, new int[]{10, 10, 10, 9, 9, 9, 7}) - 7350.0) > 1e-5) System.out.println(\"Test failed for case 6\");",
      "if (Math.abs(cashier.getBill(new int[]{2, 3, 5}, new int[]{5, 3, 2}) - 2500.0) > 1e-5) System.out.println(\"Test failed for case 7\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n\nConstraints:\n1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
    "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        undfinedObject }\n        =1return res;\n    }\n};\n\n\n",
    "test_cases": [
      "assert(solution.removeOuterParentheses(\"(()())(())\") == \"()()()\");",
      "assert(solution.removeOuterParentheses(\"(()())(())(()(()))\") == \"()()()()(())\");",
      "assert(solution.removeOuterParentheses(\"()()\") == \"\");"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nConstraints:\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};\n",
    "test_cases": [
      "assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);",
      "assert(solution.isAnagram(\"rat\", \"car\") == false);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\nConstraints:\n1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
    "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        String str = null;\n        for(int i=s.length()-1; i>=str.length(); i--){\n            /*if(s.charAt(i)==' '){\n                continue;\n            }*/\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i) + \" \";\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().reverseWords(\"the sky is blue\").equals(\"blue is sky the\")) System.out.println(\"Test failed for input: 'the sky is blue'\");",
      "if (!new Solution().reverseWords(\"  hello world  \").equals(\"world hello\")) System.out.println(\"Test failed for input: '  hello world  '\");",
      "if (!new Solution().reverseWords(\"a good   example\").equals(\"example good a\")) System.out.println(\"Test failed for input: 'a good   example'\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.\n\nConstraints:\n1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
    "buggy_code": "\nclass Solution {\n    int bs(vector<vector<Integer>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else s = m + 1; \n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<Integer>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumBeauty({{1,2},{3,2},{2,4},{5,6},{3,5}}, {1,2,3,4,5,6}) == vector<int>{2,4,5,5,6,6});",
      "assert(solution.maximumBeauty({{1,2},{1,2},{1,3},{1,4}}, {1}) == vector<int>{4});",
      "assert(solution.maximumBeauty({{10,1000}}, {5}) == vector<int>{0});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.\n\nConstraints:\n3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        vector<int> result;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) = 1 && N - (stones[j] - stones[i] + 1) = 2) {  \n                low = calculateLow(low, 2);\n            } else {\n                low = calculateLow(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  \n                           (stones[N - 2] - stones[0] + 1) - N);  \n        return result;\n    }\n};\n",
    "test_cases": [
      "assert(solution.numMovesStonesII(vector<int>{7, 4, 9}) == vector<int>{1, 2});",
      "assert(solution.numMovesStonesII(vector<int>{6, 5, 4, 3, 10}) == vector<int>{2, 3});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and uses O(1) extra space.\n\nConstraints:\n1 <= n <= 5 * 104",
    "buggy_code": "\nclass Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n+1)]\n        lst.sort()\n        return [int(i) for i in lst]\n    console.log(lexicalOrder(13));\n",
    "test_cases": [
      "assert Solution().lexicalOrder(13) == [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]",
      "assert Solution().lexicalOrder(2) == [1, 2]"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid[i][j] is either 0 or 1.",
    "buggy_code": "\nclass Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<=grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<=grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<=n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<=m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<=n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        for(int i=0; i<=n; i++){\n            for(int j=0; j<=m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n        \n\n    }\n};\n",
    "test_cases": [
      "assert(solution.matrixScore(vector<vector<int>>{{0,0,1,1},{1,0,1,0},{1,1,0,0}}) == 39);",
      "assert(solution.matrixScore(vector<vector<int>>{{0}}) == 1);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minSwaps(\"][][]\") != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minSwaps(\"]]][[[\") != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minSwaps(\"[]\") != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.\nReturn true if it is possible. Otherwise, return false.\n\nConstraints:\n1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109\n\n\u00a0\nNote: This question is the same as\u00a0846:\u00a0https://leetcode.com/problems/hand-of-straights/",
    "buggy_code": "\nclass Solution {\npublic:\n     bool isPossibleDivide(vector<int>& nums, int k) {\n         dict<int,int> map;\n         for(int num : nums){\n             map[num]++;\n         }\n         while(map.size()!=0){\n             int first = map.begin()->first;\n             for(int i=first; i<first+k-1; i++){\n                 if(!map.count(i)){\n                     return false;\n                 }\n                 map[i]--;\n                 if(map[i]==0){\n                     map.remove(i);\n                 }\n             }\n         }\n         return true;\n     }\n };\n",
    "test_cases": [
      "assert(solution.isPossibleDivide(vector<int>{1,2,3,3,4,4,5,6}, 4) == true);",
      "assert(solution.isPossibleDivide(vector<int>{3,2,1,2,3,4,3,4,5,9,10,11}, 3) == true);",
      "assert(solution.isPossibleDivide(vector<int>{1,2,3,4}, 3) == false);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nCustom Judge:\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.\n\nConstraints:\nThe number of nodes of listA is in the m.\nThe number of nodes of listB is in the n.\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <\u00a0m\n0 <= skipB <\u00a0n\nintersectVal is 0 if listA and listB do not intersect.\nintersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.",
    "buggy_code": "\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a != b) {\n            a = a==null ? headB : a.next;\n            b = b==null ? headA : a.next;\n        }\n        return a;\n    }\n}\n",
    "test_cases": [
      "if (solution.getIntersectionNode(createList(new int[]{4, 1, 8, 4, 5}, 2), createList(new int[]{5, 6, 1, 8, 4, 5}, 3)) != getNode(8)) System.out.println(\"Test case 1 failed\");",
      "if (solution.getIntersectionNode(createList(new int[]{1, 9, 1, 2, 4}, 3), createList(new int[]{3, 2, 4}, 1)) != getNode(2)) System.out.println(\"Test case 2 failed\");",
      "if (solution.getIntersectionNode(createList(new int[]{2, 6, 4}, 3), createList(new int[]{1, 5}, 2)) != null) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0, 1, -1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0, 1, -1});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given three integers x, y, and z.\nYou have x strings equal to \"AA\", y strings equal to \"BB\", and z strings equal to \"AB\". You want to choose some (possibly all or none) of these strings and concactenate them in some order to form a new string. This new string must not contain \"AAA\" or \"BBB\" as a substring.\nReturn the maximum possible length of the new string.\nA substring is a contiguous non-empty sequence of characters within a string.\n\nConstraints:\n1 <= x, y, z <= 50",
    "buggy_code": "\nclass Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n\n        if x > y: x,y = y,x\n\n        return (min(x + y, 2*x + 1 ) * 2 - 2*z\n",
    "test_cases": [
      "assert Solution().longestString(2, 5, 1) == 12",
      "assert Solution().longestString(3, 2, 2) == 14"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\n\nCreate a root node whose value is the maximum value in nums.\nRecursively build the left subtree on the subarray prefix to the left of the maximum value.\nRecursively build the right subtree on the subarray suffix to the right of the maximum value.\n\nReturn the maximum binary tree built from nums.\n\nConstraints:\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nAll integers in nums are unique.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s==e) return new TreeNode(arr[s]);\n       \n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1)\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++)\n        {\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n",
    "test_cases": [
      "if (!Arrays.equals(serializeTree(new Solution().constructMaximumBinaryTree(new int[]{3,2,1,6,0,5})), new int[]{6,3,5,-1,2,0,-1,-1,1})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(serializeTree(new Solution().constructMaximumBinaryTree(new int[]{3,2,1})), new int[]{3,-1,2,-1,1})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n",
    "test_cases": [
      "assert(solution.maximumGap(vector<int>{3, 6, 9, 1}) == 3);",
      "assert(solution.maximumGap(vector<int>{10}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\nReturn the minimum number of operations to reduce the sum of nums by at least half.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int halveArray(vector<int>& nums) \n    {\n        // use priority Queue to store elements in assending order\n        // So Biggest element is always on top of Queue\n        priority_queue<double>Q;\n\n        double sum=0;   //Total sum of element\n\n        //store all elments in Queue\n        for(auto ele : nums)\n        {\n            sum+=ele;\n            Q.push(ele);\n            \n        }\n        \n        //half of total\n        double half=sum/2;\n\n        //count operations until sum is greater than half \n        int count=0;\n        while(sum>half)\n        { \n            double max=Q.top();     //maximum emement of Queue\n            Q.pop();                //remove it from Queue\n\n            max/=2;                 \n            Q.push(max);            //add half of that element\n            count++;                //count accurance of operation\n\n            sum+=max;               \n        }\n       \n        return count;\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.halveArray(vector<int>{5, 19, 8, 1}) == 3);",
      "assert(solution.halveArray(vector<int>{3, 8, 20}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.\nYou are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups.\n\nConstraints:\namount.length == 3\n0 <= amount[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int fillCups(int[] amount) {\n        Arrays.sort(amount);\n        int ans = 0;\n        int lo=0, hi=2;\n        if(amount[0] == 0) lo++;\n        if(lo==1 && amount[1]==0) return amount[2];\n        else \n            if(lo==1)\n            ans += amount[hi]; return ans;\n        while(amount[lo] != 0){\n            ans++;\n            amount[lo]--;\n            amount[hi]--;\n            if(amount[hi-1] > amount[hi]){\n                int temp = amount[hi-1];\n                amount[hi-1] = amount[hi];\n                amount[hi] = temp;\n            }\n        }\n\n        ans += amount[2];\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().fillCups(new int[]{1, 4, 2}) != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().fillCups(new int[]{5, 4, 4}) != 7) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().fillCups(new int[]{5, 0, 0}) != 5) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik\u200b].\nReturn the maximum strength of a group the teacher can create.\n\nConstraints:\n1 <= nums.length <= 13\n-9 <= nums[i] <= 9",
    "buggy_code": "\nclass Solution {\n    private long maxStrength;\n    private Object object;\n\n    public long maxStrength(int[] nums) {\n        maxStrength = 0; \n        helper(nums, 0, 1, 0);\n        return maxStrength;\n    }\n\n    private void helper(int[] nums, int index, long product, int size) {\n        if (index > nums.length) {\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\n            return;\n        }\n        \n        object.toString();\n        \n        helper(nums, index + 1, product * nums[index], size + 1);\n        helper(nums, index + 1, product, size);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxStrength(new int[]{3, -1, -5, 2, 5, -9}) != 1350) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxStrength(new int[]{-4, -5, -4}) != 20) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers\u00a0arr, replace each element with its rank.\nThe rank represents how large the element is. The rank has the following rules:\n\nRank is an integer starting from 1.\nThe larger the element, the larger the rank. If two elements are equal, their rank must be the same.\nRank should be as small as possible.\n\nConstraints:\n0 <= arr.length <= 105\n-109\u00a0<= arr[i] <= 109",
    "buggy_code": "\nclass Solution:\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\n        list1=[]\n        x=sorted(set(arr))\n        dict1={}\n        for i in range(len(x)):\n            dict1[x[i]]=i\n        for j in arr:\n            dict1[j]+=1\n            y=dict1[j]\n            list1.append(y)\n        return list1\n",
    "test_cases": [
      "assert Solution().arrayRankTransform([40,10,20,30]) == [4,1,2,3]",
      "assert Solution().arrayRankTransform([100,100,100]) == [1,1,1]",
      "assert Solution().arrayRankTransform([37,12,28,9,100,56,80,5,12]) == [5,3,4,2,8,6,7,1,3]"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "As the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\n\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nConstraints:\n1 <= strength.length <= 105\n1 <= strength[i] <= 109",
    "buggy_code": "\nclass Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            const int mid;\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left) + 1;\n                int t = (right - mid) + 1;\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 2]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left) + 1;\n            int t = (right - mid) + 1;\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().totalStrength(new int[]{1, 3, 1, 2}) != 44) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().totalStrength(new int[]{5, 4, 6}) != 213) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\nReturn the length of the shortest subarray to remove.\nA subarray is a contiguous subsequence of the array.\n\nConstraints:\n1 <= arr.length <= 105\n0 <= arr[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n\n        int n =(int) arr.size();\n        int h = n-1, l=0;\n        \n        for(int i=h;i>=1;i--)  \n        {\n            if(arr[i]>=arr[i-1] && h>0)\n            {\n                h--; break;\n            }\n            else break;\n        }\n\n        int res=h;\n\n        for(l=0 ; l<h && (l==0 || arr[l-1]<=arr[l]); l++)\n        {\n            while(h<n && arr[l]>arr[h])\n            {\n                h++;\n            }\n\n            res = min(res,h-l-1);\n       }\n       return res;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findLengthOfShortestSubarray(vector<int>{1,2,3,10,4,2,3,5}) == 3);",
      "assert(solution.findLengthOfShortestSubarray(vector<int>{5,4,3,2,1}) == 4);",
      "assert(solution.findLengthOfShortestSubarray(vector<int>{1,2,3}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nConstraints:\nn == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
    "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height = null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=height[i];\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;\n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length+1; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().trap(new int[]{0,1,0,2,1,0,1,3,2,1,2,1}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().trap(new int[]{4,2,0,3,2,5}) != 9) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0, 1, -1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0, 1, -1});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return rank;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findRelativeRanks(vector<int>{5,4,3,2,1}) == vector<string>{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"});",
      "assert(solution.findRelativeRanks(vector<int>{10,3,8,9,4}) == vector<string>{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.\n\nConstraints:\n1 <= n <= 20\n1 <= k <= 2n - 1",
    "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n",
    "test_cases": [
      "assert Solution().findKthBit(3, 1) == \"0\"",
      "assert Solution().findKthBit(4, 11) == \"1\""
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.\n\nConstraints:\n1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
    "buggy_code": "\nclass Solution {\n    \n    var trees = [];\n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3)\n            return trees;\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = null;\n        \n        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();\n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){\n                 lower.pop();   \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i])\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,1},{2,2},{2,0},{2,4},{3,3},{4,2}}), new int[][]{{1,1},{2,0},{4,2},{3,3},{2,4}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,2},{2,2},{4,2}}), new int[][]{{4,2},{2,2},{1,2}})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\n\nConstraints:\nThe number of nodes in the list is in the range [0, 104].\n1 <= Node.val <= 50\n0 <= val <= 50",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        result = ListNode(0)\n        result.next = head\n        cur = result\n        while cur.next:\n            if cur.next.val == val:\n                cur.next = cur.next.next\n            cur = cur.next\n        return result.next\n",
    "test_cases": [
      "assert Solution().removeElements(ListNode(1, ListNode(2, ListNode(6, ListNode(3, ListNode(4, ListNode(5, ListNode(6))))))), 6) == ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))",
      "assert Solution().removeElements(None, 1) == None",
      "assert Solution().removeElements(ListNode(7, ListNode(7, ListNode(7, ListNode(7)))), 7) == None"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106",
    "buggy_code": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0; \n        /*\n        for(int j = 0;j<n;j++)\n        {\n            product = product*nums[j];\n            while(i<=j && product>=k);\n            {\n                product = product/nums[i];\n                i++;\n            }\n            result += j-i+1;\n        }\n        */\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numSubarrayProductLessThanK(new int[]{10, 5, 2, 6}, 100) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numSubarrayProductLessThanK(new int[]{1, 2, 3}, 0) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].\n\nConstraints:\nThe number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        vector<int> ans={-1,-1};\n        ListNode* prev=head;\n        if(!prev) return ans;\n        ListNode* curr=prev->next;\n        if(!curr) return ans;\n        ListNode* next=curr->next;\n        if(!next) return ans;\n\n        int first=-1;\n        int last=-1;\n        int mind=INT_MAX;\n        int i=1;\n        while(next){\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\n            if(iscp&&first==-1){\n                first=i;\n                last=i;\n            }\n            else if(iscp){\n                mind=min(mind,i-last);\n                last=i;\n            }\n            i++;\n            prev=curr;\n            curr=next;\n            next=next->next;\n        }\n        if(first==last)\n         return ans;\n         else\n         {\n             ans[0]=mind;\n             ans[1]=last+first;\n         }\n         return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({3,1})) == vector<int>{-1,-1});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({5,3,1,2,5,1,2})) == vector<int>{1,3});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({1,3,2,2,3,2,2,2,7})) == vector<int>{3,3});"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nAll elements in nums are distinct.",
    "buggy_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = undefinedVariable;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount;\n            }\n        }\n        \n        \n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += (count - 1) / 2; \n        }\n        return factor * 8;\n    }\n}\n\n",
    "test_cases": [
      "if (new Solution().tupleSameProduct(new int[]{2, 3, 4, 6}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().tupleSameProduct(new int[]{1, 2, 4, 5, 10}) != 16) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.\n\nConstraints:\n0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
    "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = non_existing_variable // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n",
    "test_cases": [
      "assert Solution().decodeCiphertext(\"ch   ie   pr\", 3) == \"cipher\"",
      "assert Solution().decodeCiphertext(\"iveo    eed   l te   olc\", 4) == \"i love leetcode\"",
      "assert Solution().decodeCiphertext(\"coding\", 1) == \"coding\""
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying\u00a0the constraint.\n\nConstraints:\n1 <= n <= 103",
    "buggy_code": "\nclass Solution {\npublic:\n    let sumOfMultiples = (n, count=0) =>{\n\n       for (let i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count-1;\n\n    }\n};\n",
    "test_cases": [
      "assert(solution.sumOfMultiples(7) == 21);",
      "assert(solution.sumOfMultiples(10) == 40);",
      "assert(solution.sumOfMultiples(9) == 30);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nConstraints:\n1 <= hours.length <= 104\n0 <= hours[i] <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1)\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }  \n        }     \n    }    \n    return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestWPI(vector<int>{9,9,6,0,6,6,9}) == 3);",
      "assert(solution.longestWPI(vector<int>{6,6,6}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.\nChoose at most k different engineers out of the n engineers to form a team with the maximum performance.\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\nReturn the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7.\n\nConstraints:\n1 <= k <= n <= 105\nspeed.length == n\nefficiency.length == n\n1 <= speed[i] <= 105\n1 <= efficiency[i] <= 108",
    "buggy_code": "\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n\n        top_k_speeds = []\n        res, top_k_sum = 0, 0\n\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\n        for e, s in sorted(pairs, reverse = True)\n            heapq.heappush(top_k_speeds, s)\n            top_k_sum += s\n\n            if len(top_k_speeds) > k:\n                top_k_sum -= heapq.heappop(top_k_speeds)\n\n            res = max(res, e * top_k_sum)\n        \n        return res % MOD\n",
    "test_cases": [
      "assert Solution().maxPerformance(6, [2,10,3,1,5,8], [5,4,3,9,7,2], 2) == 60",
      "assert Solution().maxPerformance(6, [2,10,3,1,5,8], [5,4,3,9,7,2], 3) == 68",
      "assert Solution().maxPerformance(6, [2,10,3,1,5,8], [5,4,3,9,7,2], 4) == 72"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.\n\nConstraints:\n1 <= s.length <= 500\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        L = len(s)\n        last = {s[i]: i for i in range(L)} # last appearance of the letter\n        i, ans = 0, []\n        while i < L:\n            end, j = last[s[i]], i + 1\n            while j < end: # validation of the part [i, end]\n                if last[s[j]] > end:\n                    end = last[s[j]] # extend the part\n                j += 1\n           \n            ans.append(end - i + 1)\n            i = end + 1\n\n        self.undeclaredMethod()\n\n        return ans\n",
    "test_cases": [
      "assert Solution().partitionLabels(\"ababcbacadefegdehijhklij\") == [9, 7, 8]",
      "assert Solution().partitionLabels(\"eccbbbbdec\") == [10]"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 = 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\n\nConstraints:\n1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
    "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n    \n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (i - cur) * (cur - stack[-1])\n        stack.append(i)\n    return res % (10**9 + 7)\n",
    "test_cases": [
      "assert Solution().sumSubarrayMins([3, 1, 2, 4]) == 17",
      "assert Solution().sumSubarrayMins([11, 81, 94, 43, 3]) == 444"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
    "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        return par[u] = findpar(par[u]); \n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = u;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n",
    "test_cases": [
      "assert(solution.hasValidPath({{2,4,3},{6,5,2}}) == true);",
      "assert(solution.hasValidPath({{1,2,1},{1,2,1}}) == false);",
      "assert(solution.hasValidPath({{1,1,2}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.\n\nConstraints:\n1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath.",
    "buggy_code": "\nclass Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void removeEdge(int[] edge) {\n        adj.get(edge[0]).remove(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.removeEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */\n",
    "test_cases": [
      "Graph g = new Graph(4, new int[][]{{0, 2, 5}, {0, 1, 2}, {1, 2, 1}, {3, 0, 3}});",
      "if (g.shortestPath(3, 2) != 6) System.out.println(\"Test failed for shortestPath(3, 2)\");",
      "if (g.shortestPath(0, 3) != -1) System.out.println(\"Test failed for shortestPath(0, 3)\");",
      "g.addEdge(new int[]{1, 3, 4});",
      "if (g.shortestPath(0, 3) != 6) System.out.println(\"Test failed for shortestPath(0, 3) after adding edge\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def firstPalindrome(self, words: ArrayList[str]) -> str:\n        for i in words:\n            if i==i[::-1]:\n                return i\n        return \"\"\n",
    "test_cases": [
      "assert Solution().firstPalindrome([\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]) == \"ada\"",
      "assert Solution().firstPalindrome([\"notapalindrome\",\"racecar\"]) == \"racecar\"",
      "assert Solution().firstPalindrome([\"def\",\"ghi\"]) == \"\""
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n = 0) return 0;\n        return 1 + countDigits(n/10);\n    }\n\n    public int countLargestGroup(int n) {\n\n        ArrayList<Integer> list = new let [37]; \n\n        for(int i=1;i<=n;i++) {\n            int cd = missingMethod(i); \n            list.set(cd, list.get(cd)+1); // update count\n            }\n\n        return Collections.frequency(list, Collections.max(list));\n    }\n}\n",
    "test_cases": [
      "if (new Solution().countLargestGroup(13) != 4) System.out.println(\"Test failed for input 13\");",
      "if (new Solution().countLargestGroup(2) != 2) System.out.println(\"Test failed for input 2\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.\nYou can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.\nReturn true if all asteroids can be destroyed. Otherwise, return false.\n\nConstraints:\n1 <= mass <= 105\n1 <= asteroids.length <= 105\n1 <= asteroids[i] <= 105",
    "buggy_code": "\nclass Solution {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        Arrays.sort(asteroids);\n        int c=0;\n        long s=(long)mass;\n        for(int i=0;i<=asteroids.length;i++)\n        {\n            long d=(long)asteroids[i];\n            if(s>=d)\n            {\n                c-=1;\n                s+=d;\n            }\n        }\n        if(c==asteroids.length)return true;\n        else return false;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().asteroidsDestroyed(10, new int[]{3, 9, 19, 5, 21}) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().asteroidsDestroyed(5, new int[]{4, 9, 23, 4}) != false) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.\n\nConstraints:\n1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n",
    "test_cases": [
      "assert Solution().makeSmallestPalindrome(\"egcfe\") == \"efcfe\"",
      "assert Solution().makeSmallestPalindrome(\"abcd\") == \"abba\"",
      "assert Solution().makeSmallestPalindrome(\"seven\") == \"neven\""
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:\n\nThe first ten characters consist of the phone number of passengers.\nThe next character denotes the gender of the person.\nThe following two characters are used to indicate the age of the person.\nThe last two characters determine the seat allotted to that person.\n\nReturn the number of passengers who are strictly more than 60 years old.\n\nConstraints:\n1 <= details.length <= 100\ndetails[i].length == 15\ndetails[i] consists of digits from '0' to '9'.\ndetails[i][10] is either 'M' or 'F' or 'O'.\nThe phone numbers and seat numbers of the passengers are distinct.",
    "buggy_code": "\nclass Solution {\n    public int countSeniors(String[] details) {\n\n     int count=0;\n     for(int i=0;i<details.length;i++)\n     {\n         int a=details[i].charAt(11)-'0';\n         a*=10;\n         a+=details[i].charAt(12)-'0'\n         if(a>60)\n         {\n             count++;\n         }\n     }\n     return count;    \n    }\n}\n",
    "test_cases": [
      "if (new Solution().countSeniors(new String[]{\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countSeniors(new String[]{\"1313579440F2036\",\"2921522980M5644\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.\n\nConstraints:\n1 <= s.length <= 500\ns consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n                        self.undefinedMethod()\n\n            for i in letters[::-1]:\n                if i  in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                        \n                        del freq[i]\n                        self.undefinedMethod()\n\n\n        return res\n",
    "test_cases": [
      "assert Solution().sortString(\"aaaabbbbcccc\") == \"abccbaabccba\"",
      "assert Solution().sortString(\"rat\") == \"art\""
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.\nAnswers within 10-5 of the actual answer will be considered accepted.\n\nConstraints:\n20 <= arr.length <= 1000\narr.length is a multiple of 20.\n0 <= arr[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int i, k;\n        double mean;\n        sort(arr.begin(), arr.end());\n        k = 0.05*arr.size();\n        for(i=0 ; i<k ; i++)\n        {\n            arr.erase(arr.begin()+0);\n            arr.erase(arr.begin()+arr.size());\n        }\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\n        return mean;\n    }\n};\n",
    "test_cases": [
      "assert(solution.trimMean(vector<int>{1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3}) == 2.00000);",
      "assert(solution.trimMean(vector<int>{6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0}) == 4.00000);",
      "assert(solution.trimMean(vector<int>{6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4}) == 4.77778);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "A bus\u00a0has n stops numbered from 0 to n - 1 that form\u00a0a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number\u00a0i and (i + 1) % n.\nThe bus goes along both directions\u00a0i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given\u00a0start\u00a0and destination\u00a0stops.\n\nConstraints:\n1 <= n\u00a0<= 10^4\ndistance.length == n\n0 <= start, destination < n\n0 <= distance[i] <= 10^4",
    "buggy_code": "\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        int i, dis1=0, dis2=0, j, temp;\n\n        // Swapping the values of start and destination, if destination is smaller than start\n        if(start>destination)\n        {\n            temp = start;\n            start = destination;\n            destination = temp;\n        }\n\n        //Checking Forward distance\n        for(i=start ; i<destination ; i++)\n        {\n            dis1 += distance[i];\n        }\n\n        //Checking Backward distance\n        i = start;\n        j = distance.size()-destination+start;\n        while(j>0)\n        {\n            if(i<0)\n            {\n                dis2 += distance[distance.size()+i];\n            }\n            else\n                dis2 += distance[i];\n            i--;\n            j--;\n        }\n\n        // Result\n        if(dis1<dis2)\n            return dis1;\n        return dis2;\n    }\n};\n",
    "test_cases": [
      "assert(solution.distanceBetweenBusStops(vector<int>{1,2,3,4}, 0, 1) == 1);",
      "assert(solution.distanceBetweenBusStops(vector<int>{1,2,3,4}, 0, 2) == 3);",
      "assert(solution.distanceBetweenBusStops(vector<int>{1,2,3,4}, 0, 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\nConstraints:\n1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i-wlen)\n        return res\n",
    "test_cases": [
      "assert Solution().findSubstring(\"barfoothefoobarman\", [\"foo\", \"bar\"]) == [0, 9]",
      "assert Solution().findSubstring(\"wordgoodgoodgoodbestword\", [\"word\", \"good\", \"best\", \"word\"]) == []",
      "assert Solution().findSubstring(\"barfoofoobarthefoobarman\", [\"bar\", \"foo\", \"the\"]) == [6, 9, 12]"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).\n\nConstraints:\n2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
    "buggy_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(self.calculateAbsoluteDifference(s1, nums[i], i, s2, n))\n            s1=s1+nums[i]\n            s2=total-s+11\n\n        return arr\n",
    "test_cases": [
      "assert Solution().getSumAbsoluteDifferences([2,3,5]) == [4,3,5]",
      "assert Solution().getSumAbsoluteDifferences([1,4,6,8,10]) == [24,15,13,15,21]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is equal to the number of 1's.\nEvery prefix of the binary string has at least as many 1's as 0's.\n\nYou are given a special binary string s.\nA move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\nReturn the lexicographically largest resulting string possible after applying the mentioned operations on the string.\n\nConstraints:\n1 <= s.length <= 50\ns[i] is either '0' or '1'.\ns is a special binary string.",
    "buggy_code": "\nclass Solution {\npublic:\n    string makeLargestSpecial(string s) {\n        \n        if(s.length()==0)\n            return \"\"; \n\n        vector<string> ans; \n        int count=0,i=0; \n\n        for(int j=0;j<=s.size();j++){\n            if(s[j] == '1')\n                count++;\n            else\n                count--;\n            \n            if(count==0){\n                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0\");\n                i = j;\n            }\n        }\n        sort(ans.begin(),ans.end(),greater<string>());\n        string finalString = \"\";\n        for(i=0;i<=ans.size();i++){\n            finalString += ans[i];\n        }\n        return finalString;\n    }\n};\n",
    "test_cases": [
      "assert(solution.makeLargestSpecial(\"11011000\") == \"11100100\");",
      "assert(solution.makeLargestSpecial(\"10\") == \"10\");"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\nYou will do the following steps repeatedly until all cards are revealed:\n\nTake the top card of the deck, reveal it, and take it out of the deck.\nIf there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\nIf there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\nReturn an ordering of the deck that would reveal the cards in increasing order.\nNote that the first entry in the answer is considered to be the top of the deck.\n\nConstraints:\n1 <= deck.length <= 1000\n1 <= deck[i] <= 106\nAll the values of deck are unique.",
    "buggy_code": "\nclass Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(10))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return (deck[j] for i,j in ans)\n",
    "test_cases": [
      "assert Solution().deckRevealedIncreasing([17, 13, 11, 2, 3, 5, 7]) == [2, 13, 3, 11, 5, 17, 7]",
      "assert Solution().deckRevealedIncreasing([1, 1000]) == [1, 1000]"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n\nConstraints:\n1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
    "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                \n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '1') { \n                st.push(ch);\n            }\n        }\n\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n\n        String ans = \"0\";\n        while(!st.isEmpty()) {\n            ans = st.unshift() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n\n}\n",
    "test_cases": [
      "if (!new Solution().removeKdigits(\"1432219\", 3).equals(\"1219\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().removeKdigits(\"10200\", 1).equals(\"200\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().removeKdigits(\"10\", 2).equals(\"0\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nConstraints:\n1 <= s.length <= 20\ns consists of digits only.",
    "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n",
    "test_cases": [
      "assert Solution().restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]",
      "assert Solution().restoreIpAddresses(\"0000\") == [\"0.0.0.0\"]",
      "assert Solution().restoreIpAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nConstraints:\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        postorder_idx=len(postorder)-1\n\n        def treeHelper(left, right):\n            nonlocal postorder_idx\n            if left>right:\n                return None\n\n            node_val = postorder[postorder_idx]\n            root=TreeNode(node_val)\n            postorder_idx-=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(inorder_index+1, right)\n            root.right = treeHelper(left, inorder_index-1 )\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)\n",
    "test_cases": [
      "assert Solution().buildTree([9,3,15,20,7], [9,15,7,20,3]) == [3,9,20,None,None,15,7]",
      "assert Solution().buildTree([-1], [-1]) == [-1]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n\ni < j < k,\nnums[j] - nums[i] == diff, and\nnums[k] - nums[j] == diff.\n\nReturn the number of unique arithmetic triplets.\n\nConstraints:\n3 <= nums.length <= 200\n0 <= nums[i] <= 200\n1 <= diff <= 50\nnums is strictly increasing.",
    "buggy_code": "\nclass Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        \n        int count=0;\n        for(int i=0;i<=nums.length;i++){\n            for(int j=i+1;j<=nums.length;j++){\n                for(int k=j+1;k<=nums.length;k++){\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().arithmeticTriplets(new int[]{0, 1, 4, 6, 7, 10}, 3) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().arithmeticTriplets(new int[]{4, 5, 6, 7, 8, 9}, 2) != 2) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.\n\nConstraints:\n2 <= nums.length <= 500\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n    res=[]\n    for num in nums:\n        count[num]+=1 \n    for num in nums:\n        res.append(self.calculate_numbers(count[:num]))\n    return res\n",
    "test_cases": [
      "assert Solution().smallerNumbersThanCurrent([8,1,2,2,3]) == [4,0,1,1,3]",
      "assert Solution().smallerNumbersThanCurrent([6,5,4,8]) == [2,1,0,3]",
      "assert Solution().smallerNumbersThanCurrent([7,7,7,7]) == [0,0,0,0]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findRelativeRanks(vector<int>{5,4,3,2,1}) == vector<string>{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"});",
      "assert(solution.findRelativeRanks(vector<int>{10,3,8,9,4}) == vector<string>{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.\n\nConstraints:\n1 <= arr1.length, arr2.length <= 1000\n0 <= arr1[i], arr2[i] <= 1000\nAll the elements of arr2 are distinct.\nEach\u00a0arr2[i] is in arr1.",
    "buggy_code": "\nimport java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1)\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] == target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().relativeSortArray(new int[]{2,3,1,3,2,4,6,7,9,2,19}, new int[]{2,1,4,3,9,6}), new int[]{2,2,2,1,4,3,3,9,6,7,19})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().relativeSortArray(new int[]{28,6,22,8,44,17}, new int[]{22,28,8,6}), new int[]{22,28,8,6,17,44})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00\n\nConstraints:\n0 <= celsius <= 1000",
    "buggy_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1 = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().convertTemperature(36.50), new double[]{309.65000, 97.70000})) System.out.println(\"Test failed for input 36.50\");",
      "if (!Arrays.equals(new Solution().convertTemperature(122.11), new double[]{395.26000, 251.79800})) System.out.println(\"Test failed for input 122.11\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n\nConstraints:\n1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, /* String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n        }\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
    "test_cases": [
      "if (!new Solution().smallestEquivalentString(\"parker\", \"morris\", \"parser\").equals(\"makkek\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().smallestEquivalentString(\"hello\", \"world\", \"hold\").equals(\"hdld\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().smallestEquivalentString(\"leetcode\", \"programs\", \"sourcecode\").equals(\"aauaaaaada\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\n\nConstraints:\n1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
    "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.undef(u)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n",
    "test_cases": [
      "assert Solution().equationsPossible([\"a==b\",\"b!=a\"]) == False",
      "assert Solution().equationsPossible([\"b==a\",\"a==b\"]) == True"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.\n\nConstraints:\n1 <= arr.length <= 1000\n-1000 <= arr[i] <= 1000",
    "buggy_code": "\nfrom collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool\n        d=Counter(arr)\n        l=self.get_values(d)\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().uniqueOccurrences([1, 2, 2, 1, 1, 3]) == True",
      "assert Solution().uniqueOccurrences([1, 2]) == False",
      "assert Solution().uniqueOccurrences([-3, 0, 1, -3, 1, 1, 1, -3, 10, 0]) == True"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/prv\n   }\n\n   prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Mestring()Bttm Up",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.\n\nConstraints:\n1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
    "buggy_code": "\nclass DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            /* self.par[u] = self.find(self.par[u])*/\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n",
    "test_cases": [
      "if (new Solution().findCircleNum(new int[][]{{1,1,0},{1,1,0},{0,0,1}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().findCircleNum(new int[][]{{1,0,0},{0,1,0},{0,0,1}}) != 3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's\n\nConstraints:\nn == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
    "buggy_code": "\nclass Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        vector<int>& undefined;\n        for (auto i: derived) xoor ^= i;\n        xoor ^= undefined[0];\n        return !xoor;\n    }\n};\n",
    "test_cases": [
      "assert(solution.doesValidArrayExist(vector<int>{1, 1, 0}) == true);",
      "assert(solution.doesValidArrayExist(vector<int>{1, 1}) == true);",
      "assert(solution.doesValidArrayExist(vector<int>{1, 0}) == false);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 300\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a' \"=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maxLengthBetweenEqualCharacters(\"aa\") == 0);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"abca\") == 2);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"cbzxy\") == -1);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nConstraints:\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return buildTree(0, postorder.length - 2, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = null;\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().buildTree(new int[]{9,3,15,20,7}, new int[]{9,15,7,20,3}).toArray(), new Integer[]{3,9,20,null,null,15,7})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().buildTree(new int[]{-1}, new int[]{-1}).toArray(), new Integer[]{-1})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 300\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<=s.size();i++)\n            if(v[s[i]-'a']==-1)\n                v[s[i]-'a' \"=i;\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        return ans;\n    }\n computeReult(, v, s) };\n\n\n\n",
    "test_cases": [
      "assert(solution.maxLengthBetweenEqualCharacters(\"aa\") == 0);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"abca\") == 2);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"cbzxy\") == -1);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.\n\nConstraints:\n1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public int[] char_map;\n    public int countCharacters(String[] words, String chars) {\n        char_map=new int[26];\n       int ans=0;\n       for(char c : chars.toCharArray()){\n           char_map[c-'a']++;\n       }\n\n       for(String word: words){\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\n           int count =0\n           for(char c: word.toCharArray()){\n               if(dummyArray[c-'a']>0){\n                   count++;\n                   dummyArray[c-'a']--;\n               }\n           }\n           if(count==word.length()){\n               ans+=word.length();\n           }\n       }\n       return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().countCharacters(new String[]{\"cat\", \"bt\", \"hat\", \"tree\"}, \"atach\") != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countCharacters(new String[]{\"hello\", \"world\", \"leetcode\"}, \"welldonehoneyr\") != 10) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.\n\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
    "buggy_code": "\nclass Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n    \n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] = 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n    \n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 1;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumRows({{0,0,0},{1,0,1},{0,1,1},{0,0,1}}, 2) == 3);",
      "assert(solution.maximumRows({{1},{0}}, 1) == 2);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
    "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<=products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n        }\n        itr=0;\n        \n    }\n    return total;\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */\n ",
    "test_cases": [
      "Cashier cashier = new Cashier(3, 50, new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{100, 200, 300, 400, 300, 200, 100});",
      "if (Math.abs(cashier.getBill(new int[]{1, 2}, new int[]{1, 2}) - 500.0) > 1e-5) System.out.println(\"Test case 1 failed\");",
      "if (Math.abs(cashier.getBill(new int[]{3, 7}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test case 2 failed\");",
      "if (Math.abs(cashier.getBill(new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{1, 1, 1, 1, 1, 1, 1}) - 800.0) > 1e-5) System.out.println(\"Test case 3 failed\");",
      "if (Math.abs(cashier.getBill(new int[]{4}, new int[]{10}) - 4000.0) > 1e-5) System.out.println(\"Test case 4 failed\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 3}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test case 5 failed\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 5, 3, 1, 6, 4, 2}, new int[]{10, 10, 10, 9, 9, 9, 7}) - 7350.0) > 1e-5) System.out.println(\"Test case 6 failed\");",
      "if (Math.abs(cashier.getBill(new int[]{2, 3, 5}, new int[]{5, 3, 2}) - 2500.0) > 1e-5) System.out.println(\"Test case 7 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
    "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx and i != n-1: \n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans\n",
    "test_cases": [
      "assert Solution().edgeScore([1,0,0,0,0,7,7,5]) == 7",
      "assert Solution().edgeScore([2,0,0,2]) == 0"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array nums that is sorted in non-decreasing order.\nDetermine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:\n\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\nAll subsequences have a length of 3 or more.\n\nReturn true if you can split nums according to the above conditions, or false otherwise.\nA subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).\n\nConstraints:\n1 <= nums.length <= 104\n-1000 <= nums[i] <= 1000\nnums is sorted in non-decreasing order.",
    "buggy_code": "\nclssSlution {\n    publibleanisPsble(it[]nums) {\n        HashMap<Intee,Integer> avaibilityMap = new HashMap<>();\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\n        \n        fr(in i : nums){\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\n        }\n        \n        f(inti=0;i<nums.leng;++){   i(avaibilityMap.get(nums[i])<=0){\n               iu;\n         }\n            \n            if(antMap.getOrDefault(nums[i],0)>0){\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1)\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\n            }\n            \n            elif(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\n            }\n            \n            else{\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n",
    "test_cases": [
      "if (new Slution().isPsble(new int[]{1,2,3,3,4,5}) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Slution().isPsble(new int[]{1,2,3,3,4,4,5,5}) != true) System.out.println(\"Test case 2 failed\");",
      "if (new Slution().isPsble(new int[]{1,2,3,4,4,5}) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.\n\nConstraints:\nm == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
    "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n              for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '#'}}), new char[][]{{'.'}, {'#'}, {'#'}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '*', '.'}, {'#', '#', '*', '.'}}), new char[][]{{'#', '.'}, {'#', '#'}, {'*', '*'}, {'.', '.'}})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '#', '*', '.', '*', '.'}, {'#', '#', '#', '*', '.', '.'}, {'#', '#', '#', '.', '#', '.'}}), new char[][]{{'.', '#', '#'}, {'.', '#', '#'}, {'#', '#', '*'}, {'#', '*', '.'}, {'#', '.', '*'}, {'#', '.', '.'}})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.\n\nConstraints:\n1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
    "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i=j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count=0:\n                        l.append(-1)\n        return (l)\n",
    "test_cases": [
      "assert Solution().nextGreaterElement([4,1,2], [1,3,4,2]) == [-1,3,-1]",
      "assert Solution().nextGreaterElement([2,4], [1,2,3,4]) == [3,-1]"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero).\nAfter flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card.\nReturn the minimum possible good integer after flipping the cards. If there are no good integers, return 0.\n\nConstraints:\nn == fronts.length == backs.length\n1 <= n <= 1000\n1 <= fronts[i], backs[i] <= 2000",
    "buggy_code": "\nclass Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts + backs + [1001])):\n            if i in bad:\n                continue\n            return i\n        return 0\n",
    "test_cases": [
      "assert Solution().flipgame([1, 2, 4, 4, 7], [1, 3, 4, 1, 3]) == 2",
      "assert Solution().flipgame([1], [1]) == 0"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n\nConstraints:\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        /int n=digits.size();\n        digits[n-1]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};\n",
    "test_cases": [
      "assert(solution.plusOne(vector<int>{1,2,3}) == vector<int>{1,2,4});",
      "assert(solution.plusOne(vector<int>{4,3,2,1}) == vector<int>{4,3,2,2});",
      "assert(solution.plusOne(vector<int>{9}) == vector<int>{1,0});"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n\nConstraints:\n1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
    "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek())\n                st.pop();\n                k--;\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n \n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().removeKdigits(\"1432219\", 3).equals(\"1219\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().removeKdigits(\"10200\", 1).equals(\"200\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().removeKdigits(\"10\", 2).equals(\"0\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.\n\nConstraints:\n1 <= s.length <= 105\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n)\n            if not self.compareChar(s, i, j):\n                j=lps[j-1]\n\n            if s[i]=s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n",
    "test_cases": [
      "assert Solution().longestPrefix(\"level\") == \"l\"",
      "assert Solution().longestPrefix(\"ababab\") == \"abab\""
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n\nConstraints:\n1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
    "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n+1];\n        \n        for(int i=0;i<=n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            /\n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - undefinedMethod(set2);\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{1,2,3,4,5}), new int[]{-3,-1,1,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{3,2,3,4,2}), new int[]{-2,-1,0,2,3})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n\nConstraints:\n1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
    "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        }\n        return res;\n    }\n};\n",
    "test_cases": [
      "assert(solution.removeOuterParentheses(\"(()())(())\") == \"()()()\");",
      "assert(solution.removeOuterParentheses(\"(()())(())(()(()))\") == \"()()()()(())\");",
      "assert(solution.removeOuterParentheses(\"()()\") == \"\");"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.\n\nConstraints:\n1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
    "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        /count the triplets\n        int n = s.length();\n        \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++) {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n                a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n                b++;\n        }\n        if(a<=b)\n            return false;\n        else\n            return true;  \n    }\n}\n",
    "test_cases": [
      "if (!new Solution().winnerOfGame(\"AAABABB\")) System.out.println(\"Test failed for input: AAABABB, expected: true\");",
      "if (new Solution().winnerOfGame(\"AA\")) System.out.println(\"Test failed for input: AA, expected: false\");",
      "if (new Solution().winnerOfGame(\"ABBBBBBBAAA\")) System.out.println(\"Test failed for input: ABBBBBBBAAA, expected: false\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length+1){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3,4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\nImplement the AuthenticationManager class:\n\nAuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\ngenerate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\nrenew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\ncountUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n\nNote that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.\n\nConstraints:\n1 <= timeToLive <= 108\n1 <= currentTime <= 108\n1 <= tokenId.length <= 5\ntokenId consists only of lowercase letters.\nAll calls to generate will contain unique values of tokenId.\nThe values of currentTime across all the function calls will be strictly increasing.\nAt most 2000 calls will be made to all functions combined.",
    "buggy_code": "\nclass AuthenticationManager {\n\n    int timeToLive;\n    TreeSet<Integer> treeSet;\n    Map<String, Integer> map;\n    public AuthenticationManager(int timeToLive) {\n        this.timeToLive = timeToLive;\n        treeSet = new TreeSet<>();\n        map = new HashMap<>();\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.add(currentTime + timeToLive);\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n        Integer time = map.get(tokenId);\n\t\t/* \n        if (time == null || time <= currentTime) return;\n       \n\t   \n\t   // Update the hashmap and treeSet with the new values\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.remove(time);\n        treeSet.add(currentTime + timeToLive);\n         */\n\t\t// Clearing the treeset from already expired timestamps, it doesn't really improve the time execution, with about 10% only.\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\n            treeSet.remove(treeSet.lower(currentTime));\n        }\n    }\n    \n\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\n    public int countUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime, false).size();\n    }\n}\n",
    "test_cases": [
      "AuthenticationManager authenticationManager = new AuthenticationManager(5); assert (authenticationManager.renew(\"aaa\", 1) == null);",
      "assert (authenticationManager.generate(\"aaa\", 2) == null);",
      "assert (authenticationManager.countUnexpiredTokens(6) == 1);",
      "assert (authenticationManager.generate(\"bbb\", 7) == null);",
      "assert (authenticationManager.renew(\"aaa\", 8) == null);",
      "assert (authenticationManager.renew(\"bbb\", 10) == null);",
      "assert (authenticationManager.countUnexpiredTokens(15) == 0);"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.\n\nConstraints:\nn == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10",
    "buggy_code": "\nclass Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i+1]==10 or i>=2 and nums1[i-2]==10:\n                        res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n\n                if nums2[i+1]==10 or i>=2 and nums2[i-2]==10:\n                        res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)\n",
    "test_cases": [
      "assert Solution().isWinner([4,10,7,9], [6,5,2,3]) == 1",
      "assert Solution().isWinner([3,5,7,6], [8,10,10,2]) == 2",
      "assert Solution().isWinner([2,3], [4,1]) == 0"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0,1,-1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0,1,-1});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\n\nConstraints:\nn == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
    "buggy_code": "\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                mid+=1\n                high-=1\n",
    "test_cases": [
      "solution = Solution()",
      "nums1 = [2, 0, 2, 1, 1, 0]",
      "solution.sortColors(nums1)",
      "assert nums1 == [0, 0, 1, 1, 2, 2]",
      "nums2 = [2, 0, 1]",
      "solution.sortColors(nums2)",
      "assert nums2 == [0, 1, 2]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.\n\nConstraints:\n1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
    "buggy_code": "\nclass Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else s = m + 1; \n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumBeauty({{1,2},{3,2},{2,4},{5,6},{3,5}}, {1,2,3,4,5,6}) == vector<int>{2,4,5,5,6,6});",
      "assert(solution.maximumBeauty({{1,2},{1,2},{1,3},{1,4}}, {1}) == vector<int>{4});",
      "assert(solution.maximumBeauty({{10,1000}}, {5}) == vector<int>{0});"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.\n\nConstraints:\n1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
    "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num1)\n        result = str(nattu+babu)\n        return result\n",
    "test_cases": [
      "if (!new Solution().addStrings(\"11\", \"123\").equals(\"134\")) System.out.println(\"Test failed for input: num1 = \\\"11\\\", num2 = \\\"123\\\"\");",
      "if (!new Solution().addStrings(\"456\", \"77\").equals(\"533\")) System.out.println(\"Test failed for input: num1 = \\\"456\\\", num2 = \\\"77\\\"\");",
      "if (!new Solution().addStrings(\"0\", \"0\").equals(\"0\")) System.out.println(\"Test failed for input: num1 = \\\"0\\\", num2 = \\\"0\\\"\");"
    ],
    "language": "java",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.\n\nConstraints:\n3 <= nums.length <= 105\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=0;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])\\(nums[i-1]>nums[i] && nums[i]>nums[i+1]))\n   \n                swap(nums[i],nums[i+2]);  \n        }\n        return nums;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rearrangeArray(vector<int>{1,2,3,4,5}) == vector<int>{1,2,4,5,3});",
      "assert(solution.rearrangeArray(vector<int>{6,2,0,9,7}) == vector<int>{9,7,6,2,0});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\nFor example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n\nReturn the number of different expressions that you can build, which evaluates to target.\n\nConstraints:\n1 <= nums.length <= 20\n0 <= nums[i] <= 1000\n0 <= sum(nums[i]) <= 1000\n-1000 <= target <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // idx, target -> no of ways\n        map<pair<int, int>, int> memo;\n        int objVal;\n        return objVal.calculate(nums, target, 0, memo); \n    }\n\nprivate:\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\n        if (idx == nums.size()) return target == 0;\n        if (memo.count({idx, target})) return memo[{idx, target}];\n\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\n\n        return memo[{idx, target}] = positive + negative;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findTargetSumWays(vector<int>{1, 1, 1, 1, 1}, 3) == 5);",
      "assert(solution.findTargetSumWays(vector<int>{1}, 1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.\n\nConstraints:\n1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
    "buggy_code": "\nclass Solution {\n    \n    var trees = [];\n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = null;\n        \n        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,1},{2,2},{2,0},{2,4},{3,3},{4,2}}), new int[][]{{1,1},{2,0},{4,2},{3,3},{2,4}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,2},{2,2},{4,2}}), new int[][]{{4,2},{2,2},{1,2}})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\nConstraints:\nn == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
    "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid1, 0, level, 0, level, level)\n        return root  \n        \n    def buildTree(self, grid, rs, re, cs, ce, level)\n        if level == 1:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\n            new_node = Node(tl.val, True, None, None, None, None\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n\n\n",
    "test_cases": [
      "assert Solution().construct([[0,1],[1,0]]) == [[0,1],[1,0],[1,1],[1,1],[1,0]]",
      "assert Solution().construct([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]) == [[0,1],[1,1],[0,1],[1,1],[1,0],None,None,None,None,[1,0],[1,0],[1,1],[1,1]]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1(]==0:flowerbed[i]=1;n-)  n-=1\n            else if(flowerbed[i]==1): =1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1) == True",
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i==2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
    "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestString(\"cbabc\") == \"baabc\");",
      "assert(solution.smallestString(\"acbbc\") == \"abaab\");",
      "assert(solution.smallestString(\"leetcode\") == \"kddsbncd\");"
    ],
    "language": "cpp",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array nums\u200b\u200b\u200b and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.\nA subset's incompatibility is the difference between the maximum and minimum elements in that array.\nReturn the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.\nA subset is a group integers that appear in the array with no particular order.\n\nConstraints:\n1 <= k <= nums.length <= 16\nnums.length is divisible by k\n1 <= nums[i] <= nums.length",
    "buggy_code": "\nclass Solution {\npublic:\n    const int inf = 0x3f3f3f3f;\n    int minimumIncompatibility(vector<int>& nums, int k) {\n      int n = nums.size();\n      int sz = n/k; // size of every group\n      sort(nums.begin(), nums.end());\n      int dp[1<<n][n+1];  \n      memset(dp, inf, sizeof(dp));\n      for (int i = 0; i <= n; ++i) { dp[0][i] = 0; }  \n      for (int m = 0; m < (1<<n)-1; ++m) {\n        int cnt = __builtin_popcount(m);\n        for (int i = 0; i <= n; ++i) {  \n          if (dp[m][i] == inf) { continue; }\n          if (cnt%sz == 0) {\n            int j = __builtin_ffs(~m)-1;\n            dp[m|(1<<j)][j] = dp[m|(1<<j)][j]; \n          } else {\n            for (int j = i+1; j <= n; ++j) { \n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n            }\n          }\n        }\n      }\n      return dp[(1<<n)-1][n] == inf? -1: dp[(1<<n)-1][n];  \n    }\n};\n",
    "test_cases": [
      "assert(solution.minimumIncompatibility(vector<int>{1,2,1,4}, 2) == 4);",
      "assert(solution.minimumIncompatibility(vector<int>{6,3,8,1,3,1,2,2}, 4) == 6);",
      "assert(solution.minimumIncompatibility(vector<int>{5,3,3,6,3,3}, 3) == -1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] == \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n             }\n            if(seen.size() != n) return true;\n        }\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(solution.queryString(\"0110\", 3) == true);",
      "assert(solution.queryString(\"0110\", 4) == false);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.\n\nConstraints:\n3 <= num.length <= 1000\nnum only consists of digits.",
    "buggy_code": "\nclass Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())=n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().largestGoodInteger(\"6777133339\").equals(\"777\")) System.out.println(\"Test failed for input: 6777133339\");",
      "if (!new Solution().largestGoodInteger(\"2300019\").equals(\"000\")) System.out.println(\"Test failed for input: 2300019\");",
      "if (!new Solution().largestGoodInteger(\"42352338\").equals(\"\")) System.out.println(\"Test failed for input: 42352338\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00\n\nConstraints:\n0 <= celsius <= 1000",
    "buggy_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[2] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().convertTemperature(36.50), new double[]{309.65000, 97.70000})) System.out.println(\"Test failed for input 36.50\");",
      "if (!Arrays.equals(new Solution().convertTemperature(122.11), new double[]{395.26000, 251.79800})) System.out.println(\"Test failed for input 122.11\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.\n\nConstraints:\n1 <= s.length <= 105\ns consists of only digits and does not contain leading zeros.\n1 <= k <= 109",
    "buggy_code": "\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i=n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()\n",
    "test_cases": [
      "assert Solution().numberOfArrays(\"1000\", 10000) == 1",
      "assert Solution().numberOfArrays(\"1000\", 10) == 0",
      "assert Solution().numberOfArrays(\"1317\", 2000) == 8"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.\n\nConstraints:\nm == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n",
    "buggy_code": "\nclass Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            /* if img is of the starting color. */\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            /*down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};\n",
    "test_cases": [
      "assert(solution.floodFill(vector<vector<int>>{{1,1,1},{1,1,0},{1,0,1}}, 1, 1, 2) == vector<vector<int>>{{2,2,2},{2,2,0},{2,0,1}});",
      "assert(solution.floodFill(vector<vector<int>>{{0,0,0},{0,0,0}}, 0, 0, 0) == vector<vector<int>>{{0,0,0},{0,0,0}});"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n        }\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3, 4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
    "buggy_code": "\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if not root:\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,tree_ans)\n        return ans\n",
    "test_cases": [
      "assert Solution().inorderTraversal(TreeNode(1, None, TreeNode(2, TreeNode(3), None))) == [1, 3, 2]",
      "assert Solution().inorderTraversal(None) == []",
      "assert Solution().inorderTraversal(TreeNode(1)) == [1]"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.\n\nConstraints:\n1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc) == 0\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n",
    "test_cases": [
      "assert Solution().getLengthOfOptimalCompression(\"aaabcccd\", 2) == 4",
      "assert Solution().getLengthOfOptimalCompression(\"aabbaa\", 2) == 2",
      "assert Solution().getLengthOfOptimalCompression(\"aaaaaaaaaaa\", 0) == 3"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n\nConstraints:\n1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
    "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n+1];\n        \n        for(int i=0;i<=n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - undefinedMethod(set2);\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{1,2,3,4,5}), new int[]{-3,-1,1,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{3,2,3,4,2}), new int[]{-2,-1,0,2,3})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool :\n        indexes = collections.defaultdict(collections.deque)\n        for index, character in enumerate(s) :\n            indexes[int(character)].append(index)\n\n        unique_t_values = set([int(t_i) for t_i in t])\n        for t_v in unique_t_values : \n            if t_v not in indexes :\n                return False \n            \n        for character in t : \n            character_designation = int(character)\n            if character_designation not in indexes : \n                return False \n            for lesser_character in range(character_designation):\n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \n                    return False \n            indexes[character_designation].popleft()\n            if len(indexes[character_designation]) == 0 : \n                indexes.pop(character_designation)\n        \n        # if all characters able to sort, return it \n        return False\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\nConstraints:\n1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 105.",
    "buggy_code": "\nclass Solution {\n    String b;\n\n    HashMap<String, Integer> mpp;\n    List<List<String>> ans;\n    private void dfs(String word, List<String> seq) {\n        if (word.equals(b)) {\n            List<String> dup = new ArrayList<>(seq);\n            Collections.reverse(dup);\n            an\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        for (int i = 0; i < sz; i++) {\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray)\n                if (mpp.containsKey(replacedWord) && mpp.get(replacedWord) + 1 == steps) {\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        Set<String> st = new HashSet<String>();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n\n        Queue<String> q = new LinkedList<>();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap<>();\n\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n            if (word.equals(endWord)) break;\n\n            for (int i = 0; i < sizee; i++) {\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray)\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n                        mpp.put(replacedWord, steps + 1);\n                    }\n                }\n            }\n        }\n        ans = new ArrayList<>();\n        if (mpp.containsKey(endWord) == true) {\n            List<String> seq = new ArrayList<>();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().findLadders(\"hit\", \"cog\", Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\")).equals(Arrays.asList(Arrays.asList(\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"), Arrays.asList(\"hit\",\"hot\",\"lot\",\"log\",\"cog\")))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().findLadders(\"hit\", \"cog\", Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\")).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\nConstraints:\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.",
    "buggy_code": "\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            taken.remove(course)\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True\n",
    "test_cases": [
      "assert Solution().canFinish(2, [[1, 0]]) == True",
      "assert Solution().canFinish(2, [[1, 0], [0, 1]]) == False"
    ],
    "language": "python3",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "Given two binary strings a and b, return their sum as a binary string.\n\nConstraints:\n1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
    "buggy_code": "\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[i]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};\n",
    "test_cases": [
      "assert(solution.addBinary(\"11\", \"1\") == \"100\");",
      "assert(solution.addBinary(\"1010\", \"1011\") == \"10101\");"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nConstraints:\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildNewTree(in + 1, r, postorder, m); \n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().buildTree(new int[]{9,3,15,20,7}, new int[]{9,15,7,20,3}).toArray(), new Integer[]{3,9,20,null,null,15,7})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().buildTree(new int[]{-1}, new int[]{-1}).toArray(), new Integer[]{-1})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.\n\nConstraints:\ncosts.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
    "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n        while(index<100001 && coins>=index*arr[index])\n        \n            coins-=index*arr[index];\n            count+=arr[index];\n            index++\n        \n        while(index<100001 && coins>=index){\n            coins-=index;\n            index++;\n            count++;\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxIceCream(new int[]{1,3,2,4,1}, 7) != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxIceCream(new int[]{10,6,8,7,7,8}, 5) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maxIceCream(new int[]{1,6,3,1,2,5}, 20) != 6) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n\nConstraints:\n1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        char *undefinedObject;\n\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[undefinedObject[i]-'a']++;\n        }\n        \n        \n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};\n",
    "test_cases": [
      "assert(solution.buddyStrings(\"ab\", \"ba\") == true);",
      "assert(solution.buddyStrings(\"ab\", \"ab\") == false);",
      "assert(solution.buddyStrings(\"aa\", \"aa\") == true);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
    "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return True\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False\n\n        return False\n",
    "test_cases": [
      "assert Solution().isPossibleToCutPath([[1,1,1],[1,0,0],[1,1,1]]) == True",
      "assert Solution().isPossibleToCutPath([[1,1,1],[1,0,1],[1,1,1]]) == False"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).\n\nConstraints:\n1 <= nums.length <= 16\n1 <= nums[i] <= 105",
    "buggy_code": "\n\nimport functools\n\ndef countMaxOrSubsets(nums: List[int]) -> int:\n    mapping = collections.defaultdict(int)\n    for count in range(1,len(nums)+1):\n        subsets = list(itertools.combinations(nums,count))\n        for ele in subsets:\n            mapping[functools.reduce(lambda a,b: a|b,list(ele), value)] += 1\n    return mapping[max(mapping.keys())]\n",
    "test_cases": [
      "assert countMaxOrSubsets([3, 1]) == 2",
      "assert countMaxOrSubsets([2, 2, 2]) == 7",
      "assert countMaxOrSubsets([3, 2, 1, 5]) == 6"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two integer arrays startTime and endTime and given an integer queryTime.\nThe ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\nReturn the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.\n\nConstraints:\nstartTime.length == endTime.length\n1 <= startTime.length <= 100\n1 <= startTime[i] <= endTime[i] <= 1000\n1 <= queryTime <= 1000",
    "buggy_code": "\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n        int cnt=0;\n        for(int i=0;i<=n;i++)\n         /*    if(endTime[i]>=queryTime && queryTime>=startTime[i])\n            {\n                cnt++;\n            } */\n            {\n        return cnt;  \n    return cnt\n    }\n}\n\n",
    "test_cases": [
      "if (new Solution().busyStudent(new int[]{1,2,3}, new int[]{3,2,7}, 4) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().busyStudent(new int[]{4}, new int[]{4}, 4) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n\nConstraints:\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
    "buggy_code": "\nclass Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = right;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n            {\n                n++;\n            }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n            {\n                m++;\n            }\n            \n            while(j < mid && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n\n        \n        while(i < mid)\n        {\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};\n",
    "test_cases": [
      "assert(solution.countRangeSum(vector<int>{-2, 5, -1}, -2, 2) == 3);",
      "assert(solution.countRangeSum(vector<int>{0}, 0, 0) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.\nYou are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.\nFor each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.\nReturn an array answer, where answer[j] is the answer to the jth query.\n\nConstraints:\n1 <= points.length <= 500\npoints[i].length == 2\n0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500\n1 <= queries.length <= 500\nqueries[j].length == 3\n0 <= xj, yj <= 500\n1 <= rj <= 500\nAll coordinates are integers.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= abs(x2-x1) + abs(y2-y1);\n\n        if(dist<=r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i:points){\n                int x2=i[0];\n                int y2=i[1];\n\n                if(Manhattan(x1,x2,y1,y2,r)){\n                    temp++;\n                }\n\n            }\n\n            ans.push_back(temp);\n\n        }\n        return ans;\n\n    }\n};\n",
    "test_cases": [
      "assert(solution.countPoints({{1,3},{3,3},{5,3},{2,2}}, {{2,3,1},{4,3,1},{1,1,2}}) == vector<int>{3,2,2});",
      "assert(solution.countPoints({{1,1},{2,2},{3,3},{4,4},{5,5}}, {{1,2,2},{2,2,2},{4,3,2},{4,3,3}}) == vector<int>{2,3,2,4});"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n",
    "test_cases": [
      "assert(solution.maximumGap(vector<int>{3, 6, 9, 1}) == 3);",
      "assert(solution.maximumGap(vector<int>{10}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.\n\nConstraints:\nThe number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.moveleft()) or self.isSubPath(head, root.moveright())\n\n    \n    def isSame(self, head, root):\n        if head is None:\n            return True\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.moveleft()) or self.isSame(head.next, root.moveright())\n        \n        return False        \n",
    "test_cases": [
      "assert Solution().isSubPath(ListNode(4, ListNode(2, ListNode(8))), TreeNode(1, TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6))), TreeNode(4, TreeNode(2, None, TreeNode(1)), TreeNode(6, TreeNode(8), None)))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6)))), TreeNode(1, TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6))), TreeNode(4, TreeNode(2, None, TreeNode(1)), TreeNode(6, TreeNode(8), None)))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6, ListNode(8))))), TreeNode(1, TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6))), TreeNode(4, TreeNode(2, None, TreeNode(1)), TreeNode(6, TreeNode(8), None)))) == False"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\n\nConstraints:\nm == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-231 <= matrix[i][j] <= 231 - 1",
    "buggy_code": "\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        ArrayList<Integer> row = new ArrayList<>();\n        ArrayList<Integer> col = new ArrayList<>();\n        for(int i=0; i<=matrix.length; i++){\n            for(int j=0; j<=matrix[0].length; j++){\n                if(matrix[i][j] == 0){\n                    row.add(i);\n                    col.add(j);\n                }\n            }\n        }\n\n         for(int i=0; i<=matrix.length; i++){\n            if(row.contains(i)){\n                for(int j=0; j<=matrix[0].length; j++){\n                    matrix[i][j] = 0;\n                }\n            }\n            else{\n                for(int j=0; j<=matrix[0].length; j++){\n                    if(col.contains(j)){\n                        matrix[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "test_cases": [
      "int[][] matrix1 = {{1,1,1},{1,0,1},{1,1,1}}; new Solution().setZeroes(matrix1); assert java.util.Arrays.deepEquals(matrix1, new int[][]{{1,0,1},{0,0,0},{1,0,1}}) : \"Test case 1 failed\";",
      "int[][] matrix2 = {{0,1,2,0},{3,4,5,2},{1,3,1,5}}; new Solution().setZeroes(matrix2); assert java.util.Arrays.deepEquals(matrix2, new int[][]{{0,0,0,0},{0,4,5,0},{0,3,1,0}}) : \"Test case 2 failed\";"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00\n\nConstraints:\n0 <= celsius <= 1000",
    "buggy_code": "\n```java\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        UndefinedObject obj;  \n        arr[1] = (obj.celsius * 9.0/5.0) + 32.0;\n        arr[0] = obj.celsius + 273.15;\n        return arr;\n    }\n}\n```\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().convertTemperature(36.50), new double[]{309.65000, 97.70000})) System.out.println(\"Test failed for input 36.50\");",
      "if (!Arrays.equals(new Solution().convertTemperature(122.11), new double[]{395.26000, 251.79800})) System.out.println(\"Test failed for input 122.11\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\n\nConstraints:\n1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
    "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        \n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)\n",
    "test_cases": [
      "assert Solution().sumSubarrayMins([3,1,2,4]) == 17",
      "assert Solution().sumSubarrayMins([11,81,94,43,3]) == 444"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\nConstraints:\n0 <= left <= right <= 231 - 1",
    "buggy_code": "\nclass Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left)\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 1;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};\n",
    "test_cases": [
      "assert(solution.rangeBitwiseAnd(5, 7) == 4);",
      "assert(solution.rangeBitwiseAnd(0, 0) == 0);",
      "assert(solution.rangeBitwiseAnd(1, 2147483647) == 0);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nConstraints:\n1 <= n <= 45",
    "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        /*base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        array<int> dp(n);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.climbStairs(2) == 2);",
      "assert(solution.climbStairs(3) == 3);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return \"s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test failed for input [\\\"abc\\\",\\\"car\\\",\\\"ada\\\",\\\"racecar\\\",\\\"cool\\\"]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test failed for input [\\\"notapalindrome\\\",\\\"racecar\\\"]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test failed for input [\\\"def\\\",\\\"ghi\\\"]\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.\n\nConstraints:\n1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
    "buggy_code": "\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res*2   \n",
    "test_cases": [
      "assert Solution().frogPosition(7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 2, 4) == 0.16666666666666666",
      "assert Solution().frogPosition(7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 1, 7) == 0.3333333333333333"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if (flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0): flowerbed[i]=1; n-=1\n            else if(flowerbed[i]==1): n-=1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1) == True",
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Given a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\nbool find(int target) Returns true if the target value exists in the recovered binary tree.\n\nConstraints:\nTreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 104]\nTotal calls of find() is between [1, 104]\n0 <= target <= 106",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1;\n        recover(root->right, 2 * x + 2);\n    }\n    \n    FindElements(TreeNode* root) {\n        recover(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */\n",
    "test_cases": [
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1)))->find(1) == false));",
      "assert((new FindElements(new TreeNode(-1, new TreeNode(-1), new TreeNode(-1, new TreeNode(-1), nullptr)))->find(1) == true));",
      "assert((new FindElements(new TreeNode(-1, new TreeNode(-1), new TreeNode(-1, new TreeNode(-1), nullptr)))->find(3) == true));",
      "assert((new FindElements(new TreeNode(-1, new TreeNode(-1), new TreeNode(-1, new TreeNode(-1), nullptr)))->find(5) == false));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(2) == true));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(3) == false));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(4) == false));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(5) == true));"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\n\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
    "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int:\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    \n        for j in i:\n            if(d.get(j)):\n                d[j] += 1\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i)+1)//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n",
    "test_cases": [
      "assert Solution().countAnagrams(\"too hot\") == 18",
      "assert Solution().countAnagrams(\"aa\") == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given two integers m and n, which represent the dimensions of a matrix.\nYou are also given the head of a linked list of integers.\nGenerate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.\nReturn the generated matrix.\n\nConstraints:\n1 <= m, n <= 105\n1 <= m * n <= 105\nThe number of nodes in the list is in the range [1, m * n].\n0 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        mat=[[-1 for i in range(n)] for i in range(m)]\n        temp=head\n        d=1\n        rowi,colj=0,0\n        while temp!=None:\n            mat[rowi][colj]=temp.val\n            if d==1:\n                if colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=2 # Bug is here\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n            elif d==2:\n                if rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n            elif d==3:\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n            elif d==4:\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n                elif colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n            temp=temp.next\n        return mat\n",
    "test_cases": [
      "ListNode head1 = new ListNode(3, new ListNode(0, new ListNode(2, new ListNode(6, new ListNode(8, new ListNode(1, new ListNode(7, new ListNode(9, new ListNode(4, new ListNode(2, new ListNode(5, new ListNode(5, new ListNode(0, null))))))))))))));",
      "int[][] expectedOutput1 = {{3, 0, 2, 6, 8}, {5, 0, -1, -1, 1}, {5, 2, 4, 9, 7}};",
      "if (!Arrays.deepEquals(new Solution().spiralMatrix(3, 5, head1), expectedOutput1)) {",
      "System.out.println(\"Test case 1 failed\");",
      "}",
      "ListNode head2 = new ListNode(0, new ListNode(1, new ListNode(2, null)));",
      "int[][] expectedOutput2 = {{0, 1, 2, -1}};",
      "if (!Arrays.deepEquals(new Solution().spiralMatrix(1, 4, head2), expectedOutput2)) {",
      "System.out.println(\"Test case 2 failed\");",
      "}"
    ],
    "language": "java",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.\n\nConstraints:\n1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
    "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n:\n            if lcp[i][j] > 0):\n                if pattern[j] is not None and pattern[j] != pattern[i]:\n                    return ''\n                pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n",
    "test_cases": [
      "assert Solution().findTheString([[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]) == \"abab\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]) == \"aaaa\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]) == \"\""
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n/**/\n=\ncheckubcheckub\n",
    "test_cases": [
      "if (!new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3)))) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2)))) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2)))) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nConstraints:\n1 <= heights.length <= 105\n0 <= heights[i] <= 104",
    "buggy_code": "\n#include<stack>\n \nclass Solution {\npublic:\n    //function to find the index of next smallerNumber\n    vector<int> nextSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=n-1;i>=0;i--){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    //function to find the index of prev smallerNumber\n    vector<int> prevSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=0;i<n;i++){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        int size=heights.size(),h,l,area=0,curArea;\n        vector<int> next=nextElementIndex(heights); \n         vector<int> prev=prevSmallNumberIndex(heights);\n         for(int i=0;i<size;i++){\n            h=heights[i];\n            //if index of next smaller number is -1 we change its value to size \n            if(next[i]==-1)next[i]=size;\n            l=next[i]-prev[i]-1;\n            curArea=l*h;\n             area=max(area,curArea);\n\n        }\n        return area;\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.largestRectangleArea(vector<int>{2,1,5,6,2,3}) == 10);",
      "assert(solution.largestRectangleArea(vector<int>{2,4}) == 4);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n\nConstraints:\n1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        char *undefinedObject;\n\n        for(int i=0;i<=n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false;\n                }\n            }\n            freq[undefinedObject[i]-'z']++; \n        }\n        \n      if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true;\n            return false\"false\"; \n        }else if(second == -1){\n            return ;excty1 mismat\n       }\n        \n        ret(s[first]==p[second] && s[second]==p[first]);check similarity on 2 mismatched inde\n    }\n};\n",
    "test_cases": [
      "assert(solution.buddyStrings(\"ab\", \"ba\") == true);",
      "assert(solution.buddyStrings(\"ab\", \"ab\") == false);",
      "assert(solution.buddyStrings(\"aa\", \"aa\") == true);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } lse{\n                prevLazer = }\n        return ans;\n    }\n}\n\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.\n\nConstraints:\nn == grid.length == grid[i].length\n1 <= n <= 200\n-99 <= grid[i][j] <= 99",
    "buggy_code": "\nclass Solution {\n    int m;\n    int n;\n    Integer memo[][];\n\n    public int minFallingPathSum(int[][] grid)   \n         m=grid.length;\n         n=grid[0].length;\n\n         memo=new Integer[m][n];\n\n         int recRes=Integer.MAX_VALUE;\n\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\n         return Tabulation_Ans;\n    }\n\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\n            \n            if(j<0 || j>=n || i<0 || i>=m)\n                           return Integer.MAX_VALUE;\n\n            if(i==m-1)\n                     return grid[i][j];\n\n            if(memo[i][j]!=null)\n                        return memo[i][j];\n\n            int lowerLeftSum=Integer.MAX_VALUE;\n            int lowerRightSum=Integer.MAX_VALUE;\n\n            for(int col=0;col<=j-1;col++)\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\n\n            for(int col=j+1;col<=n-1;col++)\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\n\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n\n     }\n\n\n     int minFallingPathSum_Tabulation(int[][] grid){\n          int dp[][]=new int[m][n];\n\n          for(int i=m-1;i>=0;i--){\n              for(int j=n-1;j>=0;j--){\n                    \n                    if(i==m-1)\n                     {\n                         dp[i][j]=grid[i][j];\n                         continue;\n                     }\n                \n                int lowerLeftSum=Integer.MAX_VALUE;\n                int lowerRightSum=Integer.MAX_VALUE;\n\n                for(int col=0;col<=j-1;col++){\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n\n                for(int col=j+1;col<=n-1;col++){\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n                \n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n              \n              }\n          }\n           \n\n          int Ans=Integer.MAX_VALUE;\n\n          for(int COL=0;COL<n;COL++){\n              Ans=Math.min(Ans,dp[0][COL]);\n          }\n          \n          return Ans;\n     \n     }\n}\n",
    "test_cases": [
      "if (new Solution().minFallingPathSum(new int[][]{{1,2,3},{4,5,6},{7,8,9}}) != 13) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minFallingPathSum(new int[][]{{7}}) != 7) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\nYou are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\nReturn the index of the student that will replace the chalk pieces.\n\nConstraints:\nchalk.length == n\n1 <= n <= 105\n1 <= chalk[i] <= 105\n1 <= k <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<=chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       if((k%sum !=0){\n           int x = k%sum;\n           for(int i=0; i<=chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};\n",
    "test_cases": [
      "assert(solution.chalkReplacer(vector<int>{5,1,5}, 22) == 0);",
      "assert(solution.chalkReplacer(vector<int>{3,4,1,2}, 25) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There is a programming language with only four operations and one variable X:\n\n++X and X++ increments the value of the variable X by 1.\n--X and X-- decrements the value of the variable X by 1.\n\nInitially, the value of X is 0.\nGiven an array of strings operations containing a list of operations, return the final value of X after performing all the operations.\n\nConstraints:\n1 <= operations.length <= 100\noperations[i] will be either \"++X\", \"X++\", \"--X\", or \"X--\".",
    "buggy_code": "\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        int x = 0;\n        for (int i=0; i<=operations.size(); i++) {\n            if (operations[i][1] == '+') x--;\n            else x++;\n        }\n        cout << \"The final value is: ;\n        return x;\n    }\n};\n",
    "test_cases": [
      "assert(solution.finalValueAfterOperations({\"--X\",\"X++\",\"X++\"}) == 1);",
      "assert(solution.finalValueAfterOperations({\"++X\",\"++X\",\"X++\"}) == 3);",
      "assert(solution.finalValueAfterOperations({\"X++\",\"++X\",\"--X\",\"X--\"}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+2): \n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(\"Fizz\")\n            elif i%5==0:\n                l.append(\"Buzz\")\n            \n        return l\n",
    "test_cases": [
      "assert Solution().fizzBuzz(3) == [\"1\", \"2\", \"Fizz\"]",
      "assert Solution().fizzBuzz(5) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
      "assert Solution().fizzBuzz(15) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given a string word that consists of digits and lowercase English letters.\nYou will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123\u00a0 34 8\u00a0 34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\nReturn the number of different integers after performing the replacement operations on word.\nTwo integers are considered different if their decimal representations without any leading zeros are different.\n\nConstraints:\n1 <= word.length <= 1000\nword consists of digits and lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n   int numDifferentIntegers(string word) {\n        int n = word.length();\n        unordered_set<string>s;\n        int i=0;\n        while(i<n){\n            if(isdigit(word[i]) == false){\n                i++;\n                continue;\n            }\n            string temp = \"\";\n            while(i<n && isdigit(word[i])){\n                temp += word[i];\n                i--;\n            }\n            int j=0;\n            while(j<temp.length() && temp[j] == '0') j++;\n            temp = temp.substr(j);\n            s.insert(temp);\n        }\n        return s.size();\n    }\n};\n",
    "test_cases": [
      "assert(solution.numDifferentIntegers(\"a123bc34d8ef34\") == 3);",
      "assert(solution.numDifferentIntegers(\"leet1234code234\") == 2);",
      "assert(solution.numDifferentIntegers(\"a1b01c001\") == 1);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n\nConstraints:\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
    "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    = 0;\n        for (int b: balls)\n            +b > \"?10;returnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().getProbability(new int[]{1, 1}) != 1.00000) System.out.println(\"Test case failed for input [1, 1]\");",
      "if (new Solution().getProbability(new int[]{2, 1, 1}) != 0.66667) System.out.println(\"Test case failed for input [2, 1, 1]\");",
      "if (new Solution().getProbability(new int[]{1, 2, 1, 2}) != 0.60000) System.out.println(\"Test case failed for input [1, 2, 1, 2]\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++)\n            char c = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(c))){\n                count--;\n            }\n        return count;\n    }\n}\n\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\nConstraints:\nrec1.length == 4\nrec2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1 and rec2 represent a valid rectangle with a non-zero area.",
    "buggy_code": "\nclass Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        UndefinedObject rec3; \n        int left = Math.max(rec1[0],rec2[0]);\n        int right = Math.min(rec1[3], rec2[3]);\n        int top = Math.min(rec1[3],rec2[3]);\n        int bottom = Math.max(rec1[1], rec2[1]);\n        if(left < right || bottom < top)\n        return true;\n        return false;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().isRectangleOverlap(new int[]{0,0,2,2}, new int[]{1,1,3,3}) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isRectangleOverlap(new int[]{0,0,1,1}, new int[]{1,0,2,1}) != false) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isRectangleOverlap(new int[]{0,0,1,1}, new int[]{2,2,3,3}) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.\n\nConstraints:\nThe number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val = root.val: \n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n",
    "test_cases": [
      "assert Solution().isSubPath(ListNode(4, ListNode(2, ListNode(8))), TreeNode(1, TreeNode(4, TreeNode(4), TreeNode(2)), TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8))))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6)))), TreeNode(1, TreeNode(4, TreeNode(4), TreeNode(2)), TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8))))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6, ListNode(8))))), TreeNode(1, TreeNode(4, TreeNode(4), TreeNode(2)), TreeNode(2, TreeNode(1), TreeNode(6, TreeNode(8))))) == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
    "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        '''\n        dfs(m - 1, n - 1)\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return True\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n        '''\n        if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False\n\n        return False\n",
    "test_cases": [
      "assert Solution().isPossibleToCutPath([[1,1,1],[1,0,0],[1,1,1]]) == True",
      "assert Solution().isPossibleToCutPath([[1,1,1],[1,0,1],[1,1,1]]) == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the number of reverse pairs in the array.\nA reverse pair is a pair (i, j) where:\n\n0 <= i < j < nums.length and\nnums[i] > 2 * nums[j].\n\nConstraints:\n1 <= nums.length <= 5 * 104\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution {\npublic:\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\n    int i=low,j=mid+1;\n    int r=j;\n    int c=0;\n    vector<int>v;\n     while(i<=mid){\n        while(r<=high and arr[i]>(long long)2*arr[r]){\n            c++;\n            r++;\n        }\n        cnt+=c;\n        \n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\n          v.push_back(arr[i++]);\n     }\n     while(j<=high)v.push_back(arr[j++]);\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\n}\n\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\n       if(low<high){\n      int mid=low+(high-low)/2;\n      mergesort(arr,low,mid,cnt);\n      mergesort(arr,mid+1,high,cnt);\n      merge(arr,low,mid,high,cnt);\n       }\n   }\n    int reversePairs(vector<int>& arr) {\n      // merge sort -> modified merge function \n    int cnt=0;\n    int n=arr.size();\n    mergesort(arr,0,n-1,cnt);\n    if(n<=1 or cnt==0)return 0;\n    return cnt;\n   unsortedArray(arr); \n    }\n}; \n",
    "test_cases": [
      "assert(solution.reversePairs(vector<int>{1,3,2,3,1}) == 2);",
      "assert(solution.reversePairs(vector<int>{2,4,3,5,1}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.\n\nConstraints:\n1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
    "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1: \n            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n",
    "test_cases": [
      "assert Solution().componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]]) == 2",
      "assert Solution().componentValue([2], []) == 0"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.\n\nConstraints:\n1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        \n        find(v,i+1,e,sum+v[i],sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.length();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.minAbsDifference(vector<int>{5,-7,3,5}, 6) == 0);",
      "assert(solution.minAbsDifference(vector<int>{7,-9,15,-2}, -5) == 1);",
      "assert(solution.minAbsDifference(vector<int>{1,2,3}, -7) == 7);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for(String x : words) {\n            StringBuilder SB = new StringBuilder(x);\n            x = SB.reverse().toString();\n            if(x.equals(SB.toString())) {\n                return x;\n            }\n        }\n        return \"\";\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "A valid number can be split up into these components (in order):\n\nA decimal number or an integer.\n(Optional) An 'e' or 'E', followed by an integer.\n\nA decimal number can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne of the following formats:\n\t\nOne or more digits, followed by a dot '.'.\nOne or more digits, followed by a dot '.', followed by one or more digits.\nA dot '.', followed by one or more digits.\n\n\n\nAn integer can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne or more digits.\n\nFor example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\nGiven a string s, return true if s is a valid number.\n\nConstraints:\n1 <= s.length <= 20\ns consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        int n = s.length();\n        int i = 0;\n\n        // Skip leading white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // Check optional sign\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            i++;\n        }\n\n        // Check digits before decimal point\n        bool hasDigits = false;\n        while (i < n && isdigit(s[i])) {\n            i++;\n            hasDigits = true;\n        }\n\n        // Check optional decimal point and digits after it\n        if (i < n && s[i] == '.') {\n            i++;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasDigits = true;\n            }\n        }\n\n        // Check optional exponent part\n        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {\n            i++;\n\n            // Check optional sign in exponent\n            if (i < n && (s[i] == '+' || s[i] == '-')) {\n                i++;\n            }\n\n            bool hasExponentDigits = false;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasExponentDigits = true;\n            }\n\n            // The exponent must have at least one digit\n            if (!hasDigits) {\n                return false;\n            }\n        }\n\n        // Check trailing white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // The number is valid if we consumed the entire string and found at least one digit\n        return i == n && hasDigits;\n    }\n};\n",
    "test_cases": [
      "assert(solution.isNumber(\"0\") == true);",
      "assert(solution.isNumber(\"e\") == false);",
      "assert(solution.isNumber(\".\") == false);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nConstraints:\n1 <= n <= 45",
    "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-3,dp); \n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        array<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.climbStairs(2) == 2);",
      "assert(solution.climbStairs(3) == 3);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a non-negative integer array nums. In one operation, you must:\n\nChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\nSubtract x from every positive element in nums.\n\nReturn the minimum number of operations to make every element in nums equal to 0.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num == 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniqueCount(uniq_non_zero))\n\n    def uniqueCount(self, num_set: set) -> int:\n        return len(num_set)\n",
    "test_cases": [
      "assert Solution().minimumOperations([1, 5, 0, 3, 5]) == 3",
      "assert Solution().minimumOperations([0]) == 0"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3, 4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i >= n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};\n",
    "test_cases": [
      "assert(solution.numSquares(12) == 3);",
      "assert(solution.numSquares(13) == 2);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(0,n+1):\n            if i % 3==0 and  i % k==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)\n",
    "test_cases": [
      "assert Solution().fizzBuzz(3) == [\"1\", \"2\", \"Fizz\"]",
      "assert Solution().fizzBuzz(5) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
      "assert Solution().fizzBuzz(15) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n\nConstraints:\n1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
    "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1)\n        word4 = self.concat(word2)\n        if word3 == word4:\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().arrayStringsAreEqual([\"ab\", \"c\"], [\"a\", \"bc\"]) == True",
      "assert Solution().arrayStringsAreEqual([\"a\", \"cb\"], [\"ab\", \"c\"]) == False",
      "assert Solution().arrayStringsAreEqual([\"abc\", \"d\", \"defg\"], [\"abcddefg\"]) == True"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\n\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
    "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans\n",
    "test_cases": [
      "assert Solution().countAnagrams(\"too hot\") == 18",
      "assert Solution().countAnagrams(\"aa\") == 1"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.\n\nConstraints:\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\n    a=b=head\n    while(a!=None and a.next!=None):\n        b=b.moveNext()\n            a=a.moveTwoStepNext()\n        if(a==b):\n            return True\n    return False\n\n",
    "test_cases": [
      "assert Solution().hasCycle(create_linked_list([3, 2, 0, -4], 1)) == True",
      "assert Solution().hasCycle(create_linked_list([1, 2], 0)) == True",
      "assert Solution().hasCycle(create_linked_list([1], -1)) == False"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.\nYou are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.\nFind maximum possible value of the final array.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n-105 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        originalValue, sz = getOriginalValue(nums), len(nums)\n        for idx in range(sz - 1):\n            originalValue += abs(nums[idx] - nums[idx + 1])\n        finalValue = originalValue\n        for idx in range(1, sz - 1):\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\n        minimum, maximum = inf, -inf\n        for idx in range(sz - 1):\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\n            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\n            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\n            minimum = min(minimum, tempMax)\n            maximum = max(maximum, tempMin)\n        return finalValue\n",
    "test_cases": [
      "assert Solution().maxValueAfterReverse([2, 3, 1, 5, 4]) == 10",
      "assert Solution().maxValueAfterReverse([2, 4, 9, 24, 2, 1, 10]) == 68"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n\nConstraints:\n1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, /* String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        }\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
    "test_cases": [
      "if (!new Solution().smallestEquivalentString(\"parker\", \"morris\", \"parser\").equals(\"makkek\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().smallestEquivalentString(\"hello\", \"world\", \"hold\").equals(\"hdld\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().smallestEquivalentString(\"leetcode\", \"programs\", \"sourcecode\").equals(\"aauaaaaada\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.\n\nConstraints:\n1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
    "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\n        int n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n                a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)==''B'' && s.charAt(i+1)=='B' )\n                b++;\n        }\n        if(a == b)\n            return false;\n        else\n            return true;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().winnerOfGame(\"AAABABB\") != true) System.out.println(\"Test failed for input: AAABABB\");",
      "if (new Solution().winnerOfGame(\"AA\") != false) System.out.println(\"Test failed for input: AA\");",
      "if (new Solution().winnerOfGame(\"ABBBBBBBAAA\") != false) System.out.println(\"Test failed for input: ABBBBBBBAAA\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nConstraints:\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length())return false;\n        HashMap<Character,Integer> map=null;\n        for(int i=0;i<s.length();i++){\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\n            map.put(t.charAt(i),map.getOrDefault(t.charAt(i),0)-1);\n        }\n        \n        for(int i=0;i<s.length();i++){\n            if(map.get(s.charAt(i))!=0)\n            return false;\n        }\n        return true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().isAnagram(\"anagram\", \"nagaram\")) System.out.println(\"Test failed for input: s = \\\"anagram\\\", t = \\\"nagaram\\\". Expected: true\");",
      "if (new Solution().isAnagram(\"rat\", \"car\")) System.out.println(\"Test failed for input: s = \\\"rat\\\", t = \\\"car\\\". Expected: false\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n\nConstraints:\n1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
    "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"0\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n\n}\n",
    "test_cases": [
      "if (!new Solution().removeKdigits(\"1432219\", 3).equals(\"1219\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().removeKdigits(\"10200\", 1).equals(\"200\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().removeKdigits(\"10\", 2).equals(\"0\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.\n\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\n-109 <= matrix[i][j] <= 109",
    "buggy_code": "\nclass Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] ans = new int[matrix[0].length][matrix.length];\n        int row = 0;\n        int col = 0;\n\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                ans[row][col] = matrix[j][i];\n\n                row++;\n\n                if(row % ans.length == 0) {\n                    row = 0;\n                    col++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().transpose(new int[][]{{1,2,3},{4,5,6},{7,8,9}}), new int[][]{{1,4,7},{2,5,8},{3,6,9}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().transpose(new int[][]{{1,2,3},{4,5,6}}), new int[][]{{1,4},{2,5},{3,6}})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.\n\nConstraints:\n1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
    "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        out=[]\n        for i in range(0,len(nums1)):\n            if(nums2.index(nums1[i])==len(nums2)-1):\n                out.append(-1)\n            else:\n                j=nums2.index(nums1[i])+1\n                while(1):\n                    if(nums1[i]<nums2[j]):\n                        out.append(nums2[j])\n                        self.undefinedMethod()\n                        break\n                    if(j==len(nums2)-1):\n                        out.append(-1)\n                        break\n                    j+=1\n        return out\n",
    "test_cases": [
      "assert Solution().nextGreaterElement([4,1,2], [1,3,4,2]) == [-1, 3, -1]",
      "assert Solution().nextGreaterElement([2,4], [1,2,3,4]) == [3, -1]"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    foreach (var it in m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n",
    "test_cases": [
      "assert(solution.maximumGap(vector<int>{3,6,9,1}) == 3);",
      "assert(solution.maximumGap(vector<int>{10}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] and target consist of only lowercase English letters.\n0 <= startIndex < words.length",
    "buggy_code": "\nclass Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while ((i>=0 || j<n)){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || j<n && words[j%n]==target){\n                return cnt1;\n            }\n            i--; j++;\n        }\n        \n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.closetTarget(vector<string>{\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"}, \"hello\", 1) == 1);",
      "assert(solution.closetTarget(vector<string>{\"a\",\"b\",\"leetcode\"}, \"leetcode\", 0) == 1);",
      "assert(solution.closetTarget(vector<string>{\"i\",\"eat\",\"leetcode\"}, \"ate\", 0) == -1);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    foreach (var it in m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n",
    "test_cases": [
      "assert(solution.maximumGap(vector<int>{3, 6, 9, 1}) == 3);",
      "assert(solution.maximumGap(vector<int>{10}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\n\nConstraints:\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\ndef thirdMax(self, nums: List[int]) -> int:\n    return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]\n",
    "test_cases": [
      "assert Solution().thirdMax([3, 2, 1]) == 1",
      "assert Solution().thirdMax([1, 2]) == 2",
      "assert Solution().thirdMax([2, 2, 3, 1]) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:\n\ni - k <= r <= i + k,\nj - k <= c <= j + k, and\n(r, c) is a valid position in the matrix.\n\nConstraints:\nm ==\u00a0mat.length\nn ==\u00a0mat[i].length\n1 <= m, n, k <= 100\n1 <= mat[i][j] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[][] matrixBlockSum(int[][] mat, int k) {\n        int[][] answer = new int[mat.length][mat[0].length];\n\n        for(int i = 0; i < mat.length; i++) {\n            for(int j = 0; j < mat[0].length; j++) {\n                int rowStart = i-k;\n                int rowEnd = i+k;\n                int colStart = j-k;\n                int colEnd = j+k;\n\n                if(rowStart < 0) {\n                    rowStart = 0;\n                }\n\n                if(rowEnd >= mat.length) {\n                    rowEnd = mat.length - 1;\n                }\n\n                if(colStart < 0) {\n                    colStart = 0;\n                }\n\n                if(colEnd >= mat[0].length) {\n                    colEnd = mat[0].length - 1;\n                }\n\n                answer[i][j] = calculatorBlockSum(mat, rowStart, rowEnd, colStart, colEnd);\n            }\n        }\n\n        return answer;\n    }\n\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int sum = 0;\n\n        for(int i = rowStart; i <= rowEnd; i++) {\n            for(int j = colStart; j < colEnd; j++) {\n                sum += mat[i][j];\n            }\n        }\n        return sum;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().matrixBlockSum(new int[][]{{1,2,3},{4,5,6},{7,8,9}}, 1), new int[][]{{12,21,16},{27,45,33},{24,39,28}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().matrixBlockSum(new int[][]{{1,2,3},{4,5,6},{7,8,9}}, 2), new int[][]{{45,45,45},{45,45,45},{45,45,45}})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.\n\nConstraints:\n1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
    "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n:\n                if lcp[i][j] > 0):\n                    if pattern[j] is not None and pattern[j] != pattern[i]:      \n                        return ''      \n                    pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n",
    "test_cases": [
      "assert Solution().findTheString([[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]) == \"abab\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]) == \"aaaa\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]) == \"\""
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of\u00a0integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\n\ni + 1 where:\u00a0i + 1 < arr.length.\ni - 1 where:\u00a0i - 1 >= 0.\nj where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.\n\nConstraints:\n1 <= arr.length <= 5 * 104\n-108 <= arr[i] <= 108",
    "buggy_code": "\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<=arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al)\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                al.clear();\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minJumps(new int[]{100,-23,-23,404,100,23,23,23,3,404}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minJumps(new int[]{7}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minJumps(new int[]{7,6,9,6,9,6,9,7}) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.\n\nConstraints:\n1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
    "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i<pivot:val.append(i)\n            elif i==pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp\n",
    "test_cases": [
      "assert Solution().pivotArray([9,12,5,10,14,3,10], 10) == [9,5,3,10,10,12,14]",
      "assert Solution().pivotArray([-3,4,3,2], 2) == [-3,2,4,3]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5,4,3,2,1}), new String[]{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10,3,8,9,4}), new String[]{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n\nTake their own seat if it is still available, and\nPick other seats randomly when they find their seat occupied\n\nReturn the probability that the nth person gets his own seat.\n\nConstraints:\n1 <= n <= 105",
    "buggy_code": "\nclass Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        if(n = 1)\n        return 1.00000;\n        return 0.50000;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().nthPersonGetsNthSeat(1) != 1.00000) System.out.println(\"Test failed for input 1\");",
      "if (new Solution().nthPersonGetsNthSeat(2) != 0.50000) System.out.println(\"Test failed for input 2\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Design a stack that supports increment operations on its elements.\nImplement the CustomStack class:\n\nCustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.\nvoid push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.\nint pop() Pops and returns the top of the stack or -1 if the stack is empty.\nvoid inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.\n\nConstraints:\n1 <= maxSize, x, k <= 1000\n0 <= val <= 100\nAt most 1000 calls will be made to each method of increment, push and pop each separately.",
    "buggy_code": "\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.m = maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.m:\n            self.arr.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return(self.arr.pop(-1))\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\n",
    "test_cases": [
      "CustomStack stk1 = new CustomStack(3); assert stk1.pop() == -1;",
      "stk1.push(1); assert stk1.pop() == 1;",
      "stk1.push(2); assert stk1.pop() == 2;",
      "stk1.push(2); assert stk1.pop() == 2;",
      "stk1.push(3); assert stk1.pop() == 3;",
      "stk1.push(4); assert stk1.pop() == 3; // stack still [1, 2, 3]",
      "stk1.increment(5, 100); assert stk1.pop() == 103; // stack becomes [101, 102, 103]",
      "stk1.increment(2, 100); assert stk1.pop() == 202; // stack becomes [201, 202]",
      "assert stk1.pop() == 201; // stack becomes []",
      "assert stk1.pop() == -1; // stack is empty return -1"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    static bool cmp(int a , int b){\n        return a>b;\n    }\n    int deleteGreatestValue(vector<vector<int>>& grid) {\n        int ans = 0;\n        \n        vector<vector<int>> mat = grid;\n        \n        \n        for(int i=0 ; i<grid.size() ; i++){\n            sort(mat[i].begin() , mat[i].end() , cmp);\n        }\n        \n        for(int j=0 ; j<mat[0].size() ; j++){\n            vector<int> tmp(mat.size());\n            for(int i=0 ; i<mat.size() ; i++){\n               \n                tmp.push_back(mat[i][j]);\n            }\n           \n            sort(tmp.begin() , tmp.end , cmp);\n            \n            ans = ans + tmp[0];\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.deleteGreatestValue({{1,2,4},{3,3,1}}) == 8);",
      "assert(solution.deleteGreatestValue({{10}}) == 10);"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nConstraints:\n1 <= s.length <= 20\ns consists of digits only.",
    "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n",
    "test_cases": [
      "assert Solution().restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]",
      "assert Solution().restoreIpAddresses(\"0000\") == [\"0.0.0.0\"]",
      "assert Solution().restoreIpAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nConstraints:\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
    "buggy_code": "\n\n\n\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i <= inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return buildTree(0, postorder.length - 2, postorder, m;\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = null;\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(solution.buildTree(new int[]{9,3,15,20,7}, new int[]{9,15,7,20,3}), new TreeNode[]{new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7)))})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(solution.buildTree(new int[]{-1}, new int[]{-1}), new TreeNode[]{new TreeNode(-1)})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\nConstraints:\n1 <= beginWord.length <= 10\nendWord.length == beginWord.length\n1 <= wordList.length <= 5000\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.",
    "buggy_code": "\nclass Pair{\n    String first;\n    int second;\n    Pair(String first,int second){\n        this.first=first;\n        this.second=second;\n    }\n}\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Queue<Pair> q=new ArrayDeque<>();\n        Pair undefinedPair;\n        //initially adding beginword and sequence length 1 into queue\n        q.add(undefinedPair);\n        //adding all words in HashSet \n        HashSet<String> set=new HashSet<>();\n        for(int i=0;i<wordList.size();i++){\n            set.add(wordList.get(i));\n        }\n        set.remove(beginWord);\n        while(!q.isEmpty()){\n            String rem=q.peek().first;\n            int steps=q.peek().second;\n            q.remove();\n            if(rem.equals(endWord))return steps;\n            //for every character doing a change,so traverse to all the characters\n            for(int i=0;i<rem.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    char replacedcharArray[]=rem.toCharArray();\n                    replacedcharArray[i]=ch;\n                    String replacedword=new String(replacedcharArray);\n                    //exist in the set?\n                    if(set.contains(replacedword)){\n                        set.remove(replacedword);\n                        q.add(new Pair(replacedword,steps+1));\n                    }\n                }\n            }\n\n        }\n        return 0;\n\n    }\n}\n",
    "test_cases": [
      "if (new Solution().ladderLength(\"hit\", \"cog\", Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\")) != 5) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().ladderLength(\"hit\", \"cog\", Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\")) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs.\nYou are given an array of employees employees where:\n\nemployees[i].id is the ID of the ith employee.\nemployees[i].importance is the importance value of the ith employee.\nemployees[i].subordinates is a list of the IDs of the direct subordinates of the ith employee.\n\nGiven an integer id that represents an employee's ID, return the total importance value of this employee and all their direct and indirect subordinates.\n\nConstraints:\n1 <= employees.length <= 2000\n1 <= employees[i].id <= 2000\nAll employees[i].id are unique.\n-100 <= employees[i].importance <= 100\nOne employee has at most one direct leader and may have several subordinates.\nThe IDs in employees[i].subordinates are valid IDs.",
    "buggy_code": "\nclass Solution {\n    public int getImportance(List<Employee> employees, int id) {\n        Map<Integer, Employee> inputMap = new HashMap<>();\n        for(Employee e : employees) {\n            inputMap.put(e.id, e);\n        }\n        return helper(inputMap, id);\n    }\n\n    private static int helper(Map<Integer, Employee> inputMap, int id) {\n        let imp = inputMap.get(id).importance;\n\n        for(int subId : inputMap.get(id).getSubordinates()) {\n            imp += helper(inputMap, subId);\n        }\n\n        return imp;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().getImportance(Arrays.asList(new Employee(1, 5, Arrays.asList(2, 3)), new Employee(2, 3, Arrays.asList()), new Employee(3, 3, Arrays.asList())), 1) != 11) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().getImportance(Arrays.asList(new Employee(1, 2, Arrays.asList(5)), new Employee(5, -3, Arrays.asList())), 5) != -3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        Arrays.sort(strs);\n        String start = strs[0];\n        String end = strs[strs.length];\n        int count = 0;\n        for (int i = 0; i < start.length(); i++) {\n            if (start.charAt(i) == end.charAt(i)) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return end.substring(0, count);\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().longestCommonPrefix(new String[]{\"flower\", \"flow\", \"flight\"}).equals(\"fl\")) System.out.println(\"Test failed for input: [flower, flow, flight]\");",
      "if (!new Solution().longestCommonPrefix(new String[]{\"dog\", \"racecar\", \"car\"}).equals(\"\")) System.out.println(\"Test failed for input: [dog, racecar, car]\");"
    ],
    "language": "java",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.\n\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100\n-105 <= k <= 105",
    "buggy_code": "\n\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n       \n        for(int left =0 ;left<matrix[0].length; left++){\n         \n            int[] rSum = new int[matrix.length];\n          \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] -= matrix[row][right];\n           \n                    \n            \n                TreeSet<Integer> set = new TreeSet<>();\n              \n                set.add(0);\n                int cs = 0;\n               \n                for(int a: rSum){\n                    cs += a;\n                                                                      \n                    Integer target = set.ceiling(cs-k;\n                  \n                    if(target !=null)\n                        result = Math.max(result,cs-\"invalid string\");\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxSumSubmatrix(new int[][]{{1,0,1},{0,-2,3}}, 2) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxSumSubmatrix(new int[][]{{2,2,-1}}, 3) != 3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution:\n    def totalMoney(self, n: int) -> int:\n        income=1;a=[1];ans=0\n        for i in range(n):\n            if i%7==0 and i!=0:income=(a[len(a)-8])\n            ans+=income;income+=1;a.append(income)      \n        return ans\n",
    "test_cases": [
      "assert Solution().totalMoney(4) == 10",
      "assert Solution().totalMoney(10) == 37",
      "assert Solution().totalMoney(20) == 96"
    ],
    "language": "python3",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\nConstraints:\n0 <= left <= right <= 231 - 1",
    "buggy_code": "\nclass Solution {\npublic:\n    int solve(int left , int right){\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0     return 1;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n        return solve(left , right);\n    }\n};\n",
    "test_cases": [
      "assert(solution.rangeBitwiseAnd(5, 7) == 4);",
      "assert(solution.rangeBitwiseAnd(0, 0) == 0);",
      "assert(solution.rangeBitwiseAnd(1, 2147483647) == 0);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(solution.queryString(\"0110\", 3) == true);",
      "assert(solution.queryString(\"0110\", 4) == false);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 2 * 104].\n1 <= Node.val <= 105\n1 <= low <= high <= 105\nAll Node.val are unique.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nint sum = 0; // Initialised Sum\n    void Traversal(TreeNode* root,int low,int high)\n    {\n        if(root==NULL) // If Node is NULL then we return \n        return;\n        Traversal(root->left,low,high); // To check for left Node\n        ProcessNode(root);\n        Traversal(root->right,low,high); // To check for right Node\n    }\n    void ProcessNode(TreeNode* root) {\n        if(root->val > high && root->val <low)sum+=root->val;\n    }\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        ios_base::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout.tie(nullptr); // To make input output fast\n        let traversalStart = Traversal(root,low,high); \n        return sum;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rangeSumBST(new TreeNode(10, new TreeNode(5, new TreeNode(3), new TreeNode(7)), new TreeNode(15, nullptr, new TreeNode(18))), 7, 15) == 32);",
      "assert(solution.rangeSumBST(new TreeNode(10, new TreeNode(5, new TreeNode(3), new TreeNode(7, new TreeNode(6), nullptr)), new TreeNode(15, new TreeNode(13), new TreeNode(18))), 6, 10) == 23);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X.\nFor example, \"tars\"\u00a0and \"rats\"\u00a0are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.\u00a0 Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.\u00a0 Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?\n\nConstraints:\n1 <= strs.length <= 300\n1 <= strs[i].length <= 300\nstrs[i] consists of lowercase letters only.\nAll words in strs have the same length and are anagrams of each other.",
    "buggy_code": "\nclass Solution {\n    boolean isSimilar(String str1,String str2)\n    {\n        int count=0;\n        for(int i=0;i<str1.length();i++)\n        {\n            if(str1.charAt(i)!=str2.charAt(i))\n            {\n                count++;\n                if(count>2)\n                {\n                    return false\n                }\n            }\n            \n        }\n        return count==0 || count==2;\n    }\n    void dfs(String curr, String []strs, Set<String> visited)\n    {\n        //base condition\n        if(visited.contains(curr))\n        {\n            return;\n        }\n        visited.add(curr);\n        for(int i=0;i<strs.length;i++)\n        {\n         if(isSimilar(curr,strs[i]))\n         {\n             dfs(strs[i],strs,visited);\n         }   \n        }\n    }\n    public int numSimilarGroups(String[] strs)\n    {\n        int count =0;\n\n        //Base condition\n        if(strs==null ||strs.length ==0)\n        {\n            return 0;\n        }\n\n        //now create a set for visited elements which are similar\n        Set<String> visited = new HashSet<>();\n        for(String s:strs)\n        {\n            if(!visited.contains(s))\n            {\n                dfs(s,strs,visited);\n                count++;\n            }\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numSimilarGroups(new String[]{\"tars\", \"rats\", \"arts\", \"star\"}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numSimilarGroups(new String[]{\"omv\", \"ovm\"}) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.\n\nConstraints:\n3 <= nums.length <= 105\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=0;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   \n                swapp(nums[i],nums[i+1]);  \n        }\n        return nums;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rearrangeArray(vector<int>{1,2,3,4,5}) == vector<int>{1,2,4,5,3});",
      "assert(solution.rearrangeArray(vector<int>{6,2,0,9,7}) == vector<int>{9,7,6,2,0});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.\n\nConstraints:\n1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i+1][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total\n",
    "test_cases": [
      "assert Solution().numberOfArithmeticSlices([2, 4, 6, 8, 10]) == 7",
      "assert Solution().numberOfArithmeticSlices([7, 7, 7, 7, 7]) == 16"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\nConstraints:\n1 <= beginWord.length <= 10\nendWord.length == beginWord.length\n1 <= wordList.length <= 5000\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.",
    "buggy_code": "\nclass Pair{\n    String first;\n    int second;\n    Pair(String first,int second){\n        this.first=\"first;\n        this.second=second;\n    }\n}\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Queue<Pair> q=new ArrayDeque<>();\n        q.add(new Pair(beginWord,1));HashSet<String> set=new HashSet<>();\n        for(int i=0;i<=wordList.size();i++){\n            set.add(wordList.get(i));\n        }\n        set.remove(beginWord);\n        while(!q.isEmpty()){\n            String rem=q.peek().first;\n            int steps=q.peek().second;\n            q.remove();\n            \n            \n            for(int i=0;i<rem.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    char replacedcharArray[]=rem.toCharArray();\n                    replacedcharArray[i]=ch;\n                    String replacedword=new String(replacedcharArray);\n                    if(set.contains(replacedword)){\n                        set.remove(replacedword);\n                        q.add(new Pair(replacedword,steps+1));\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().ladderLength(\"hit\", \"cog\", Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\")) != 5) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().ladderLength(\"hit\", \"cog\", Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\")) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x.\nReturn the maximum number of consecutive integer values that you can make with your coins starting from and including 0.\nNote that you may have multiple coins of the same value.\n\nConstraints:\ncoins.length == n\n1 <= n <= 4 * 104\n1 <= coins[i] <= 4 * 104",
    "buggy_code": "\nclass Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    \n    if coin > ans:\n        return ans\n    ans += coin\n\n  return ans\n",
    "test_cases": [
      "assert Solution().getMaximumConsecutive([1, 3]) == 2",
      "assert Solution().getMaximumConsecutive([1, 1, 1, 4]) == 8",
      "assert Solution().getMaximumConsecutive([1, 4, 10, 3, 1]) == 20"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\nConstraints:\n1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 105.",
    "buggy_code": "\nclass Solution {\n    String b;\n\n    HashMap < String, Integer > mpp;\n\n    List < List < String >> ans;\n    private void dfs(String word, List < String > seq) {\n\n        if (word.equals(b)) {\n\n            List < String > dup = new ArrayList < > (seq);\n            Collections.reverse(dup);\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        for (int i = 0; i < sz; i++) {\n\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray);\n                if (mpp.containsKey(replacedWord) &&\n                    mpp.get(replacedWord) + 1 == steps {\n\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List < List < String >> findLadders(String beginWord, String endWord,\n        List < String > wordList) {\n\n        Set < String > st = new HashSet < String > ();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n\n        Queue < String > q = new LinkedList < > ();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap < > ();\n\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n\n            if (word.equals(endWord)) break;\n\n            for (int i = 0; i < sizee; i++) {\n\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray);\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n\n                        mpp.put(replacedWord, steps + 1);\n                    }\n                }\n\n\n            }\n        }\n        ans = new ArrayList < > ();\n\n        if (mpp.containsKey(endWord) == true) {\n            List < String > seq = new ArrayList < > ();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().findLadders(\"hit\", \"cog\", Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\")).equals(Arrays.asList(Arrays.asList(\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"), Arrays.asList(\"hit\", \"hot\", \"lot\", \"log\", \"cog\")))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().findLadders(\"hit\", \"cog\", Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\")).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\n\nConstraints:\nn == nums.length\n1 <= n <= 105\n1 <= nums[i] <= n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0;\n        while (i<n) {\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\n                swap(nums[i], nums[nums[i]]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        return res;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findDisappearedNumbers(vector<int>{4,3,2,7,8,2,3,1}) == vector<int>{5,6});",
      "assert(solution.findDisappearedNumbers(vector<int>{1,1}) == vector<int>{2});"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.\n\nConstraints:\nn == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
    "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n+1)   \n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.push(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return iflst\n",
    "test_cases": [
      "assert Solution().findAllRecipes([\"bread\"], [[\"yeast\", \"flour\"]], [\"yeast\", \"flour\", \"corn\"]) == [\"bread\"]",
      "assert Solution().findAllRecipes([\"bread\", \"sandwich\"], [[\"yeast\", \"flour\"], [\"bread\", \"meat\"]], [\"yeast\", \"flour\", \"meat\"]) == [\"bread\", \"sandwich\"]",
      "assert Solution().findAllRecipes([\"bread\", \"sandwich\", \"burger\"], [[\"yeast\", \"flour\"], [\"bread\", \"meat\"], [\"sandwich\", \"meat\", \"bread\"]], [\"yeast\", \"flour\", \"meat\"]) == [\"bread\", \"sandwich\", \"burger\"]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1(]==0:flowerbed[i2]=1;n-)  n-=1\n            else if(flowerbed[i]==1): =1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1) == True",
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \nfun(s, k , index+, prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][prev];\n               else if(abs(s[index]-'a') - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n  fun(        }\n        }\n\n       return max(dp[0][s[0]-'a']) , dp[0][26]);\n   }\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return SolveByTab(s, k);\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i > n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr=, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};\n",
    "test_cases": [
      "assert(solution.numSquares(12) == 3);",
      "assert(solution.numSquares(13) == 2);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\npublic:\n    int minSwaps(string s);\n}; \n\nint Solution::maxSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/2;\n    }\n",
    "test_cases": [
      "assert(solution.minSwaps(\"][][]\") == 1);",
      "assert(solution.minSwaps(\"]]][[[\") == 2);",
      "assert(solution.minSwaps(\"[]\") == 0);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 300\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<=s.size();i++)\n            if(v[s[i]-'a']==-1)\n                v[s[i]-'a']=i;\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        return ans;\n    }\n computeReult(, v, s) };\n\n\n",
    "test_cases": [
      "assert(solution.maxLengthBetweenEqualCharacters(\"aa\") == 0);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"abca\") == 2);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"cbzxy\") == -1);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    int binaryS(vector<int>& v, int sz) {\n        int l=0, r=sz, mid;\n        while(l<r){\n            Solution ob;\n            mid=l+(r-l)/2;\n            if(ob.v[mid]<0) r=mid;\n            else l=mid+1;\n        }\n        return r;  \n    }\n\n    int countNegatives(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        int sum=0;\n\n        vector<int> col0(n);\n        for(int i=0; i<n; i++) col0[i]=grid[i][0];\n        int i_max=binaryS(col0, n);\n\n        for (int i=0; i<i_max; i++){\n            sum+= m-binaryS(grid[i], m);\n        }\n\n        sum+=(n-i_max)*m;\n        return sum;  \n    }\n};\n",
    "test_cases": [
      "assert(solution.countNegatives(vector<vector<int>>{{4,3,2,-1},{3,2,1,-1},{1,1,-1,-2},{-1,-1,-2,-3}}) == 8);",
      "assert(solution.countNegatives(vector<vector<int>>{{3,2},{1,0}}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i=0\n        c=0\n        j=len(nums)\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c\n",
    "test_cases": [
      "assert Solution().findTheArrayConcVal([7, 52, 2, 4]) == 596",
      "assert Solution().findTheArrayConcVal([5, 14, 13, 8, 12]) == 673"
    ],
    "language": "python3",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.\n\nConstraints:\nm == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
    "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '#'}}), new char[][]{{'.'}, {'#'}, {'#'}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '*', '.'}, {'#', '#', '*', '.'}}), new char[][]{{'#', '.'}, {'#', '#'}, {'*', '*'}, {'.', '.'}})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '#', '*', '.', '*', '.'}, {'#', '#', '#', '*', '.', '.'}, {'#', '#', '#', '.', '#', '.'}}), new char[][]{{'.', '#', '#'}, {'.', '#', '#'}, {'#', '#', '*'}, {'#', '*', '.'}, {'#', '.', '*'}, {'#', '.', '.'}})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums with the following properties:\n\nnums.length == 2 * n.\nnums contains n + 1 unique elements.\nExactly one element of nums is repeated n times.\n\nReturn the element that is repeated n times.\n\nConstraints:\n2 <= n <= 5000\nnums.length == 2 * n\n0 <= nums[i] <= 104\nnums contains n + 1 unique elements and one of them is repeated exactly n times.",
    "buggy_code": "\nclass Solution {\n    public int repeatedNTimes(int[] nums) {\n        HashSet<Integer>set=new HashSet<>();\n     /*   for(int n:nums){\n            if(!set.contains(n)){\n                set.add(n);\n            }else{\n                return n+1;\n            }\n        }*/\n        return 0;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().repeatedNTimes(new int[]{1, 2, 3, 3}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().repeatedNTimes(new int[]{2, 1, 2, 5, 3, 2}) != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().repeatedNTimes(new int[]{5, 1, 5, 2, 5, 3, 5, 4}) != 5) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util1(s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minSwaps(\"][][]\") != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minSwaps(\"]]][[[\") != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minSwaps(\"[]\") != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\nConstraints:\nrec1.length == 4\nrec2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1 and rec2 represent a valid rectangle with a non-zero area.",
    "buggy_code": "\nclass Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        UndefinedObject rec3; \n        int left = Math.max(rec1[0],rec2[0]);\n        int right = Math.min(rec1[2], rec2[2]);\n        int top = Math.min(rec1[3],rec2[3]);\n        int bottom = Math.max(rec1[1], rec2[1]);\n        if(left < right || bottom < top)\n        return true;\n        return false;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().isRectangleOverlap(new int[]{0,0,2,2}, new int[]{1,1,3,3}) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isRectangleOverlap(new int[]{0,0,1,1}, new int[]{1,0,2,1}) != false) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isRectangleOverlap(new int[]{0,0,1,1}, new int[]{2,2,3,3}) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000",
    "buggy_code": "\nclass Solution {\n    public int countPossibility(int []nums,int x){\n        int cnt=0;\n        for(int n:nums) if(n>x) cnt++;\n        return cnt;\n    }\n    public int specialArray(int[] nums) {\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\n        for(int x:nums) maxi=Math.max(maxi,x);\n        int end = maxi;\n        while(start<=end){\n            mid = (start+end)/2;\n            int check = countPossibility(nums,mid);\n            if(check==mid) return mid;\n            if(mid<check) start=mid+1;\n            else end=mid-1;\n        }\n        return -1;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().specialArray(new int[]{3, 5}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().specialArray(new int[]{0, 0}) != -1) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().specialArray(new int[]{0, 4, 3, 0, 4}) != 3) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)+1): \n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.right)  \n                    queue.append(tmp.left)   \n\n            if levels:\n                lst.add(levels)\n        return lst[::-1]\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\nThe happiness of each person is calculated as follows:\n\nIntroverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).\nExtroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\nThe grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.\n\nConstraints:\n1 <= m, n <= 5\n0 <= introvertsCount, extrovertsCount <= min(m * n, 6)",
    "buggy_code": "\n//from votrubac\nclass Solution {\npublic:\n   int dp[25][7][7][64][64] = {};\nint nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {\n    int diff = 0, up = (1 << (n - 1));\n    if (j > 0 && (mask_in & 1))\n        diff += d - 30;\n    if (i > 0 && (mask_in & up))\n        diff += d - 30;\n    if (j > 0 && (mask_ex & 1))\n        diff += d + 20;\n    if (i > 0 && (mask_ex & up))\n        diff += d + 20;\n    return diff;\n}\nint dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {\n    int i = p / n, j = p % n;\n    if (i >= m)\n        return 0;\n    if (dp[p][in][ex][mask_in][mask_ex])\n        return dp[p][in][ex][mask_in][mask_ex] - 1;\n    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;\n    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);\n    if (in > 0) {\n        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);\n        res = max(res, diff + dfs(m, n, p + 2, in - 1, ex, n_mask_in + 1, n_mask_ex)); \n    }\n    if (ex > 0) {\n        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, 20);\n        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));\n    }\n    dp[p][in][ex][mask_in][mask_ex] = res + 1;\n    return res;\n}\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);\n}\n};\n",
    "test_cases": [
      "assert(solution.getMaxGridHappiness(2, 3, 1, 2) == 240);",
      "assert(solution.getMaxGridHappiness(3, 1, 2, 1) == 260);",
      "assert(solution.getMaxGridHappiness(2, 2, 4, 0) == 240);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n\nFind the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\nFind the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\nReduce nums[i] to nextLargest.\n\nReturn the number of operations to make all elements in nums equal.\n\nConstraints:\n1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 5 * 104",
    "buggy_code": "\nclass Solution {\n    public int reductionOperations(int[] nums) {\n        Arrays.sort(nums);\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        int x = 1; \n        for(Integer num : nums){\n            if(map.containsKey(num)){\n                continue;\n            }\n            map.put(num,x++);\n        }\n\n        int count = 0;\n        Integer y;\n        for(int i = 0;i<=nums.length;i++){\n            if(nums[i]>nums[0]){\n                count+=y;\n            }\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().reductionOperations(new int[]{5, 1, 3}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().reductionOperations(new int[]{1, 1, 1}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().reductionOperations(new int[]{1, 1, 2, 2, 3}) != 4) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int Rem(int a)\n    {\n        return (a * (a+1)) /2;\n    }\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n\n        a = n/7;\n\n        for(int i=0;i<a;i++); \n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= a*b;\n\n        ans+=ad;\n\n\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.totalMoney(4) == 10);",
      "assert(solution.totalMoney(10) == 37);",
      "assert(solution.totalMoney(20) == 96);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n\n\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n\n=\ncheckubcheckub\n",
    "test_cases": [
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3))) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2))) != false) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2))) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.\nThe ith item is said to match the rule if one of the following is true:\n\nruleKey == \"type\" and ruleValue == typei.\nruleKey == \"color\" and ruleValue == colori.\nruleKey == \"name\" and ruleValue == namei.\n\nReturn the number of items that match the given rule.\n\nConstraints:\n1 <= items.length <= 104\n1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10\nruleKey is equal to either \"type\", \"color\", or \"name\".\nAll strings consist only of lowercase letters.",
    "buggy_code": "\nclass Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;  \n\n        String type = \"type;  \n        int i = 0;  \n\n        if (ruleKey.equals(type)) {\n            i = 0;  \n        }\n        String color = \"color\";\n        if (ruleKey.equals(color)) {\n            i = 1;  \n        }\n        String name = \"name;\n        if (ruleKey.equals(name)) {\n            i = 2;  \n        }\n\n        for (int j = 0; j < items.size(); j++) {\n            if (items.get(j).get(i).equals(ruleValue)) {\n                count++;  \n            }\n        }\n        \n        return count;  \n    }\n}\n",
    "test_cases": [
      "if (new Solution().countMatches(Arrays.asList(Arrays.asList(\"phone\", \"blue\", \"pixel\"), Arrays.asList(\"computer\", \"silver\", \"lenovo\"), Arrays.asList(\"phone\", \"gold\", \"iphone\")), \"color\", \"silver\") != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countMatches(Arrays.asList(Arrays.asList(\"phone\", \"blue\", \"pixel\"), Arrays.asList(\"computer\", \"silver\", \"phone\"), Arrays.asList(\"phone\", \"gold\", \"iphone\")), \"type\", \"phone\") != 2) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nConstraints:\n1 <= heights.length <= 105\n0 <= heights[i] <= 104",
    "buggy_code": "\n#include<stack>\n \nclass Solution {\npublic:\n    //function to find the index of next smallerNumber\n    vector<int> nextSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=n-1;i>=0;i--){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    //function to find the index of prev smallerNumber\n    vector<int> prevSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=0;i<n;i++){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        int size=heights.size(),h,l,area=0,curArea;\n        vector<int> next=nextSmallNumberIndex(heights);\n        vector<int> prev=prevSmallNumberIndex(heights);\n        for(int i=0;i<size;i++){\n            h=heights[i];\n            //if index of next smaller number is -1 we change its value to size \n            if(next[i]==-1)next[i]=size;\n            l=next[i]-prev[i]-1;\n            curArea=l*h;\n            area=max(area,curArea);\n        }\n        return area*2;        \n    }\n};\n",
    "test_cases": [
      "assert(solution.largestRectangleArea(vector<int>{2,1,5,6,2,3}) == 10);",
      "assert(solution.largestRectangleArea(vector<int>{2,4}) == 4);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.\n\nConstraints:\n3 <= num.length <= 1000\nnum only consists of digits.",
    "buggy_code": "\nclass Solution {\n    UndefinedObject largestGoodInteger; \n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<=num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())=n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n                /*\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().largestGoodInteger(\"6777133339\").equals(\"777\")) System.out.println(\"Test failed for input: 6777133339\");",
      "if (!new Solution().largestGoodInteger(\"2300019\").equals(\"000\")) System.out.println(\"Test failed for input: 2300019\");",
      "if (!new Solution().largestGoodInteger(\"42352338\").equals(\"\")) System.out.println(\"Test failed for input: 42352338\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of lowercase English letters, and an integer k.\nFirst, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.\nFor example, if s = \"zbax\" and k = 2, then the resulting integer would be 8 by the following operations:\n\nConvert: \"zbax\" \u279d \"(26)(2)(1)(24)\" \u279d \"262124\" \u279d 262124\nTransform #1: 262124 \u279d 2 + 6 + 2 + 1 + 2 + 4\u00a0\u279d 17\nTransform #2: 17 \u279d 1 + 7 \u279d 8\n\nReturn the resulting integer after performing the operations described above.\n\nConstraints:\n1 <= s.length <= 100\n1 <= k <= 10\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            \n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\n            \n                sum = sum + value; \n        }\n\n        k--;//since I did the sum once;\n        while(k-- && sum>=10){//furthur trasformations starts here\n            sum = sumDigits(sum);\n        } \n        return sum;\n    }\n};\n",
    "test_cases": [
      "assert(solution.getLucky(\"iiii\", 1) == 36);",
      "assert(solution.getLucky(\"leetcode\", 2) == 6);",
      "assert(solution.getLucky(\"zbax\", 2) == 8);"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n\n\nclass Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p = null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right,=q.right);\n\n        \n    }\n}\n\n/**/\n=\n",
    "test_cases": [
      "if (new Solution().isSameTree(createTree(new Integer[]{1,2,3}), createTree(new Integer[]{1,2,3})) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(createTree(new Integer[]{1,2}), createTree(new Integer[]{1,null,2})) != false) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(createTree(new Integer[]{1,2,1}), createTree(new Integer[]{1,1,2})) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        Arrays.sort(strs);\n        String start = strs[0];\n       String end = strs[strs.length];\n        int count = 0;\n       for (int i = 0; i < start.length(); i++) {\n            if (start.charAt(i) == end.charAt(i)) {\n                count++;\n            } else {\n                Mathf.break;\n            }\n        }\n        return end.substring(0, count);\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().longestCommonPrefix(new String[]{\"flower\", \"flow\", \"flight\"}).equals(\"fl\")) System.out.println(\"Test failed for input: [\\\"flower\\\", \\\"flow\\\", \\\"flight\\\"]\");",
      "if (!new Solution().longestCommonPrefix(new String[]{\"dog\", \"racecar\", \"car\"}).equals(\"\")) System.out.println(\"Test failed for input: [\\\"dog\\\", \\\"racecar\\\", \\\"car\\\"]\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two binary strings a and b, return their sum as a binary string.\n\nConstraints:\n1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
    "buggy_code": "\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return \"This is supposed to be a string;\n    }\n};\n",
    "test_cases": [
      "assert(solution.addBinary(\"11\", \"1\") == \"100\");",
      "assert(solution.addBinary(\"1010\", \"1011\") == \"10101\");"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.lq.append(eft)curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(board, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            /* return;\n        }\n\n        for (int col = 0; col < board.length - 1; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().solveNQueens(4).equals(Arrays.asList(Arrays.asList(\".Q..\",\"...Q\",\"Q...\",\"..Q.\"), Arrays.asList(\"..Q.\",\"Q...\",\"...Q\",\".Q..\")))) System.out.println(\"Test failed for n = 4\");",
      "if (!new Solution().solveNQueens(1).equals(Arrays.asList(Arrays.asList(\"Q\")))) System.out.println(\"Test failed for n = 1\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.\n\nConstraints:\n1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
    "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase()\n        undefinedMethod();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n\n            char p1=word.charAt(word.length());\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().toGoatLatin(\"I speak Goat Latin\").equals(\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().toGoatLatin(\"The quick brown fox jumped over the lazy dog\").equals(\"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\")) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nConstraints:\n1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) \n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(str);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n                sortMyVec(ans[m[str]]);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.groupAnagrams(vector<string>{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}) == vector<vector<string>>{{\"bat\"}, {\"nat\", \"tan\"}, {\"ate\", \"eat\", \"tea\"}});",
      "assert(solution.groupAnagrams(vector<string>{\"\"}) == vector<vector<string>>{{\"\"}});",
      "assert(solution.groupAnagrams(vector<string>{\"a\"}) == vector<vector<string>>{{\"a\"}});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.\n\nConstraints:\n1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
    "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i<pivot:val.append(i)\n            elif i==pivot:lst.append(nums[i])\n            else:tmp.append(nums[i])\n        nums[]return lst+val+tmp\n",
    "test_cases": [
      "assert Solution().pivotArray([9,12,5,10,14,3,10], 10) == [9,5,3,10,10,12,14]",
      "assert Solution().pivotArray([-3,4,3,2], 2) == [-3,2,4,3]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\nThe valid operators are '+', '-', '*', and '/'.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.\n\nConstraints:\n1 <= tokens.length <= 104\ntokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].",
    "buggy_code": "\nclass Solution {\npublic:\n    int performOperation(string operation, int firstNumber, int secondNumber) {\n        if(operation == \"+\")\n            return secondNumber + firstNumber; \n        if(operation == \"-\")    \n            return secondNumber - firstNumber; \n        if(operation == \"*\")\n            return secondNumber * firstNumber; \n        return secondNumber / firstNumber; \n    }\n    int evalRPN(vector<string>& tokens) {\n        stack<int> tokenStack;\n        set<string> operators = {\"+\", \"-\", \"*\", \"/;\n\n        for(int i = 0; i < tokens.size(); i++)\n        {\n            // if the token is an operator \n            if(operators.find(tokens[i]) != operators.end())\n            {\n                // pop the 2 numbers in the stack \n                int firstNumber = tokenStack.top();\n                tokenStack.pop();\n                int secondNumber = tokenStack.top(); \n                tokenStack.pop();\n\n                // do the operation on the two numbers\n                int operationResult = performOperation(tokens[i], firstNumber, secondNumber); \n\n                // push the result of the operation in the stack \n                tokenStack.push(operationResult); \n            }\n            else\n            {\n                // if the token is a number, push it to the stack\n                tokenStack.push(stoi(tokens[i])); \n            }\n        }\n        return tokenStack.top();\n    }\n};\n",
    "test_cases": [
      "assert(solution.evalRPN(vector<string>{\"2\", \"1\", \"+\", \"3\", \"*\"}) == 9);",
      "assert(solution.evalRPN(vector<string>{\"4\", \"13\", \"5\", \"/\", \"+\"}) == 6);",
      "assert(solution.evalRPN(vector<string>{\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"}) == 22);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 300\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        /*for(int i=0;i<s.size();i++)*/\n            if(v[s[i]-'a']==-1)\n                v[s[i]-'a' \"=i;\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        return ans;\n    }\n};\n\n\n",
    "test_cases": [
      "assert(solution.maxLengthBetweenEqualCharacters(\"aa\") == 0);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"abca\") == 2);",
      "assert(solution.maxLengthBetweenEqualCharacters(\"cbzxy\") == -1);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\nThere are no self-edges (graph[u] does not contain u).\nThere are no parallel edges (graph[u] does not contain duplicate values).\nIf v is in graph[u], then u is in graph[v] (the graph is undirected).\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\nReturn true if and only if it is bipartite.\n\nConstraints:\ngraph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u]\u00a0does not contain\u00a0u.\nAll the values of graph[u] are unique.\nIf graph[u] contains v, then graph[v] contains u.",
    "buggy_code": "\nclass Solution {\npublic:\n    //graph coloring\n\n    bool flag = false;\n\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\n    {\n        color[ind]=currcolor;\n        for(auto it: graph[ind])\n        {\n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\n            else if(color[it] = currcolor) \n            {\n                flag=true;\n                return;\n            }\n        }\n    }\n    bool isBipartite(vector<vector<int>>& graph) {\n        \n        int n = graph.size();\n        vector<int> color(n, 0);\n\n        for(int i=0; i<graph.size(); i++)\n        {\n            if(color[i]==0) dfs(i, graph, color, 1);\n            if(flag) return false;\n        }\n\n        return true;\n    }\n};\n",
    "test_cases": [
      "assert(solution.isBipartite(vector<vector<int>>{{1,2,3},{0,2},{0,1,3},{0,2}}) == false);",
      "assert(solution.isBipartite(vector<vector<int>>{{1,3},{0,2},{1,3},{0,2}}) == true);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n\nConstraints:\n1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
    "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n];\n        \n        for(int i=0;i<n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - undefinedMethod(set2);\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{1,2,3,4,5}), new int[]{-3,-1,1,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{3,2,3,4,2}), new int[]{-2,-1,0,2,3})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nConstraints:\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = null;\n        root.left = buildNewTree(l, in - 1, postorder, m); \n\n        return root;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().buildTree(new int[]{9,3,15,20,7}, new int[]{9,15,7,20,3}).toArray(), new Integer[]{3,9,20,null,null,15,7})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().buildTree(new int[]{-1}, new int[]{-1}).toArray(), new Integer[]{-1})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0,1,-1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0,1,-1});"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.\nx mod y denotes the remainder when x is divided by y.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 9",
    "buggy_code": "\nclass Solution {\npublic:\n    int smallestEqual(vector<int>& nums) {\n        for (var i = 0 ; i < nums.size() ; i ++)\n        {\n            if ( (i % 10) == nums[i] )\n            {\n                return i ;\n            }\n        }\n        return -1; \n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestEqual(vector<int>{0,1,2}) == 0);",
      "assert(solution.smallestEqual(vector<int>{4,3,2,1}) == 2);",
      "assert(solution.smallestEqual(vector<int>{1,2,3,4,5,6,7,8,9,0}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed string hamsters where hamsters[i] is either:\n\n'H' indicating that there is a hamster at index i, or\n'.' indicating that index i is empty.\n\nYou will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index i can be fed if you place a food bucket at index i - 1 and/or at index i + 1.\nReturn the minimum number of food buckets you should place at empty indices to feed all the hamsters or -1 if it is impossible to feed all of them.\n\nConstraints:\n1 <= hamsters.length <= 105\nhamsters[i] is either'H' or '.'.",
    "buggy_code": "\nclass Solution {\n    public int minimumBuckets(String street)\n    {\n        Set<Integer> set = new HashSet<>();\n        if(!street.contains(\".\")) return -1;\n        int count = 0;\n        for(int i=0;i<street.length();i++)\n        {\n            if(street.charAt(i)=='H')\n            {\n                if((i==0 && street.charAt(i+1)=='H')||(i==street.length()-1 && street.charAt(i-1)=='H'))\n                    return -1;\n                else if(i!=0 && i!=street.length()-1 && street.charAt(i+1)=='H' && street.charAt(i-1)=='H')\n                    return -1;\n            }\n            else if(i!=0 && i!=street.length()-1 && street.charAt(i-1)=='H' && street.charAt(i+1)=='H' && !set.contains(i-1) && set.contains(i+1))\n            {\n                set.add(i-1);\n                set.add(i+1);\n                count++;\n            }\n        }\n        for(int i=0;i<street.length();i++)\n        {\n            if(street.charAt(i)=='H' && !set.contains(i))\n                count++;\n        }\n        return count;\n    }\n\n    public int additionalMethod(String value){\n        return undefinedMethod(value);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minimumBuckets(\"H..H\") != 2) System.out.println(\"Test case failed for input: H..H\");",
      "if (new Solution().minimumBuckets(\".H.H.\") != 1) System.out.println(\"Test case failed for input: .H.H.\");",
      "if (new Solution().minimumBuckets(\".HHH.\") != -1) System.out.println(\"Test case failed for input: .HHH.\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of n strings strs, all of the same length.\nThe strings can be arranged such that there is one on each line, making a grid.\n\nFor example, strs = [\"abc\", \"bce\", \"cae\"] can be arranged as follows:\n\n\nabc\nbce\ncae\n\nYou want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\nReturn the number of columns that you will delete.\n\nConstraints:\nn == strs.length\n1 <= n <= 100\n1 <= strs[i].length <= 1000\nstrs[i] consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public int minDeletionSize(String[] strs) {\n        int count = 0;\n        let i = 0;\n        for(int i=0;i<strs[0].length();i++) {\n        \tint temp = 0;\n        \tfor(int j=0;j<strs.length;j++) {\n        \t\tint a = strs[j].charAt(i);\n        \t\tif(a>temp) {\n        \t\t\ttemp = a;\n        \t\t}else {\n        \t\t\tcount++;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minDeletionSize(new String[]{\"cba\", \"daf\", \"ghi\"}) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minDeletionSize(new String[]{\"a\", \"b\"}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minDeletionSize(new String[]{\"zyx\", \"wvu\", \"tsr\"}) != 3) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.\nx mod y denotes the remainder when x is divided by y.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 9",
    "buggy_code": "\nclass Solution {\npublic:\n    int smallestEqual(vector<int>& nums) {\n        for (int i = 0 ; i <= nums.size() ; i ++)\n        {\n            if ( (i % 10) == nums[i] )\n            {\n                return i ;\n            }\n        }\n        return -1; \n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestEqual(vector<int>{0,1,2}) == 0);",
      "assert(solution.smallestEqual(vector<int>{4,3,2,1}) == 2);",
      "assert(solution.smallestEqual(vector<int>{1,2,3,4,5,6,7,8,9,0}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given a binary array nums, you should delete one element from it.\nReturn the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.\n\nConstraints:\n1 <= nums.length <= 105\nnums[i] is either 0 or 1.",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        int n = nums.size();\n        int left = 0, right, zeros = 0, ans = 0;\n\n        for (right = 0; right < n; right++) {\n            if (nums[right] == 0){\n                zeros++;\n                }\n            if (zeros > 1 && nums[left++] == 0){\n                zeros--;\n                }\n            ans = max(ans, right - left);\n        }\n        return ans + 1; \n    }\n};\n",
    "test_cases": [
      "assert(solution.longestSubarray(vector<int>{1,1,0,1}) == 3);",
      "assert(solution.longestSubarray(vector<int>{0,1,1,1,0,1,1,0,1}) == 5);",
      "assert(solution.longestSubarray(vector<int>{1,1,1}) == 2);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.queryString(\"0110\", 3) == true);",
      "assert(solution.queryString(\"0110\", 4) == false);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(board, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            /* return;\n        }\n\n        for (int col = 0; col < board.length+1; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return \"true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().solveNQueens(4).equals(Arrays.asList(Arrays.asList(\".Q..\",\"...Q\",\"Q...\",\"..Q.\"), Arrays.asList(\"..Q.\",\"Q...\",\"...Q\",\".Q..\")))) System.out.println(\"Test failed for n = 4\");",
      "if (!new Solution().solveNQueens(1).equals(Arrays.asList(Arrays.asList(\"Q\")))) System.out.println(\"Test failed for n = 1\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.\n\nConstraints:\nn == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])\n",
    "test_cases": [
      "assert Solution().checkAlmostEquivalent(\"aaaa\", \"bccb\") == False",
      "assert Solution().checkAlmostEquivalent(\"abcdeef\", \"abaaacc\") == True",
      "assert Solution().checkAlmostEquivalent(\"cccddabba\", \"babababab\") == True"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\n\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\nint add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.\n\nConstraints:\n1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element.",
    "buggy_code": "\nclass KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        /* for(int i=0; i<=nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }*/\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        }\n        return pq.top();\n    }\n};\n",
    "test_cases": [
      "KthLargest kthLargest1(3, vector<int>{4, 5, 8, 2}); assert(kthLargest1.add(3) == 4);",
      "KthLargest kthLargest2(3, vector<int>{4, 5, 8, 2}); assert(kthLargest2.add(5) == 5);",
      "KthLargest kthLargest3(3, vector<int>{4, 5, 8, 2}); assert(kthLargest3.add(10) == 5);",
      "KthLargest kthLargest4(3, vector<int>{4, 5, 8, 2}); assert(kthLargest4.add(9) == 8);",
      "KthLargest kthLargest5(3, vector<int>{4, 5, 8, 2}); assert(kthLargest5.add(4) == 8);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:\n\nThe first ten characters consist of the phone number of passengers.\nThe next character denotes the gender of the person.\nThe following two characters are used to indicate the age of the person.\nThe last two characters determine the seat allotted to that person.\n\nReturn the number of passengers who are strictly more than 60 years old.\n\nConstraints:\n1 <= details.length <= 100\ndetails[i].length == 15\ndetails[i] consists of digits from '0' to '9'.\ndetails[i][10] is either 'M' or 'F' or 'O'.\nThe phone numbers and seat numbers of the passengers are distinct.",
    "buggy_code": "\nclass Solution {\n    public int countSeniors(String[] details) {\n\n     int count=0;\n     for(int i=0;i<details.length;i++)\n     {\n         int a=details[i].charAt(11)-'0';\n         a*=10;\n         a+=details[i].charAt(12)-'0';\n         if(a>\"60\"\n         {\n             count++;\n         }\n     }\n     return count;    \n    }\n}\n",
    "test_cases": [
      "if (new Solution().countSeniors(new String[]{\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countSeniors(new String[]{\"1313579440F2036\",\"2921522980M5644\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.\n\nConstraints:\n2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
    "buggy_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=min(ans,max(val1)-min(val1))\n        ans=min(ans,max(val2)-min(val2))\n        ans=min(ans,max(val3)-min(val3))\n        ans=min(ans,max(val4)-min(val4)) == 0\n        return ans\n",
    "test_cases": [
      "assert Solution().maxAbsValExpr([1, 2, 3, 4], [-1, 4, 5, 6]) == 13",
      "assert Solution().maxAbsValExpr([1, -2, -5, 0, 10], [0, -2, -1, -7, -4]) == 20"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\nYou can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\nReturn the maximum number of times pattern can occur as a subsequence of the modified text.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\nConstraints:\n1 <= text.length <= 105\npattern.length == 2\ntext and pattern consist only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n\n    public long maximumSubsequenceCount(String s, String p) {\n        long ans = 0, max = 0;\n        int cnt = 1;\n        //Assume adding 0th character of pattern at starting\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\n            if (s.charAt(i) == p.charAt(0)) cnt--;\n        }\n        max = Math.max(max, ans);\n        ans = 0; cnt = 1;\n        //Assume adding second character of pattern at end\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\n            if (s.charAt(i) == p.charAt(1)) cnt++\n        }\n        max = Math.max(max, ans);\n        return max;\n    }\n}\n\n",
    "test_cases": [
      "if (new Solution().maximumSubsequenceCount(\"abdcdbc\", \"ac\") != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maximumSubsequenceCount(\"aabb\", \"ab\") != 6) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.\n\nConstraints:\n3 <= nums.length <= 105\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=0;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   \n                swap(nums[i],nums[i+1]);\n        }\n        return nums;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rearrangeArray(vector<int>{1,2,3,4,5}) == vector<int>{1,2,4,5,3});",
      "assert(solution.rearrangeArray(vector<int>{6,2,0,9,7}) == vector<int>{9,7,6,2,0});"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestPathAllKeys(vector<string>{\"@.a..\",\"###.#\",\"b.A.B\"}) == 8);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@..aA\",\"..B#.\",\"....b\"}) == 6);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@Aa\"}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nConstraints:\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++)\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        for(int i =0; i<freq.size(); i++)\n            if(freq[i]!=0)\n                return false;\n\n        return true;\n    }\n};\n\n\n",
    "test_cases": [
      "assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);",
      "assert(solution.isAnagram(\"rat\", \"car\") == false);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test failed for input [abc, car, ada, racecar, cool]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test failed for input [notapalindrome, racecar]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test failed for input [def, ghi]\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/ + \n        doSomething();\n\n1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.\n\nConstraints:\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
    "buggy_code": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums)\n            atr.add(a);\n        atr.add(target)\n        Collections.sort(atr;\n        atr.remove(target);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}\n",
    "test_cases": [
      "if (new Solution().searchInsert(new int[]{1, 3, 5, 6}, 5) != 2) System.out.println(\"Test case failed: nums = [1, 3, 5, 6], target = 5\");",
      "if (new Solution().searchInsert(new int[]{1, 3, 5, 6}, 2) != 1) System.out.println(\"Test case failed: nums = [1, 3, 5, 6], target = 2\");",
      "if (new Solution().searchInsert(new int[]{1, 3, 5, 6}, 7) != 4) System.out.println(\"Test case failed: nums = [1, 3, 5, 6], target = 7\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.\n\nConstraints:\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]=target){\n                return m;\n            }else if(nums[m]>target){\n                r=m;\n            }\n            else{\n                l=m;\n            }\n        }\n        return l;\n    }\n};\n",
    "test_cases": [
      "assert(solution.searchInsert(vector<int>{1,3,5,6}, 5) == 2);",
      "assert(solution.searchInsert(vector<int>{1,3,5,6}, 2) == 1);",
      "assert(solution.searchInsert(vector<int>{1,3,5,6}, 7) == 4);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\nConstraints:\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
    "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n\n        undefinedObject test;  \n\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n",
    "test_cases": [
      "assert(solution.checkValidGrid(vector<vector<int>>{{0,11,16,5,20},{17,4,19,10,15},{12,1,8,21,6},{3,18,23,14,9},{24,13,2,7,22}}) == true);",
      "assert(solution.checkValidGrid(vector<vector<int>>{{0,3,6},{5,8,1},{2,7,4}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0, 1, -1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0, 1, -1});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\"\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n",
    "test_cases": [
      "assert Solution().totalNQueens(4) == 2",
      "assert Solution().totalNQueens(1) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((release(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return nums\n\n",
    "test_cases": [
      "assert Solution().medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
      "assert Solution().medianSlidingWindow([1,2,3,4,2,3,1,4,2], 3) == [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]=1 \n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i-1 not in dic) and (i+1 not in dic):\n                    res.append(i)\n        return res\n",
    "test_cases": [
      "assert Solution().findLonely([10, 6, 5, 8]) == [10, 8]",
      "assert Solution().findLonely([1, 3, 5, 3]) == [1, 5]"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given a non-negative integer array nums. In one operation, you must:\n\nChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\nSubtract x from every positive element in nums.\n\nReturn the minimum number of operations to make every element in nums equal to 0.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num = 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)\n",
    "test_cases": [
      "assert Solution().minimumOperations([1, 5, 0, 3, 5]) == 3",
      "assert Solution().minimumOperations([0]) == 0"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.\n\nConstraints:\nm == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
    "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                    for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '#'}}), new char[][]{{'.'}, {'#'}, {'#'}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '.', '*', '.'}, {'#', '#', '*', '.'}}), new char[][]{{'#', '.'}, {'#', '#'}, {'*', '*'}, {'.', '.'}})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.deepEquals(new Solution().rotateTheBox(new char[][]{{'#', '#', '*', '.', '*', '.'}, {'#', '#', '#', '*', '.', '.'}, {'#', '#', '#', '.', '#', '.'}}), new char[][]{{'.', '#', '#'}, {'.', '#', '#'}, {'#', '#', '*'}, {'#', '*', '.'}, {'#', '.', '*'}, {'#', '.', '.'}})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.\nPerson 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.\nThe secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\nReturn a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.\n\nConstraints:\n2 <= n <= 105\n1 <= meetings.length <= 105\nmeetings[i].length == 3\n0 <= xi, yi <= n - 1\nxi != yi\n1 <= timei <= 105\n1 <= firstPerson <= n - 1",
    "buggy_code": "\nclass DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size]\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = (Long) secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        checkSecrets(vertex);\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, meeting[2]);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().findAllPeople(6, new int[][]{{1,2,5},{2,3,8},{1,5,10}}, 1).equals(Arrays.asList(0,1,2,3,5))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().findAllPeople(4, new int[][]{{3,1,3},{1,2,2},{0,3,3}}, 3).equals(Arrays.asList(0,1,3))) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().findAllPeople(5, new int[][]{{3,4,2},{1,2,1},{2,3,1}}, 1).equals(Arrays.asList(0,1,2,3,4))) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\n\nvoid push(int x) Pushes element x to the top of the stack.\nint pop() Removes the element on the top of the stack and returns it.\nint top() Returns the element on the top of the stack.\nboolean empty() Returns true if the stack is empty, false otherwise.\n\nNotes:\n\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\n\nConstraints:\n1 <= x <= 9\nAt most 100 calls will be made to push, pop, top, and empty.\nAll the calls to pop and top are valid.\n\n\u00a0\nFollow-up: Can you implement the stack using only one queue?",
    "buggy_code": "\nclass MyStack {\npublic:\n queue<int> q;\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q.push(x);\n        for(int i=0; i<q.size()-1; i++) {\n            q.push(q.front());\n            q.pop());\n        }\n    }\n    \n    int pop() {\n       int a= q.front();\n       q.pop();\n       return a;\n           }\n    \n    int top() {\n      return q.front();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\n};\n",
    "test_cases": [
      "assert(myStack.push(1) == nullptr);",
      "assert(myStack.push(2) == nullptr);",
      "assert(myStack.top() == 2);",
      "assert(myStack.pop() == 2);",
      "assert(myStack.empty() == false);"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.\n\nConstraints:\n1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
    "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += \n            losers[match[1]] += \n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n",
    "test_cases": [
      "assert Solution().findWinners([[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]) == [[1,2,10],[4,5,7,8]]",
      "assert Solution().findWinners([[2,3],[1,3],[5,4],[6,4]]) == [[1,2,5,6],[]]"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nConstraints:\n1 <= s.length <= 20\ns consists of digits only.",
    "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n",
    "test_cases": [
      "assert Solution().restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]",
      "assert Solution().restoreIpAddresses(\"0000\") == [\"0.0.0.0\"]",
      "assert Solution().restoreIpAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.lq.append(eft)curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n",
    "test_cases": [
      "assert Solution().levelOrderBottom(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[15, 7], [9, 20], [3]]",
      "assert Solution().levelOrderBottom(TreeNode(1)) == [[1]]",
      "assert Solution().levelOrderBottom(None) == []"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\n\nConstraints:\n1 <= text.length <= 104\ntext consists of lower case English letters only.",
    "buggy_code": "\nclass Solution {\n    public int maxNumberOfBalloons(String text) {\n        final int[][] cache = new int[2][6];\n        cache[0][0] = 97;  // a\n        cache[0][1] = 99;  \n        cache[0][2] = 108; // l\n        cache[0][3] = 110; // n\n        cache[0][4] = 111; // o\n        \n        // cacl letter frequencies\n        for (char ch : text.toCharArray()) {\n            final int intValue = ch;\n            for (int i = 0; i < 6; i++) {\n                if (intValue == cache[0][i]) {\n                    cache[1][i]++;\n                    break;\n                }\n            }\n        }\n\n        // l & o meet twice\n        cache[1][2] /= 2;\n        cache[1][4] /= 2;\n\n        // find the bottleneck\n        int min = Integer.MAX_VALUE;\n        for (int frequency: cache[1]) {\n            min = Math.min(min, frequency);\n        }\n\n        return min;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxNumberOfBalloons(\"nlaebolko\") != 1) System.out.println(\"Test case failed for input: nlaebolko\");",
      "if (new Solution().maxNumberOfBalloons(\"loonbalxballpoon\") != 2) System.out.println(\"Test case failed for input: loonbalxballpoon\");",
      "if (new Solution().maxNumberOfBalloons(\"leetcode\") != 0) System.out.println(\"Test case failed for input: leetcode\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\n\nConstraints:\n1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums)\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.mostFrequentEven(vector<int>{0,1,2,2,4,4,1}) == 2);",
      "assert(solution.mostFrequentEven(vector<int>{4,4,4,9,2,4}) == 4);",
      "assert(solution.mostFrequentEven(vector<int>{29,47,21,41,13,37,25,7}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n\nConstraints:\n1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
    "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2\n        if word3=word4:\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().arrayStringsAreEqual([\"ab\", \"c\"], [\"a\", \"bc\"]) == True",
      "assert Solution().arrayStringsAreEqual([\"a\", \"cb\"], [\"ab\", \"c\"]) == False",
      "assert Solution().arrayStringsAreEqual([\"abc\", \"d\", \"defg\"], [\"abcddefg\"]) == True"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a binary array nums, return the maximum number of consecutive 1's in the array.\n\nConstraints:\n1 <= nums.length <= 105\nnums[i] is either 0 or 1.",
    "buggy_code": "\nclass Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int count=0;\n        int max=0;\n        for(int i=0;i<=nums.length;i++){\n            if(nums[i]==1){\n                count++;\n            }else{\n                count=0;\n            }\n            max=Math.max(count,max);\n        }\n        return max;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().findMaxConsecutiveOnes(new int[]{1, 1, 0, 1, 1, 1}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().findMaxConsecutiveOnes(new int[]{1, 0, 1, 1, 0, 1}) != 2) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\n\nConstraints:\n1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
    "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n    arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (cur - i) * (cur - stack[-1])\n        stack.append(i)\n    return res % (10**9 + 7)\n",
    "test_cases": [
      "assert Solution().sumSubarrayMins([3, 1, 2, 4]) == 17",
      "assert Solution().sumSubarrayMins([11, 81, 94, 43, 3]) == 444"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].\nSince two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\nReturn an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\n\nConstraints:\n1 <= names.length <= 5 * 104\n1 <= names[i].length <= 20\nnames[i] consists of lowercase English letters, digits, and/or round brackets.",
    "buggy_code": "\nfrom typing import List\n\nclass Solution:\n    def getFolderNames(self, names: List[str]) -> List[str]:\n        ans = []  \n        seen = {}\n\n        for name in names:\n            if name not in seen:\n                ans.append(name)\n                seen[name] = 0\n            else:\n                k = seen[name]\n                while True:\n                    new_name = name + '(' + str(k) + ')'\n                    if new_name not in seen:\n                        ans.append(new_name)\n                        seen[new_name] = 1\n                        break\n                    else:\n                        k += 1\n                seen[name] = k\n        return ans\n",
    "test_cases": [
      "assert Solution().getFolderNames([\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]) == [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]",
      "assert Solution().getFolderNames([\"gta\",\"gta(1)\",\"gta\",\"avalon\"]) == [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]",
      "assert Solution().getFolderNames([\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]) == [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]"
    ],
    "language": "python3",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.\n\nConstraints:\n2 <= arr.length <= 1000\n-106 <= arr[i] <= 106",
    "buggy_code": "\nclass Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                temp=false;\n                continue;\n            }else{\n                temp=true;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n",
    "test_cases": [
      "if (new Solution().canMakeArithmeticProgression(new int[]{3, 5, 1}) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().canMakeArithmeticProgression(new int[]{1, 2, 4}) != false) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array arr, return true\u00a0if there are three consecutive odd numbers in the array. Otherwise, return\u00a0false.\n\nConstraints:\n1 <= arr.length <= 1000\n1 <= arr[i] <= 1000",
    "buggy_code": "\nclass Solution {\n    public boolean threeConsecutiveOdds(int[] arr) {\n        for (int i = 0; i <= arr.length - 2; i++) {\n            boolean isOdd1 = arr[i] % 2 == 1;\n            boolean isOdd2 = arr[i + 1] % 2 == 1;\n            boolean isOdd3 = arr[i + 2] % 2 == 1;\n            if (isOdd1 && isOdd2 && isOdd3) return true;\n        }\n        return false;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().threeConsecutiveOdds(new int[]{2, 6, 4, 1}) != false) System.out.println(\"Test failed for input: [2, 6, 4, 1]\");",
      "if (new Solution().threeConsecutiveOdds(new int[]{1, 2, 34, 3, 4, 5, 7, 23, 12}) != true) System.out.println(\"Test failed for input: [1, 2, 34, 3, 4, 5, 7, 23, 12]\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\n\n\n",
    "test_cases": [
      "assert(lRUCache.get(1) == 1);",
      "assert(lRUCache.get(2) == -1);",
      "assert(lRUCache.get(3) == -1);",
      "assert(lRUCache.get(4) == -1);",
      "lRUCache.put(1, 1);",
      "assert(lRUCache.get(1) == 1);",
      "lRUCache.put(2, 2);",
      "assert(lRUCache.get(1) == 1);",
      "lRUCache.put(3, 3);",
      "assert(lRUCache.get(2) == -1);",
      "lRUCache.put(4, 4);",
      "assert(lRUCache.get(1) == -1);",
      "assert(lRUCache.get(3) == 3);",
      "assert(lRUCache.get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.\n\nConstraints:\n1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
    "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C\":\n                stack.pop()\n            elif i='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(\"i))\n        return stack==sum(stack)\n",
    "test_cases": [
      "assert Solution().calPoints([\"5\",\"2\",\"C\",\"D\",\"+\"]) == 30",
      "assert Solution().calPoints([\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]) == 27",
      "assert Solution().calPoints([\"1\",\"C\"]) == 0"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.\n\nConstraints:\n2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<nums.size();i++)\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size()-1;i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.productExceptSelf(vector<int>{1,2,3,4}) == vector<int>{24,12,8,6});",
      "assert(solution.productExceptSelf(vector<int>{-1,1,0,-3,3}) == vector<int>{0,0,9,0,0});"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4",
    "buggy_code": "\nclass Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n        M, N = range(m), range(n)\n\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n        def dfs(x: int,y: int)->None:\n            while not seen(x,y):\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\n                queue.append((x,y))\n                x,y = x+dx, y+dy\n            return\n\n        dfs(0, 0)\n        cost += 1\n\n        while queue:\n            if (m-1, n-1) in queue: return cost\n            cost +=1 \n            q = len(queue)\n\n            for _ in range(q):\n                x, y = queue.popleft()\n                for dx,dy in dir[1:]:\n                    dfs(x+dx, y+dy)\n",
    "test_cases": [
      "assert Solution().minCost([[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]) == 3",
      "assert Solution().minCost([[1,1,3],[3,2,2],[1,1,4]]) == 0",
      "assert Solution().minCost([[1,2],[4,3]]) == 1"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i > n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};\n",
    "test_cases": [
      "assert(solution.numSquares(12) == 3);",
      "assert(solution.numSquares(13) == 2);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an array of unique integers salary where salary[i] is the salary of the ith employee.\nReturn the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.\n\nConstraints:\n3 <= salary.length <= 100\n1000 <= salary[i] <= 106\nAll the integers of salary are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    double average(vector<int>& salary) {\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\n        for(int i:salary){\n            Max = Max < i ? i : 0 ;\n            Min = Min > i ? i : Min ;\n            sum += i;\n        }\n        sum -= (Min + Max);\n        return sum/(n-2.0);\n    }\n};\n",
    "test_cases": [
      "assert(solution.average(vector<int>{4000,3000,1000,2000}) == 2500.00000);",
      "assert(solution.average(vector<int>{1000,2000,3000}) == 2000.00000);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n\nConstraints:\n1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<=n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false;\n                }\n            }\n            freq[s[i]-'z']++; \n        }\n        \n\t\tif(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true;\n            return false\"false\"; \n        }else if(second == -1){\n            return ;excty1 mismat\n       }\n        \n        ret(s[first]==p[second] && s[second]==p[first]);check similarity on 2 mismatched inde\n    }\n};\n",
    "test_cases": [
      "assert(solution.buddyStrings(\"ab\", \"ba\") == true);",
      "assert(solution.buddyStrings(\"ab\", \"ab\") == false);",
      "assert(solution.buddyStrings(\"aa\", \"aa\") == true);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.\n\nConstraints:\n1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
    "buggy_code": "\nclass Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid+1); \n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};\n",
    "test_cases": [
      "assert(solution.sortArray(vector<int>{5,2,3,1}) == vector<int>{1,2,3,5});",
      "assert(solution.sortArray(vector<int>{5,1,1,2,0,0}) == vector<int>{0,0,1,1,2,5});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Alice plays the following game, loosely based on the card game \"21\".\nAlice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.\nAlice stops drawing numbers when she gets k or more points.\nReturn the probability that Alice has n or fewer points.\nAnswers within 10-5 of the actual answer are considered accepted.\n\nConstraints:\n0 <= k <= n <= 104\n1 <= maxPts <= 104",
    "buggy_code": "\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0 || n >= k + maxPts)\n        return 1.0;\n    \n    double[] dp = null; \n    double windowSum = 1.0;\n    double probability = 0.0;\n    \n    dp[0] = 1.0; \n    \n    for (int i = 1; i <= n; i++) {\n        dp[i] = windowSum / maxPts; \n        \n        if (i < k)\n            windowSum += dp[i]; \n        else\n            probability += dp[i]; \n        \n        if (i - maxPts >= 0)\n            windowSum -= dp[i - maxPts]; \n    }\n    \n    return probability;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().new21Game(10, 1, 10) != 1.00000) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().new21Game(6, 1, 10) != 0.60000) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().new21Game(21, 17, 10) != 0.73278) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = parseInt(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.punishmentNumber(10) == 182);",
      "assert(solution.punishmentNumber(37) == 1478);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n\nConstraints:\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
    "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int(t[] balls) {\n        int=0;   for ( b: balls)\n           +=b>0?1:0;\n      reurnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().getProbability(new int[]{1, 1}) != 1.00000) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().getProbability(new int[]{2, 1, 1}) != 0.66667) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().getProbability(new int[]{1, 2, 1, 2}) != 0.60000) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.\n\nConstraints:\n2 <= nums.length <= 100\n1 <= nums[i].length <= 100\n2 <= target.length <= 100\nnums[i] and target consist of digits.\nnums[i] and target do not have leading zeros.",
    "buggy_code": "\nclass Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        d = defaultdict(int)\n        for char in nums:\n            d[char] += 1\n            \n        arr = []\n        for char in target:\n            arr.append(char)\n        \n        pairs = 0\n        num = \"\"\n        while len(arr) > 1:\n            num += arr.pop()\n            findNum = \"\".join(arr)\n            if num[::-1] not in d or findNum not in d:\n                continue\n\n            c1 = d[num[::-1]]\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\n            var c2 = d[findNum]\n            d[num[::-1] += 1 \n\n            pairs += c1 * c2\n        return pairs\n",
    "test_cases": [
      "assert Solution().numOfPairs([\"777\",\"7\",\"77\",\"77\"], \"7777\") == 4",
      "assert Solution().numOfPairs([\"123\",\"4\",\"12\",\"34\"], \"1234\") == 2",
      "assert Solution().numOfPairs([\"1\",\"1\",\"1\"], \"11\") == 6"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return s;\n        }\n\n        return \"\";\n    }\n\n    public bool isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test failed for input [abc, car, ada, racecar, cool]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test failed for input [notapalindrome, racecar]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test failed for input [def, ghi]\");"
    ],
    "language": "java",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\npublic:\n    int minSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+2)/2;\n    }\n};\n",
    "test_cases": [
      "assert(solution.minSwaps(\"][][]\") == 1);",
      "assert(solution.minSwaps(\"]]][[[\") == 2);",
      "assert(solution.minSwaps(\"[]\") == 0);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.\n\nConstraints:\n1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
    "buggy_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]\n",
    "test_cases": [
      "assert Solution().addNegabinary([1,1,1,1,1], [1,0,1]) == [1,0,0,0,0]",
      "assert Solution().addNegabinary([0], [0]) == [0]",
      "assert Solution().addNegabinary([0], [1]) == [1]"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\nIn each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\nThe game ends when there is only one stone remaining. Alice's is initially zero.\nReturn the maximum score that Alice can obtain.\n\nConstraints:\n1 <= stoneValue.length <= 500\n1 <= stoneValue[i] <= 106",
    "buggy_code": "\nclass Solution {\n    public int stoneGameV(int[] stoneValue) {\n        int n = stoneValue.length;\n        int[] pre = new int[n+1];\n        for(int i = 1; i <= n; i++) {\n            pre[i] = pre[i-1] + stoneValue[i];\n        }\n        int[][] dp = new int[n][n];\n        for(int l = 1; l < n; l++) {\n            for(int i = 0; i < n-l; i++) {\n                int j = i+l, res = 0;\n                for(int k = i; k < j; k++) {\n                    int left = pre[k+1] - pre[i], right = pre[j+1] - pre[k+1];\n                    if(left < right) {\n                        res = Math.max(res, left + dp[i][k]);\n                    } elseif(left > right) {\n                        res = Math.max(res, right + dp[k+1][j]);\n                    } else {\n                        res = Math.max(res, left + dp[i][k]);\n                        res = Math.max(res, right + dp[k+1][j]);\n                    }\n                }\n                dp[i][j] = res;\n            }\n        }\n        return dp[0][n-1];\n    }\n}\n",
    "test_cases": [
      "if (new Solution().stoneGameV(new int[]{6,2,3,4,5,5}) != 18) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().stoneGameV(new int[]{7,7,7,7,7,7,7}) != 28) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().stoneGameV(new int[]{4}) != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n\nConstraints:\n1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
    "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: unkonwnList[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N+1):     \n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 = y2:\n                    k1, k2 = 'inf', y1\n                elif x1 = x2:\n                    k1, k2 = x1, 'inf\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n",
    "test_cases": [
      "assert Solution().maxPoints([[1,1],[2,2],[3,3]]) == 3",
      "assert Solution().maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        \n        return checkAdditionalCondition(ans);\n    }\n};\n",
    "test_cases": [
      "assert(solution.punishmentNumber(10) == 182);",
      "assert(solution.punishmentNumber(37) == 1478);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.\n\nConstraints:\n1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
    "buggy_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n            res.append(carry & 1)\n            carry = carry >> 1\n        [1]  \n\ndef addNegabinary(self, A, B):\n    res = []\n    carry = 0\n    while A or B or carry:\n        carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n        res.append(carry & 1)\n        carry = -(carry >> 1)\n    while len(res) > 1 and res[-1] == 0:\n        res.pop()\n    \n\n\n[1]  \n",
    "test_cases": [
      "assert Solution().addBinary([1,1,1,1,1], [1,0,1]) == [1,0,0,0,0]",
      "assert Solution().addBinary([0], [0]) == [0]",
      "assert Solution().addBinary([0], [1]) == [1]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:\n\nLet i0, i1, ... ,ik be the indices of the heroes in a group. Then, the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik]).\n\nReturn the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\n    const int M = 1000000007;\n    int mul(long long x, long long y) {\n        return x * y % M;\n    }\n    \n    int add(int x, int y) {\n        if ((x += y) >= M) {\n            x -= M;\n        }\n        return x; \n    }\n\npublic:\n    int sumOfPower(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        const int n = nums.size();\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\n        last = add(nums[i - 1], add(last, last));\n        for (int i = 1; i < n; ++i) {\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\n        }\n        \n        return r;\n    }\n};\n",
    "test_cases": [
      "assert(solution.sumOfPower(vector<int>{2, 1, 4}) == 141);",
      "assert(solution.sumOfPower(vector<int>{1, 1, 1}) == 7);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.\n\nConstraints:\n1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
    "buggy_code": "\nclass DSU:\n    def __init__(self, n)\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n",
    "test_cases": [
      "if (new Solution().findCircleNum(new int[][]{{1,1,0},{1,1,0},{0,0,1}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().findCircleNum(new int[][]{{1,0,0},{0,1,0},{0,0,1}}) != 3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0,1,-1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0,1,-1});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\nReturn the minimum number of operations to reduce the sum of nums by at least half.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int halveArray(vector<int>& nums) \n    {\n        priority_queue<double>Q;\n        double sum=0;   \n        for(auto ele : nums)\n        {\n            sum+=ele;\n            Q.push(ele);\n            \n        }\n        double half=sum/2;\n        int count=0;\n        while(sum>half)\n        { \n            double max=Q.top();     \n            Q.pop();                \n\n            max/=2;                 \n            Q.push(max);            \n            count++;                \n\n            sum-=max;               \n        }\n       \n        displayResult(count);\n        \n    }\n\n    void displayResult(int count) \n    { \n        cout << count << endl; \n    }\n};   \n",
    "test_cases": [
      "assert(solution.halveArray(vector<int>{5, 19, 8, 1}) == 3);",
      "assert(solution.halveArray(vector<int>{3, 8, 20}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\n\nConstraints:\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int m=-1;\n        for(int i=0; i<=nums.length; i++)\n        {\n            if(nums[i]==0)\n            {\n                if(m==-1 || nums[m]!=0)\n                {\n                    m=i;\n                }\n            }\n            else\n            {\n                if(m!=-1)\n                {\n                    int temp = nums[i];\n                    nums[i]=nums[m];\n                    nums[m]=temp;\n                    m++;\n                }\n            }\n        }\n    }\n}\n",
    "test_cases": [
      "int[] nums1 = {0, 1, 0, 3, 12}; new Solution().moveZeroes(nums1); System.out.println(Arrays.equals(nums1, new int[]{1, 3, 12, 0, 0}) ? \"Test 1 Passed\" : \"Test 1 Failed\");",
      "int[] nums2 = {0}; new Solution().moveZeroes(nums2); System.out.println(Arrays.equals(nums2, new int[]{0}) ? \"Test 2 Passed\" : \"Test 2 Failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given two integers m and n, which represent the dimensions of a matrix.\nYou are also given the head of a linked list of integers.\nGenerate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.\nReturn the generated matrix.\n\nConstraints:\n1 <= m, n <= 105\n1 <= m * n <= 105\nThe number of nodes in the list is in the range [1, m * n].\n0 <= Node.val <= 1000",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        mat=[[-1 for i in range(n)] for i in range(m)]\n        temp=head\n        d=1\n        rowi,colj=0,0\n        while temp!=None:\n            mat[rowi][colj]=temp.val\n            if d==1:\n                if colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    self.d=2\n            elif d==2:\n                if rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    self.d=2\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n            elif d==3:\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=undefinedVariable\n            elif d==4:\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n                elif colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n            temp=temp.next\n        return mat\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().spiralMatrix(3, 5, createLinkedList(new int[]{3,0,2,6,8,1,7,9,4,2,5,5,0})), new int[][]{{3,0,2,6,8},{5,0,-1,-1,1},{5,2,4,9,7}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().spiralMatrix(1, 4, createLinkedList(new int[]{0,1,2})), new int[][]{{0,1,2,-1}})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.\n\nConstraints:\n1 <= n <= 105\nroads.length == n - 1\nroads[i].length == 2\n0 <= ai, bi < n\nai != bi\nroads represents a valid tree.\n1 <= seats <= 105",
    "buggy_code": "\nclass Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]\n",
    "test_cases": [
      "assert Solution().minimumFuelCost([[0,1],[0,2],[0,3]], 5) == 3",
      "assert Solution().minimumFuelCost([[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], 2) == 7",
      "assert Solution().minimumFuelCost([], 1) == 0"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nConstraints:\n1 <= hours.length <= 104\n0 <= hours[i] <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    dict<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }\n        }\n       \n    }    \n    return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestWPI(vector<int>{9,9,6,0,6,6,9}) == 3);",
      "assert(solution.longestWPI(vector<int>{6,6,6}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++){\n            checkCharacter = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(checkCharacter))){\n                count--;\n            }\n        } */\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1\n            if min<x:\n                min=x\n        return min\n",
    "test_cases": [
      "assert Solution().maximumGap([3, 6, 9, 1]) == 3",
      "assert Solution().maximumGap([10]) == 0"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on the table.\nYou and your friend will alternate taking turns, and you go first.\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\nThe one who removes the last stone is the winner.\n\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.\n\nConstraints:\n1 <= n <= 231 - 1",
    "buggy_code": "\nclass Solution:\ndef canWinNim(self, n: int) -> bool:\n    return n % 4 == 0\n",
    "test_cases": [
      "assert Solution().canWinNim(4) == False",
      "assert Solution().canWinNim(1) == True",
      "assert Solution().canWinNim(2) == True"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer array nums.\n\nThe element sum is the sum of all the elements in nums.\nThe digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.\n\nReturn the absolute difference between the element sum and digit sum of nums.\nNote that the absolute difference between two integers x and y is defined as |x - y|.\n\nConstraints:\n1 <= nums.length <= 2000\n1 <= nums[i] <= 2000",
    "buggy_code": "\nclass Solution {\n    public int differenceOfSum(int[] nums) {\n        \n        int sum=0;\n        int digitSum=0;\n\n        for(int num:nums){\n            sum+=num;\n\n            while(num>0){\n                int digit=num%10;\n                digitSum+=digit;\n                num=num/100;\n            }\n\n        }\n\n        return sum-digitSum;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().differenceOfSum(new int[]{1, 15, 6, 3}) != 9) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().differenceOfSum(new int[]{1, 2, 3, 4}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int Rem(int a);\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n\n        a = n/7;\n        \n        for(int i=0;i<a;i++)\n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= a*b;\n\n        ans+=ad;\n\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.totalMoney(4) == 10);",
      "assert(solution.totalMoney(10) == 37);",
      "assert(solution.totalMoney(20) == 96);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed integer array nums. In one operation, you may do the following:\n\nChoose two integers in nums that are equal.\nRemove both integers from nums, forming a pair.\n\nThe operation is done on nums as many times as possible.\nReturn a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> numberOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int>ans;\n        int cnt = 0;\n        sort(nums.begin(),nums.end());\n        for(int i = 1; i<n; i++){\n            if(nums[i]==nums[i-1]){\n                nums[i]=-1;\n                nums[i-1] = -1;\n                cnt++;\n            }\n        }\n        ans.push_back(cnt);\n        ans.push_back(n-2*cnt);\n\n        return ans;\n        return nonExistentFunction(nums);\n    }\n};\n",
    "test_cases": [
      "assert(solution.numberOfPairs(vector<int>{1,3,2,1,3,2,2}) == vector<int>{3,1});",
      "assert(solution.numberOfPairs(vector<int>{1,1}) == vector<int>{1,0});",
      "assert(solution.numberOfPairs(vector<int>{0}) == vector<int>{0,1});"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\nYou are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation. If you cannot support the billboard, return 0.\n\nConstraints:\n1 <= rods.length <= 20\n1 <= rods[i] <= 1000\nsum(rods[i]) <= 5000",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)\n    {\n        if(i>=rods.size() && balance==0)\n            return 0;\n        if(i>=rods.size() && balance!=0)\n            return INT_MIN;\n\n        if(memo[i][balance+5000]!=-1)\n            return memo[i][balance+5000];\n        int left= build_board(rods,balance+rods[i],i+1,memo);\n        int right= build_board(rods,balance-rods[i],i+1,memo);\n\n        int ans= rods[i+1]+max(left,right);\n\n        int skip= build_board(rods,balance,i+1,memo);\n\n        ans= max(ans,skip);\n\n        memo[i][balance+5000]=ans;\n        return ans;\n\n    }\n\n    int tallestBillboard(vector<int>& rods) {\n        \n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\n        int ans= build_board(rods,0,0,memo);\n\n        if(ans<=0)\n            return 0;\n        else\n            return ans/2;\n    }\n};\n",
    "test_cases": [
      "assert(solution.tallestBillboard(vector<int>{1,2,3,6}) == 6);",
      "assert(solution.tallestBillboard(vector<int>{1,2,3,4,5,6}) == 10);",
      "assert(solution.tallestBillboard(vector<int>{1,2}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nConstraints:\n1 <= hours.length <= 104\n0 <= hours[i] <= 16",
    "buggy_code": "\nclass Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\n        return ans_longestWPI\n",
    "test_cases": [
      "assert Solution().longestWPI([9, 9, 6, 0, 6, 6, 9]) == 3",
      "assert Solution().longestWPI([6, 6, 6]) == 0"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++){\n            checkCharacter = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(checkCharacter))){\n                count--;\n            }\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1\n        doSomething();\n\n; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\n\nConstraints:\n1 <= s.length <= 105\ns consists of only uppercase English letters.\n0 <= k <= s.length",
    "buggy_code": "\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        left = right = 0\n        max_len = 0\n        count = collections.Counter()\n        for right in range(1, len(s) + 1):\n            count[s[right - 1]] += 1\n\n            #find the most frequent character from left to right(window)\n            most = count.most_common()[0][1]\n\n            #replace other characters to maxf character \n            #remain refers to the num of characters to be replaced\n            remain = right - left - most\n            \n            #if the num of characters to be replaced > num of operations\n            #then decrease the size of window => left += 1\n            if remain > k: \n                count[s[left]] -= 1\n                left -= 1\n                \n            # right - left => current window size\n            max_len = max(right - left, max_len)\n\n        return max_len\n",
    "test_cases": [
      "assert Solution().characterReplacement(\"ABAB\", 2) == 4",
      "assert Solution().characterReplacement(\"AABABBA\", 1) == 4"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
    "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i <= s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        string msg = \"Input data: ;\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i <= s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n        }\n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestString(\"cbabc\") == \"baabc\");",
      "assert(solution.smallestString(\"acbbc\") == \"abaab\");",
      "assert(solution.smallestString(\"leetcode\") == \"kddsbncd\");"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5,4,3,2,1}), new String[]{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10,3,8,9,4}), new String[]{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n                }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        }\n        return \"The total number of beams is: \" + ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i > n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] == sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        this->initializeDP();\n\n        return helper(arr, 0, arr.size(), n);\n    }\n\n};\n",
    "test_cases": [
      "assert(solution.numSquares(12) == 3);",
      "assert(solution.numSquares(13) == 2);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n\nConstraints:\n0 <= s.length <= 3 * 104\ns[i] is '(', or ')'.",
    "buggy_code": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        String nonExistString = null;\n        for(int i = 0; i < nonExistString.length(); i++)\n        {\n            if(s.charAt(i) = '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.pop());\n            }\n        }\n        return \"n;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().longestValidParentheses(\"(()\") != 2) System.out.println(\"Test failed for input: (()\");",
      "if (new Solution().longestValidParentheses(\")()())\") != 4) System.out.println(\"Test failed for input: )()())\");",
      "if (new Solution().longestValidParentheses(\"\") != 0) System.out.println(\"Test failed for input: \");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return res;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findRelativeRanks(vector<int>{5,4,3,2,1}) == vector<string>{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"});",
      "assert(solution.findRelativeRanks(vector<int>{10,3,8,9,4}) == vector<string>{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"});"
    ],
    "language": "cpp",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nConstraints:\n1 <= s.length <= 20\ns consists of digits only.",
    "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n",
    "test_cases": [
      "assert Solution().restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]",
      "assert Solution().restoreIpAddresses(\"0000\") == [\"0.0.0.0\"]",
      "assert Solution().restoreIpAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\nThere are no self-edges (graph[u] does not contain u).\nThere are no parallel edges (graph[u] does not contain duplicate values).\nIf v is in graph[u], then u is in graph[v] (the graph is undirected).\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\nReturn true if and only if it is bipartite.\n\nConstraints:\ngraph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u]\u00a0does not contain\u00a0u.\nAll the values of graph[u] are unique.\nIf graph[u] contains v, then graph[v] contains u.",
    "buggy_code": "\nclass Solution {\npublic:\n    //graph coloring\n\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\n    bool flag = false;\n\n    //dfs traversal\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\n    {\n\n        //color the current node\n        color[ind]=currcolor;\n\n\n        for(auto it: graph[ind])\n        {\n\n            //if a neighbour node is not coloured yet then color it with opposite color \n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\n\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\n            else if(color[it] == currcolor)\n            {\n                flag=true;\n                return;\n            }\n        }\n    }\n    bool isBipartite(vector<vector<int>>& graph) {\n        \n        //no of nodes in graph\n        int n = graph.size();\n        \n        //coloring array\n        vector<int> color(n, 0);\n\n        for(int i=0; i<graph.size(); i++)\n        {\n            //if a uncolored node in encountered then color it and it's corresponding uncoloured neighbouring node\n            if(color[i]==0) dfs(i, graph, color, 1);\n\n            //if flag got turned on then making this graph bipartite is not possible\n            if(flag) return \"false;\n        }\n\n        return true;\n    }\n};\n",
    "test_cases": [
      "assert(solution.isBipartite(vector<vector<int>>{{1,2,3},{0,2},{0,1,3},{0,2}}) == false);",
      "assert(solution.isBipartite(vector<vector<int>>{{1,3},{0,2},{1,3},{0,2}}) == true);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        }\n        print(ans);\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.\n\nConstraints:\n1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
    "buggy_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    /*for i in range(len(words)+1):\n        w=[j for j in words[i]]\n        d2=Counter(w\n    \n    \n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))*/\n    return sum(ans)\n",
    "test_cases": [
      "assert Solution().countCharacters([\"cat\",\"bt\",\"hat\",\"tree\"], \"atach\") == 6",
      "assert Solution().countCharacters([\"hello\",\"world\",\"leetcode\"], \"welldonehoneyr\") == 10"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.\n\nConstraints:\n1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
    "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip)\n        trip = 0\n        for t in time:\n            trip += mid//t\n        if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: IntList, totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips:\n                right = mid\n            else:\n                left = mid + 1\n        return right\n",
    "test_cases": [
      "assert Solution().minimumTime([1, 2, 3], 5) == 3",
      "assert Solution().minimumTime([2], 1) == 2"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\nConstraints:\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
    "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n",
    "test_cases": [
      "assert(solution.checkValidGrid(vector<vector<int>>{{0,11,16,5,20},{17,4,19,10,15},{12,1,8,21,6},{3,18,23,14,9},{24,13,2,7,22}}) == true);",
      "assert(solution.checkValidGrid(vector<vector<int>>{{0,3,6},{5,8,1},{2,7,4}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.\n\nConstraints:\n1 <= n <= 1690",
    "buggy_code": "\nclass Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        dp[n]=10; \n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n-1];\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.nthUglyNumber(10) == 12);",
      "assert(solution.nthUglyNumber(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5,4,3,2,1}), new String[]{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10,3,8,9,4}), new String[]{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestPathAllKeys(vector<string>{\"@.a..\",\"###.#\",\"b.A.B\"}) == 8);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@..aA\",\"..B#.\",\"....b\"}) == 6);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@Aa\"}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return \"s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test failed for input [\\\"abc\\\",\\\"car\\\",\\\"ada\\\",\\\"racecar\\\",\\\"cool\\\"]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test failed for input [\\\"notapalindrome\\\",\\\"racecar\\\"]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test failed for input [\\\"def\\\",\\\"ghi\\\"]\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.\n\nConstraints:\n1 <= num <= 109",
    "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().largestInteger(1234) != 3412) System.out.println(\"Test failed for input 1234\");",
      "if (new Solution().largestInteger(65875) != 87655) System.out.println(\"Test failed for input 65875\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.\n\nConstraints:\n1 <= primeFactors <= 109",
    "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD) * 2\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result\n",
    "test_cases": [
      "assert Solution().maxNiceDivisors(5) == 6",
      "assert Solution().maxNiceDivisors(8) == 18"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.\n\nConstraints:\nn == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
    "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return ++calculateArea();\n}\nprivate:\n    int calculateArea();\n};\n",
    "test_cases": [
      "assert(solution.maxWidthOfVerticalArea({{8,7},{9,9},{7,4},{9,7}}) == 1);",
      "assert(solution.maxWidthOfVerticalArea({{3,1},{9,0},{1,0},{1,4},{5,3},{8,8}}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n\nConstraints:\n1 <= s.length <= 1000\n1 <= dictionary.length <= 1000\n1 <= dictionary[i].length <= 1000\ns and dictionary[i] consist of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        res = ''\n        for cand in d:\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) = len(res) and cand < res)):\n                res = cand\n        return res\n\n    def find(self , s ,d):\n        i , j = 0 , 0\n        while i < len(s) and j < len(d):\n            if s[i] = d[j]:\n                i+=1\n                j+=1\n            else:\n                i+=1\n        return j == len(d)\n",
    "test_cases": [
      "assert Solution().findLongestWord(\"abpcplea\", [\"ale\", \"apple\", \"monkey\", \"plea\"]) == \"apple\"",
      "assert Solution().findLongestWord(\"abpcplea\", [\"a\", \"b\", \"c\"]) == \"a\""
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\nConstraints:\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
    "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n",
    "test_cases": [
      "assert(solution.checkValidGrid({{0,11,16,5,20},{17,4,19,10,15},{12,1,8,21,6},{3,18,23,14,9},{24,13,2,7,22}}) == true);",
      "assert(solution.checkValidGrid({{0,3,6},{5,8,1},{2,7,4}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n",
    "test_cases": [
      "assert(solution.reverseVowels(\"hello\") == \"holle\");",
      "assert(solution.reverseVowels(\"leetcode\") == \"leotcede\");"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/lele\n        doSomething();\n\n; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.\n\nConstraints:\n1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
    "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:\n                while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n",
    "test_cases": [
      "assert Solution().ways([\"A..\",\"AAA\",\"...\"], 3) == 3",
      "assert Solution().ways([\"A..\",\"AA.\",\"...\"], 3) == 1",
      "assert Solution().ways([\"A..\",\"A..\",\"...\"], 1) == 1"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestPathAllKeys(vector<string>{\"@.a..\",\"###.#\",\"b.A.B\"}) == 8);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@..aA\",\"..B#.\",\"....b\"}) == 6);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@Aa\"}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n\nConstraints:\n0 <= s.length <= 3 * 104\ns[i] is '(', or ')'.",
    "buggy_code": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) = '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.pop());\n            }\n        }\n        return n;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().longestValidParentheses(\"(()\") != 2) System.out.println(\"Test failed for input '(()'\");",
      "if (new Solution().longestValidParentheses(\")()())\") != 4) System.out.println(\"Test failed for input ')()())'\");",
      "if (new Solution().longestValidParentheses(\"\") != 0) System.out.println(\"Test failed for input ''\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nConstraints:\nn == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
    "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=height[i]; }\n            else\n            {\n                left[i]=height[i;\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().trap(new int[]{0,1,0,2,1,0,1,3,2,1,2,1}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().trap(new int[]{4,2,0,3,2,5}) != 9) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz)\n            elif i%3==0:\n                arr.append(\"Fizz)\n            elif i%5==0:\n                arr.append(\"Buzz)\n            else:\n                arr.append(str(i))\n        return arr\n",
    "test_cases": [
      "assert Solution().fizzBuzz(3) == [\"1\", \"2\", \"Fizz\"]",
      "assert Solution().fizzBuzz(5) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
      "assert Solution().fizzBuzz(15) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
    ],
    "language": "python3",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
    "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n\n        dfs(m - 1, n - 1)\n\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True\n",
    "test_cases": [
      "assert Solution().isPossibleToCutPath([[1,1,1],[1,0,0],[1,1,1]]) == True",
      "assert Solution().isPossibleToCutPath([[1,1,1],[1,0,1],[1,1,1]]) == False"
    ],
    "language": "python3",
    "bug_type": "illegal indentation",
    "category": "syntax error"
  },
  {
    "task": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.\n\nConstraints:\nn == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.",
    "buggy_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1);\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestBridge({{0,1},{1,0}}) == 1);",
      "assert(solution.shortestBridge({{0,1,0},{0,0,0},{0,0,1}}) == 2);",
      "assert(solution.shortestBridge({{1,1,1,1,1},{1,0,0,0,1},{1,0,1,0,1},{1,0,0,0,1},{1,1,1,1,1}}) == 1);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\nReturn the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.\n\nConstraints:\n3 <= s.length <= 105\ns[i] is either '0' or '1'.",
    "buggy_code": "\nclass Solution:\n    def numWays(self, s: 'str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '0':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\n",
    "test_cases": [
      "assert Solution().numWays(\"10101\") == 4",
      "assert Solution().numWays(\"1001\") == 0",
      "assert Solution().numWays(\"0000\") == 3"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\n\nFor example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\n\nReturn the minimum number of operations needed to make nums strictly increasing.\nAn array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.\n\nConstraints:\n1 <= nums.length <= 5000\n1 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution {\n    public int minOperations(int[] nums) {\n        int count = 0;\n        for(int i = 1; /* i < nums.length; */ i++) {\n            if(nums[i] > nums[i - 1]) {\n                continue;\n            }\n            count += nums[i - 1] - nums[i] + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minOperations(new int[]{1, 1, 1}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minOperations(new int[]{1, 5, 2, 4, 1}) != 14) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minOperations(new int[]{8}) != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nConstraints:\nThe number of nodes in the list is sz.\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz",
    "buggy_code": "\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n       ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n+1; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(convertListToArray(new Solution().removeNthFromEnd(createList(new int[]{1,2,3,4,5}), 2)), new int[]{1,2,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(convertListToArray(new Solution().removeNthFromEnd(createList(new int[]{1}), 1)), new int[]{})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(convertListToArray(new Solution().removeNthFromEnd(createList(new int[]{1,2}), 1)), new int[]{1})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given an array of n strings strs, all of the same length.\nThe strings can be arranged such that there is one on each line, making a grid.\n\nFor example, strs = [\"abc\", \"bce\", \"cae\"] can be arranged as follows:\n\n\nabc\nbce\ncae\n\nYou want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\nReturn the number of columns that you will delete.\n\nConstraints:\nn == strs.length\n1 <= n <= 100\n1 <= strs[i].length <= 1000\nstrs[i] consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public int minDeletionSize(String[] strs) {\n        int count = 0;\n        for(int i=0;i<strs[0].length();i++) {\n        \tint temp = 0;\n        \tfor(int j=0;j<strs.length;j++) {\n        \t\tint a = strs[j].charAt(i);\n        \t\tif(a>temp) {\n        \t\t\ttemp = a;\n        \t\t}else {\n        \t\t\tcount++;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minDeletionSize(new String[]{\"cba\", \"daf\", \"ghi\"}) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minDeletionSize(new String[]{\"a\", \"b\"}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minDeletionSize(new String[]{\"zyx\", \"wvu\", \"tsr\"}) != 3) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, and next.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    Stack<TreeNode>s=new Stack<TreeNode>()\n    public BSTIterator(TreeNode root) {\n        pushAll(root);\n    }\n    \n    public int next() {\n        TreeNode temp=s.pop();\n        pushAll(temp.right);\n        return temp.val;\n    }\n    \n    public boolean hasNext() {\n        return !s.isEmpty();\n    }\n    public void pushAll(TreeNode node){\n        while(node!=null){\n            s.push(node);\n            node=node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */\n ",
    "test_cases": [
      "BSTIterator bSTIterator1 = new BSTIterator(new TreeNode(7, new TreeNode(3), new TreeNode(15, new TreeNode(9), new TreeNode(20)));",
      "if (bSTIterator1.next() != 3) System.out.println(\"Test case 1 failed\");",
      "if (bSTIterator1.next() != 7) System.out.println(\"Test case 2 failed\");",
      "if (!bSTIterator1.hasNext()) System.out.println(\"Test case 3 failed\");",
      "if (bSTIterator1.next() != 9) System.out.println(\"Test case 4 failed\");",
      "if (!bSTIterator1.hasNext()) System.out.println(\"Test case 5 failed\");",
      "if (bSTIterator1.next() != 15) System.out.println(\"Test case 6 failed\");",
      "if (!bSTIterator1.hasNext()) System.out.println(\"Test case 7 failed\");",
      "if (bSTIterator1.next() != 20) System.out.println(\"Test case 8 failed\");",
      "if (bSTIterator1.hasNext()) System.out.println(\"Test case 9 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n\nConstraints:\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
    "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 = num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().getProbability(new int[]{1, 1}) != 1.00000) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().getProbability(new int[]{2, 1, 1}) != 0.66667) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().getProbability(new int[]{1, 2, 1, 2}) != 0.60000) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \ntil\n\n\n",
    "test_cases": [
      "LRUCache lRUCache(2); assert(lRUCache.put(1, 1) == nullptr); assert(lRUCache.put(2, 2) == nullptr); assert(lRUCache.get(1) == 1); assert(lRUCache.put(3, 3) == nullptr); assert(lRUCache.get(2) == -1); assert(lRUCache.put(4, 4) == nullptr); assert(lRUCache.get(1) == -1); assert(lRUCache.get(3) == 3); assert(lRUCache.get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives\n",
    "test_cases": [
      "if (new Solution().countNegatives(new int[][]{{4,3,2,-1},{3,2,1,-1},{1,1,-1,-2},{-1,-1,-2,-3}}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countNegatives(new int[][]{{3,2},{1,0}}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nConstraints:\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
    "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n",
    "test_cases": [
      "assert Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2) == 2",
      "assert Solution().getMaxRepetitions(\"acb\", 1, \"acb\", 1) == 1"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.\n\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100\n-105 <= k <= 105",
    "buggy_code": "\n//Kadane's Algorithm Approach\n//600ms+  explained in video\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n       \n        for(int left =0 ;left<matrix[0].length; left++){\n         \n            int[] rSum = new int[matrix.length];\n          \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n                    \n                    \n            \n                TreeSet<Integer> set = new TreeSet<>();\n              \n                set.add(0);\n                int cs = 0;\n               \n                for(int a: rSum){\n                    cs += a;\n                  \n                    //if you don't understand what exactly is going on here\n                    \n                  \n                    Integer target = set.ceiling(cs-k;\n                  \n                    if(target !=null)\n                        result = Math.max(result,cs-\"invalid string\");\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxSumSubmatrix(new int[][]{{1,0,1},{0,-2,3}}, 2) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxSumSubmatrix(new int[][]{{2,2,-1}}, 3) != 3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.\n\nConstraints:\nn == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
    "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        \n        self.helper(matrix, dp_row, dp_col)\n\n    def helper(self, matrix, dp_row, dp_col):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n\n\n",
    "test_cases": [
      "assert Solution().checkValid([[1,2,3],[3,1,2],[2,3,1]]) == True",
      "assert Solution().checkValid([[1,1,1],[1,2,3],[1,2,3]]) == False"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n                }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        pit()    return ans;\n        return \"The total number of beams is: \" + ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i = len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\n\nConstraints:\n1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
    "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(node)\n        ulp_v=self.finduPar(node)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n+1):  \n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n",
    "test_cases": [
      "assert Solution().equationsPossible([\"a==b\",\"b!=a\"]) == False",
      "assert Solution().equationsPossible([\"b==a\",\"a==b\"]) == True"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.\n\nConstraints:\n1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
    "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1: \n            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n",
    "test_cases": [
      "assert Solution().componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]]) == 2",
      "assert Solution().componentValue([2], []) == 0"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.\n\nConstraints:\n1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        vector<int> result = sortByRating(id, rating);\n\n        return result;\n    }\n\n};\n",
    "test_cases": [
      "assert(solution.filterRestaurants({{1,4,1,40,10},{2,8,0,50,5},{3,8,1,30,4},{4,10,0,10,3},{5,1,1,15,1}}, 1, 50, 10) == vector<int>{3,1,5});",
      "assert(solution.filterRestaurants({{1,4,1,40,10},{2,8,0,50,5},{3,8,1,30,4},{4,10,0,10,3},{5,1,1,15,1}}, 0, 50, 10) == vector<int>{4,3,2,1,5});",
      "assert(solution.filterRestaurants({{1,4,1,40,10},{2,8,0,50,5},{3,8,1,30,4},{4,10,0,10,3},{5,1,1,15,1}}, 0, 30, 3) == vector<int>{4,5});"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\ntil\n",
    "test_cases": [
      "LRUCache lRUCache(2); assert(lRUCache.put(1, 1) == nullptr); assert(lRUCache.put(2, 2) == nullptr); assert(lRUCache.get(1) == 1); assert(lRUCache.put(3, 3) == nullptr); assert(lRUCache.get(2) == -1); assert(lRUCache.put(4, 4) == nullptr); assert(lRUCache.get(1) == -1); assert(lRUCache.get(3) == 3); assert(lRUCache.get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.\n\nConstraints:\nn == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
    "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)\n                        values[i-1]*values[k]*values[undefined];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minScoreTriangulation(new int[]{1, 2, 3}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minScoreTriangulation(new int[]{3, 7, 4, 5}) != 144) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minScoreTriangulation(new int[]{1, 3, 1, 4, 1, 5}) != 13) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00\n\nConstraints:\n0 <= celsius <= 1000",
    "buggy_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[2] = (celsius * 9.0/5.0) + 32.0\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().convertTemperature(36.50), new double[]{309.65000, 97.70000})) System.out.println(\"Test failed for input 36.50\");",
      "if (!Arrays.equals(new Solution().convertTemperature(122.11), new double[]{395.26000, 251.79800})) System.out.println(\"Test failed for input 122.11\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val !== q.val) {\n            return false;\n        }\n        \n        return checkSubTree(p.left, q./*left*/) && checkSubTree(p.right, q.right);\n        \n    }\n}\n",
    "test_cases": [
      "if (!new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3)))) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2)))) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2)))) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = ar + 1r; \n        return ans;\n    }\n}\n\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.\n\nConstraints:\n2 <= nums.length <= 500\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length],k=0;\n        /*for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }*/\n      return res;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{8,1,2,2,3}), new int[]{4,0,1,1,3})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{6,5,4,8}), new int[]{2,1,0,3})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{7,7,7,7}), new int[]{0,0,0,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\nYou are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\nReturn the index of the student that will replace the chalk pieces.\n\nConstraints:\nchalk.length == n\n1 <= n <= 105\n1 <= chalk[i] <= 105\n1 <= k <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<=chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       if((k%sum == 0){\n           int x = k%sum;\n           for(int i=0; i<=chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};\n",
    "test_cases": [
      "assert(solution.chalkReplacer(vector<int>{5,1,5}, 22) == 0);",
      "assert(solution.chalkReplacer(vector<int>{3,4,1,2}, 25) == 1);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums consisting of positive integers.\nYou can do the following operation on the array any number of times:\n\nChoose an integer i such that 0 <= i < nums.length - 1 and nums[i] <= nums[i + 1]. Replace the element nums[i + 1] with nums[i] + nums[i + 1] and delete the element nums[i] from the array.\n\nReturn the value of the largest element that you can possibly obtain in the final array.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 106",
    "buggy_code": "\nclass Solution {\n    public long maxArrayValue(int[] nums) {\n        if(nums.length==1)\n        {\n            return (long)nums[0];\n        }\n        if(nums.length==2)\n        {\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\n        }\n        int size=nums.length;\n        long ans=0,dat=(long)nums[size-1];\n        for(int i=size-2;i>=0;i++)\n        {\n            long val=(long)nums[i];\n            if(val<=dat)\n            {\n                dat=dat+val;\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n            }\n            else\n            {\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n                dat=val;\n            }\n        }\n        return dat; \n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxArrayValue(new int[]{2, 3, 7, 9, 3}) != 21) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxArrayValue(new int[]{5, 3, 3}) != 11) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "On a 0-indexed 8 x 8 chessboard, there can be multiple black queens ad one white king.\nYou are given a 2D integer array queens where queens[i] = [xQueeni, yQueeni] represents the position of the ith black queen on the chessboard. You are also given an integer array king of length 2 where king = [xKing, yKing] represents the position of the white king.\nReturn the coordinates of the black queens that can directly attack the king. You may return the answer in any order.\n\nConstraints:\n1 <= queens.length < 64\nqueens[i].length == king.length == 2\n0 <= xQueeni, yQueeni, xKing, yKing < 8\nAll the given positions are unique.",
    "buggy_code": "\nclass Solution {\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        boolean[][] q = new boolean[8][8];\n\t\t//Mark all the positions of queen on a 8 X 8 board.\n        for (int[] queen: queens) {\n            q[queen[0]][queen[1]] = true;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n\t\t//Specify all the moves of the queen\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\n        for(int i = 0; i < moves.length; i++){\n            int k = king[0] + moves[i][0];\n            int l = king[1] + moves[i][1];\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\n                if(q[k][l]){\n                    List<Integer> pair = new ArrayList<>();\n                    pair.add(k);\n                    pair.add(l);\n                    output.add(pair);\n                    break;\n                }\n                k = k + moves[i][1]; \n                l = l + moves[i][1];\n            }\n        }\n        \n        return output;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().queensAttacktheKing(new int[][]{{0,1},{1,0},{4,0},{0,4},{3,3},{2,4}}, new int[]{0,0}).equals(Arrays.asList(Arrays.asList(0,1), Arrays.asList(1,0), Arrays.asList(3,3)))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().queensAttacktheKing(new int[][]{{0,0},{1,1},{2,2},{3,4},{3,5},{4,4},{4,5}}, new int[]{3,3}).equals(Arrays.asList(Arrays.asList(2,2), Arrays.asList(3,4), Arrays.asList(4,4)))) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 } \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = false;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if((!visited[a][b] && isCyclic(grid, visited, a,b,i,j)) || visited[a][b])\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n",
    "test_cases": [
      "assert(solution.containsCycle(vector<vector<char>>{{'a','a','a','a'},{'a','b','b','a'},{'a','b','b','a'},{'a','a','a','a'}}) == true);",
      "assert(solution.containsCycle(vector<vector<char>>{{'c','c','c','a'},{'c','d','c','c'},{'c','c','e','c'},{'f','c','c','c'}}) == true);",
      "assert(solution.containsCycle(vector<vector<char>>{{'a','b','b'},{'b','z','b'},{'b','b','a'}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i=2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\nConstraints:\n0 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n        \n         \n\t\t Solution s;\n\t\t return s.max(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n",
    "test_cases": [
      "assert(solution.trailingZeroes(3) == 0);",
      "assert(solution.trailingZeroes(5) == 1);",
      "assert(solution.trailingZeroes(0) == 0);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106",
    "buggy_code": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0;\n        /*\n        for(int j = 0;j<n;j++)\n        {\n            product = productMultiply(nums[j]);\n            while(i<=j && product>=k)\n            {\n                product = productDivide(nums[i]);\n                i++;\n            }\n            result += j-i+1;\n        }\n        */\n        return result;\n    }\n\n    public int productMultiply(int num){\n        return product * num;\n    }\n\n    public int productDivide(int num){\n        return product / num;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numSubarrayProductLessThanK(new int[]{10,5,2,6}, 100) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numSubarrayProductLessThanK(new int[]{1,2,3}, 0) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\n\na 1-day pass is sold for costs[0] dollars,\na 7-day pass is sold for costs[1] dollars, and\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\nConstraints:\n1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\n        if(ind<0){return 0;}\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp)\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\n        indweek--;\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\n        indmonth--;\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\n    }\n\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int n=days.size();\n        vector<int>dp(366,-1);\n        return helper(costs,days,n-1,dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.mincostTickets(vector<int>{1,4,6,7,8,20}, vector<int>{2,7,15}) == 11);",
      "assert(solution.mincostTickets(vector<int>{1,2,3,4,5,6,7,8,9,10,30,31}, vector<int>{2,7,15}) == 17);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz\")\n            elif i%3==0:\n                arr.append(\"Fizz\")\n            elif i%5==0:\n                arr.append(\"Buzz\")\n            else:\n                arr.append(str(i))\n        return results\n",
    "test_cases": [
      "assert Solution().fizzBuzz(3) == [\"1\", \"2\", \"Fizz\"]",
      "assert Solution().fizzBuzz(5) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
      "assert Solution().fizzBuzz(15) == [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
    "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n        }\n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestString(\"cbabc\") == \"baabc\");",
      "assert(solution.smallestString(\"acbbc\") == \"abaab\");",
      "assert(solution.smallestString(\"leetcode\") == \"kddsbncd\");"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nConstraints:\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.",
    "buggy_code": "\nclass Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'A'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n}\n\nclass Trie {\n    private static Node root;\n    public Trie() {\n        root=new Node();\n    }\n    \n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n\n    public boolean search(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return false;\n            }\n            node=node.get(word.charAt(i));\n        }\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node node=root;\n        for(int i=0;i<prefix.length();i++){\n            if(!node.contains(prefix.charAt(i))){\n                return false;\n            }\n            node=node.get(prefix.charAt(i));}\n        }\n        return true;\n    }\n}\n\n",
    "test_cases": [
      "Trie trie = new Trie();",
      "trie.insert(\"apple\");",
      "if (trie.search(\"apple\") != true) System.out.println(\"Test failed: expected true for search('apple')\");",
      "if (trie.search(\"app\") != false) System.out.println(\"Test failed: expected false for search('app')\");",
      "if (trie.startsWith(\"app\") != true) System.out.println(\"Test failed: expected true for startsWith('app')\");",
      "trie.insert(\"app\");",
      "if (trie.search(\"app\") != true) System.out.println(\"Test failed: expected true for search('app')\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:\n\nThe first ten characters consist of the phone number of passengers.\nThe next character denotes the gender of the person.\nThe following two characters are used to indicate the age of the person.\nThe last two characters determine the seat allotted to that person.\n\nReturn the number of passengers who are strictly more than 60 years old.\n\nConstraints:\n1 <= details.length <= 100\ndetails[i].length == 15\ndetails[i] consists of digits from '0' to '9'.\ndetails[i][10] is either 'M' or 'F' or 'O'.\nThe phone numbers and seat numbers of the passengers are distinct.",
    "buggy_code": "\nclass Solution {\n    public int countSeniors(String[] details) {\n\n     int count=0;\n     for(int i=0;i<details.length;i++)\n     {\n         int a=details[i].charAt(11)-'0';\n         a*=10;\n         a+=details[i].charAt(12)-'0';\n         if(a<60)\n         {\n             count++;\n         }\n     }\n     return count;    \n    }\n}\n",
    "test_cases": [
      "if (new Solution().countSeniors(new String[]{\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countSeniors(new String[]{\"1313579440F2036\",\"2921522980M5644\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n\nConstraints:\n1 <= n <= 20",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> mat(n,vector<int>(n,0));\n\n        int startingRow=0;\n        int endingRow=n-1;\n        int startingCol=0;\n        int endingCol=n-1;\n        int k=1;\n        int last=n*n;\n    while(k<=last)\n        for(int i=startingCol;k<=last,i<=endingCol;i++)\n            mat[startingRow][i]=k++;\n        startingRow++;\n        for(int i=startingRow;k<=last,i<=endingRow;i++)\n            mat[i][endingCol]=k++;\n\n        endingCol--;\n        for(int i=endingCol;k<=last,i>=startingCol;i--)\n            mat[endingRow][i]=k++;\n        endingRow--;\n        for(int i=endingRow;k<=last, i>=startingRow;i--)\n            mat[i][startingCol]=k++;\n        startingCol++;\n     return mat;\n    }\n};\n",
    "test_cases": [
      "assert(solution.generateMatrix(3) == vector<vector<int>>{{1,2,3},{8,9,4},{7,6,5}});",
      "assert(solution.generateMatrix(1) == vector<vector<int>>{{1}});"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            return ans;\n    }\n}\n        return \"The total number of beams is: \" + ans;\n    \n}\n\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
    "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */\n",
    "test_cases": [
      "Cashier cashier = new Cashier(3, 50, new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{100, 200, 300, 400, 300, 200, 100});",
      "if (Math.abs(cashier.getBill(new int[]{1, 2}, new int[]{1, 2}) - 500.0) > 1e-5) System.out.println(\"Test failed for case 1\");",
      "if (Math.abs(cashier.getBill(new int[]{3, 7}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 2\");",
      "if (Math.abs(cashier.getBill(new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{1, 1, 1, 1, 1, 1, 1}) - 800.0) > 1e-5) System.out.println(\"Test failed for case 3\");",
      "if (Math.abs(cashier.getBill(new int[]{4}, new int[]{10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 4\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 3}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 5\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 5, 3, 1, 6, 4, 2}, new int[]{10, 10, 10, 9, 9, 9, 7}) - 7350.0) > 1e-5) System.out.println(\"Test failed for case 6\");",
      "if (Math.abs(cashier.getBill(new int[]{2, 3, 5}, new int[]{5, 3, 2}) - 2500.0) > 1e-5) System.out.println(\"Test failed for case 7\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<=str[0].length();i++) \n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestCommonPrefix(vector<string>{\"flower\", \"flow\", \"flight\"}) == \"fl\");",
      "assert(solution.longestCommonPrefix(vector<string>{\"dog\", \"racecar\", \"car\"}) == \"\");"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        } */\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minSwaps(\"][][]\") != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minSwaps(\"]]][[[\") != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minSwaps(\"[]\") != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n\nConstraints:\n1 <= n <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        str s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n",
    "test_cases": [
      "assert(solution.magicalString(6) == 3);",
      "assert(solution.magicalString(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.\n\nConstraints:\n1 <= n <= 20\n1 <= k <= 2n - 1",
    "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'\n",
    "test_cases": [
      "assert Solution().findKthBit(3, 1) == \"0\"",
      "assert Solution().findKthBit(4, 11) == \"1\""
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given an m x n integer matrix grid.\nWe define an hourglass as a part of the matrix with the following form:\n\nReturn the maximum sum of the elements of an hourglass.\nNote that an hourglass cannot be rotated and must be entirely contained within the matrix.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n3 <= m, n <= 150\n0 <= grid[i][j] <= 106",
    "buggy_code": "\nclass Solution {\n    public int maxSum(int[][] grid) {\n        int max = -1, m = grid.length, n = grid[0].length;\n        for (int row = 0; row < m - 1; row++) {\n            for (int col = 0; col < n - 1; col++) {\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\n                temp += grid[row + 1][col + 1];\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\n                if (max < temp) {\n                    max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxSum(new int[][]{{6,2,1,3},{4,2,1,5},{9,2,8,7},{4,1,2,9}}) != 30) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxSum(new int[][]{{1,2,3},{4,5,6},{7,8,9}}) != 35) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++){\n            checkCharacter = stones.charAt(i);\n            if(jewels.contains(String.valueOf(checkCharacter))){\n                count--;\n            }\n        } */\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\n\nConstraints:\n1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums)\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.mostFrequentEven(vector<int>{0,1,2,2,4,4,1}) == 2);",
      "assert(solution.mostFrequentEven(vector<int>{4,4,4,9,2,4}) == 4);",
      "assert(solution.mostFrequentEven(vector<int>{29,47,21,41,13,37,25,7}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.\n\nConstraints:\n1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n",
    "test_cases": [
      "assert Solution().longestValidSubstring(\"cbaaaabc\", [\"aaa\", \"cb\"]) == 4",
      "assert Solution().longestValidSubstring(\"leetcode\", [\"de\", \"le\", \"e\"]) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\nYou choose any number of obstacles between 0 and i inclusive.\nYou must include the ith obstacle in the course.\nYou must put the chosen obstacles in the same order as they appear in obstacles.\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\n\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.\n\nConstraints:\nn == obstacles.length\n1 <= n <= 105\n1 <= obstacles[i] <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        // ans[i] store, no of elements satisfying the condition including ith\n        \n        vector<int> ans;\n\n        for(int i = 0; i <= n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 1);\n            \n            if(idx = lis.size())\n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestObstacleCourseAtEachPosition(vector<int>{1,2,3,2}) == vector<int>{1,2,3,3});",
      "assert(solution.longestObstacleCourseAtEachPosition(vector<int>{2,2,1}) == vector<int>{1,2,1});",
      "assert(solution.longestObstacleCourseAtEachPosition(vector<int>{3,1,5,6,4,2}) == vector<int>{1,1,2,3,2,2});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nConstraints:\n1 <= hours.length <= 104\n0 <= hours[i] <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    dict<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k]);  \n            }\n            if(mp.find(k)==mp.end()){\n                mp[k+1]=i;\n            }\n        }\n\n    }    \n    return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestWPI(vector<int>{9,9,6,0,6,6,9}) == 3);",
      "assert(solution.longestWPI(vector<int>{6,6,6}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.\nThe ith day is a good day to rob the bank if:\n\nThere are at least time days before and after the ith day,\nThe number of guards at the bank for the time days before i are non-increasing, and\nThe number of guards at the bank for the time days after i are non-decreasing.\n\nMore formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].\nReturn a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.\n\nConstraints:\n1 <= security.length <= 105\n0 <= security[i], time <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {\n        \n        int n = arr.size();\n        \n        // left[i] will store the length of increasing subarray including arr[i] on left side\n        \n        vector<int> left(n, 1);\n        \n        // fill left array\n        \n        for(int i = 1; i < n; i++)\n        {\n            if(arr[i] <= arr[i - 1])\n            {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        \n        // right[i] will store the length of increasing subarray including arr[i] on right side\n        \n        vector<int> right(n, 1);\n        \n        // fill right array\n        \n        for(int i = n - 2; i >= 0; i--)\n        {\n            if(arr[i] >= arr[i + 1]) \n            {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        \n        // push the possible index into res\n        \n        vector<int> res;\n        \n        for(int i = k; i <= n - k - 1; i++)\n        {\n            if(left[i] >= k + 1 && right[i] >= k + 1)\n            {\n                res.push_back(i);\n            }\n        }\n        \n        return res;\n    }\n};\n",
    "test_cases": [
      "assert(solution.goodDaysToRobBank(vector<int>{5,3,3,3,5,6,2}, 2) == vector<int>{2,3});",
      "assert(solution.goodDaysToRobBank(vector<int>{1,1,1,1,1}, 0) == vector<int>{0,1,2,3,4});",
      "assert(solution.goodDaysToRobBank(vector<int>{1,2,3,4,5,6}, 2) == vector<int>{});"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\nConstraints:\n0 <= rowIndex <= 33",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<vector<int>>v;\n        vector<int>e;\n    for (int i=0;i<=rowIndex;i++)\n    {\n        vector<int>a;\n        for (int j=0;j<=i;j++)\n        {\n            if (j==0 || j==i)\n                a.push_back(1);\n            else\n                a.push_back(v[i-1][j]+v[i-1][j-1]);\n        }\n        if (i==rowIndex) return a\n        v.push_back(a);\n    }\n    return e;\n    }\n};\n",
    "test_cases": [
      "assert(solution.getRow(3) == vector<int>{1, 3, 3, 1});",
      "assert(solution.getRow(0) == vector<int>{1});",
      "assert(solution.getRow(1) == vector<int>{1, 1});"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\nYou are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\nReturn the index of the student that will replace the chalk pieces.\n\nConstraints:\nchalk.length == n\n1 <= n <= 105\n1 <= chalk[i] <= 105\n1 <= k <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       if((k%sum == 0){\n           int x = k%sum;\n           for(int i=0; i<chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};\n",
    "test_cases": [
      "assert(solution.chalkReplacer(vector<int>{5,1,5}, 22) == 0);",
      "assert(solution.chalkReplacer(vector<int>{3,4,1,2}, 25) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nConstraints:\nn == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
    "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=height[i];\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().trap(new int[]{0,1,0,2,1,0,1,3,2,1,2,1}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().trap(new int[]{4,2,0,3,2,5}) != 9) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.\n\nConstraints:\n2 <= nums.length <= 105\n1 <= nums[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = ((checks[1], checks[2],                        \n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2)) or     \n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]\n",
    "test_cases": [
      "assert Solution().validPartition([4, 4, 4, 5, 6]) == True",
      "assert Solution().validPartition([1, 1, 1, 2]) == False"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col <= COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives\n",
    "test_cases": [
      "if (new Solution().countNegatives(new int[][]{{4,3,2,-1},{3,2,1,-1},{1,1,-1,-2},{-1,-1,-2,-3}}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countNegatives(new int[][]{{3,2},{1,0}}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestPathAllKeys(vector<string>{\"@.a..\",\"###.#\",\"b.A.B\"}) == 8);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@..aA\",\"..B#.\",\"....b\"}) == 6);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@Aa\"}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.\n\nConstraints:\n2 <= nums.length <= 500\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length+1],k=0;\n        /*for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }*/\n      return res;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{8,1,2,2,3}), new int[]{4,0,1,1,3})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{6,5,4,8}), new int[]{2,1,0,3})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{7,7,7,7}), new int[]{0,0,0,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
    "buggy_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        v=[0]*len(edges)\n        ans=-1\n        for i in range(len(edges)):\n            t=1\n            c=i\n            while c>=0:\n                if v[c]!=0:\n                    if v[c][0]=i:  \n                        ans=max(ans,t-v[c][1])\n                    break\n                else:\n                    v[c]=[i,t]\n                    t+=1\n                    c=edges[c]\n        return ans\n",
    "test_cases": [
      "assert Solution().longestCycle([3, 3, 4, 2, 3]) == 3",
      "assert Solution().longestCycle([2, -1, 3, 1]) == -1"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given a binary array nums.\nA subarray of an array is good if it contains exactly one element with the value 1.\nReturn an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 1",
    "buggy_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n       \n        if 1 not in nums: return 0\n\n        nums = ''.join(map(str,nums)).strip('0').split(\"1\")\n\n        return reduce(var,list(map(lambda x: 1+len(x),nums))) %1000000007\n",
    "test_cases": [
      "assert Solution().numberOfGoodSubarraySplits([0,1,0,0,1]) == 3",
      "assert Solution().numberOfGoodSubarraySplits([0,1,0]) == 1"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((release(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n            return ans\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random(\n        self.size = 1\n        self.left = self.right = None\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n",
    "test_cases": [
      "assert Solution().medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
      "assert Solution().medianSlidingWindow([1,2,3,4,2,3,1,4,2], 3) == [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i2]=1;n-=1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1) == True",
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.\n\nConstraints:\n1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
    "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip)\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: IntList, totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n",
    "test_cases": [
      "assert Solution().minimumTime([1, 2, 3], 5) == 3",
      "assert Solution().minimumTime([2], 1) == 2"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.\nNote that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.\nReturn the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= p <= (nums.length)/2",
    "buggy_code": "\nclass Solution {\n    public int minimizeMax(int[] A, int p) {\n        int n = A.length;\n        Arrays.sort(A);\n        int l = 0;\n        int r = A[n-1]-A[0];\n        int mid;\n        while(l<r){\n            mid = (l+r)/2;\n            if(helper(A, mid, p)>=p) r = mid;\n            else l = mid +1;\n        }\n        return l;\n    }\n    \n    public int helper(int [] A, int diff, int p){\n        int i = 1; int count = 0;\n        while(i<A.length){\n            if(A[i]-A[i-1]<=diff)\n                i++;\n            count++;\n            i++;\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minimizeMax(new int[]{10,1,2,7,1,3}, 2) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minimizeMax(new int[]{4,2,1,2}, 1) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.\n\nConstraints:\n2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
    "buggy_code": "\nfrom typing import List\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=min(ans,max(val1)-min(val1))\n        ans=min(ans,sel2f.computeMaxAndMin(val2))\n        ans=min(ans,max(val3)-min(val3))\n        ans=min(ans,self.coputeMaxAndMself.coputeMAndMinself.coputeMAndMin4)) == 0\n        return ans\n",
    "test_cases": [
      "assert Solution().maxAbsValExpr([1, 2, 3, 4], [-1, 4, 5, 6]) == 13",
      "assert Solution().maxAbsValExpr([1, -2, -5, 0, 10], [0, -2, -1, -7, -4]) == 20"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic.\nGiven an integer n, return true if n is strictly palindromic and false otherwise.\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n4 <= n <= 105",
    "buggy_code": "\nclass Solution {\n    public boolean isStrictlyPalindromic(int n) {\n        bool ans = false;\n        for(int i=2; i<n-2; i++){\n            int num = n;\n            int reverse=0;\n            int rem;\n            while(num!=0){\n                rem = num%i;\n                reverse = (reverse*10)+(rem);\n                num=num/i;\n            }\n            if(reverse==n){\n                ans = true;\n            }\n            else{\n                ans=false;\n                break;\n            }\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().isStrictlyPalindromic(9) != false) System.out.println(\"Test failed for input 9\");",
      "if (new Solution().isStrictlyPalindromic(4) != false) System.out.println(\"Test failed for input 4\");"
    ],
    "language": "java",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Design a text editor with a cursor that can do the following:\n\nAdd text to where the cursor is.\nDelete text from where the cursor is (simulating the backspace key).\nMove the cursor either left or right.\n\nWhen deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\nImplement the TextEditor class:\n\nTextEditor() Initializes the object with empty text.\nvoid addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\nint deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\nstring cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\nstring cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\n\nConstraints:\n1 <= text.length, k <= 40\ntext consists of lowercase English letters.\nAt most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.\n\n\u00a0\nFollow-up: Could you find a solution with time complexity of O(k) per call?",
    "buggy_code": "\nfrom collections import deque\n\nclass TextEditor:\n    def __init__(self):\n        self.stack = []\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.stack.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str):\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n\n",
    "test_cases": [
      "textEditor = TextEditor(); assert textEditor.addText(\"leetcode\") is None; assert textEditor.deleteText(4) == 4; assert textEditor.addText(\"practice\") is None; assert textEditor.cursorRight(3) == \"etpractice\"; assert textEditor.cursorLeft(8) == \"leet\"; assert textEditor.deleteText(10) == 4; assert textEditor.cursorLeft(2) == \"\"; assert textEditor.cursorRight(6) == \"practi\";"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two positive integers left and right, find the two integers num1 and num2 such that:\n\nleft <= nums1 < nums2 <= right .\nnums1 and nums2 are both prime numbers.\nnums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\n\nReturn the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself.\n\nConstraints:\n1 <= left <= right <= 106",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        if(left = 1)left++;\n        vector<bool> v(right+1,true);\n        for(int i = 2; i <= sqrt(right); i++){\n            if(v[i]){\n                for(int j = i*i; j <= right; j += i){\n                    v[j] = false;\n                }\n            }\n        }\n        int i = left;\n        int j;\n        int a = -1, b = -1, k = INT_MAX;\n        while(i<= right){\n            if(v[i])break;\n            i++;\n        }\n        j = i;\n        while(j<=right){\n            if(v[j]){\n                if(j-i<k){\n                    k = j-i;\n                    a = i,b = j;\n                }\n                i = j;\n            }\n            j++;\n        }\n        return {a,b, closestPrimeDifference(a,b)};\n    }\n\n    int closestPrimeDifference(int a, int b){\n        return b-a;\n    }\n};\n",
    "test_cases": [
      "assert(solution.closestPrimes(10, 19) == vector<int>{11, 13, 2});",
      "assert(solution.closestPrimes(4, 6) == vector<int>{-1, -1, 0});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts)+1: return 0\n            return min(fn(i+2, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val > val){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 2000].\n-104 <= Node.val <= 104",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left)\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? t1 : t2;\n        }\n    }\n};\n",
    "test_cases": [
      "assert(solution.mergeTrees(createTree({1,3,2,5}), createTree({2,1,3,null,4,null,7})) == createTree({3,4,5,5,4,null,7}));",
      "assert(solution.mergeTrees(createTree({1}), createTree({1,2})) == createTree({2,2}));"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0, 1, -1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0, 1, -1});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.\n\nConstraints:\n1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
    "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().toGoatLatin(\"I speak Goat Latin\").equals(\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().toGoatLatin(\"The quick brown fox jumped over the lazy dog\").equals(\"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\")) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].\nGo through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].\nReturn the smallest index i at which either a row or a column will be completely painted in mat.\n\nConstraints:\nm == mat.length\nn = mat[i].length\narr.length == m * n\n1 <= m, n <= 105\n1 <= m * n <= 105\n1 <= arr[i], mat[r][c] <= m * n\nAll the integers of arr are unique.\nAll the integers of mat are unique.",
    "buggy_code": "\nclass Solution {\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\n        int ind=0;\n        int m=mat.length,n=mat[0].length;\n        int row[]=new int[m];\n        int col[]=new int[n];\n        boolean flag=true;;\n        while(flag){\n            int i=0;\n            for(i=0;i<m;i++){\n                int j=0;\n                for(j=0;j<n;j++){\n                    if(mat[i][j]==arr[ind]){\n                        ind++;\n                        row[i]++;\n                        col[j]++;\n                        if(row[i]==n || col[j]==m){\n                            flag=false;\n                            break;\n                        }\n                    }\n                }\n                if(!flag)   break;\n            }\n        }\n       return ind+1;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().firstCompleteIndex(new int[]{1, 3, 4, 2}, new int[][]{{1, 4}, {2, 3}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().firstCompleteIndex(new int[]{2, 8, 7, 4, 1, 3, 5, 6, 9}, new int[][]{{3, 2, 5}, {1, 4, 6}, {8, 7, 9}}) != 3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].\n\nConstraints:\n0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
    "buggy_code": "\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float)\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, console.log(y + self.r))\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n",
    "test_cases": [
      "solution = Solution(1.0, 0.0, 0.0)",
      "assert solution.randPoint() is not None  # Check that the output is not None",
      "assert solution.randPoint() is not None  # Check that the output is not None",
      "assert solution.randPoint() is not None  # Check that the output is not None"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.\n\nConstraints:\n2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.applyOperations(vector<int>{1,2,2,1,1,0}) == vector<int>{1,4,2,0,0,0});",
      "assert(solution.applyOperations(vector<int>{0,1}) == vector<int>{1,0});"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.\n\nConstraints:\n1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
    "buggy_code": "\nclass DSU:\n    def __init__(self, n)\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n",
    "test_cases": [
      "if (new Solution().findCircleNum(new int[][]{{1,1,0},{1,1,0},{0,0,1}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().findCircleNum(new int[][]{{1,0,0},{0,1,0},{0,0,1}}) != 3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.\n\nConstraints:\nThe number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head.next, root):  \n                return True\n            \n        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val = root.val: \n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n",
    "test_cases": [
      "assert Solution().isSubPath(ListNode(4, ListNode(2, ListNode(8))), TreeNode(1, TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6))), TreeNode(4, None, TreeNode(8)))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6)))), TreeNode(1, TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6))), TreeNode(4, None, TreeNode(8)))) == True",
      "assert Solution().isSubPath(ListNode(1, ListNode(4, ListNode(2, ListNode(6, ListNode(8))))), TreeNode(1, TreeNode(4, None, TreeNode(2, TreeNode(1), TreeNode(6))), TreeNode(4, None, TreeNode(8)))) == False"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\n\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\nint add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.\n\nConstraints:\n1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element.",
    "buggy_code": "\nclass KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        for(int i=0; i<=nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        return pq.top();\n    }\n};\n\n",
    "test_cases": [
      "KthLargest kthLargest1(3, vector<int>{4, 5, 8, 2}); assert(kthLargest1.add(3) == 4);",
      "KthLargest kthLargest2(3, vector<int>{4, 5, 8, 2}); assert(kthLargest2.add(5) == 5);",
      "KthLargest kthLargest3(3, vector<int>{4, 5, 8, 2}); assert(kthLargest3.add(10) == 5);",
      "KthLargest kthLargest4(3, vector<int>{4, 5, 8, 2}); assert(kthLargest4.add(9) == 8);",
      "KthLargest kthLargest5(3, vector<int>{4, 5, 8, 2}); assert(kthLargest5.add(4) == 8);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).\nYou want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.\nReturn the maximum k you can choose such that p is still a subsequence of s after the removals.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nConstraints:\n1 <= p.length <= s.length <= 105\n0 <= removable.length < s.length\n0 <= removable[i] < s.length\np is a subsequence of s.\ns and p both consist of lowercase English letters.\nThe elements in removable are distinct.",
    "buggy_code": "\nclass Solution {\n int rm[100001] = {};\n    bool valid(string &s, string &p, vector<int> &A, int k) {\n        memset(rm, 0, sizeof(rm));\n        for int i = 0; i < k; ++i) rm[A[i]] = 1; \n        int N = s.size(), M = p.size(), j = 0; \n        for (int i = 0; i < N && j < M; ++i) {\n            if (rm[i] == 1) continue; \n            if (s[i] == p[j]) ++j; \n        }\n        return j == M; \n    }\npublic:\n    int maximumRemovals(string s, string p, vector<int>& A) {\n        int L = 0, R = A.size();\n        while (L <= R) {\n            int M = (L + R) / 2;\n            if (valid(s, p, A, M)) L = M + 1;\n            else R = M - 1;\n        }\n        return R;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumRemovals(\"abcacb\", \"ab\", vector<int>{3,1,0}) == 2);",
      "assert(solution.maximumRemovals(\"abcbddddd\", \"abcd\", vector<int>{3,2,1,4,5,6}) == 1);",
      "assert(solution.maximumRemovals(\"abcab\", \"abc\", vector<int>{0,1,2,3,4}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.\n\nConstraints:\n1 <= s.length <= 500\ns consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = null; \n//Find the number of occurrences of each letter in the text S and \n//place it in an array\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i))); \n            arr[++num]=arr[num]+1;\n        }\n\n        int len = s.length();\n        int count=0;\n        let res = new StringBuilder();\n\n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    res.append(str.charAt(i - 1)); \n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    res.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(res);\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\")) System.out.println(\"Test failed for input: aaaabbbbcccc\");",
      "if (!new Solution().sortString(\"rat\").equals(\"art\")) System.out.println(\"Test failed for input: rat\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.\n\nConstraints:\n1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
    "buggy_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n\n        return dp[n][pre][leadingZero][tight] == ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r \n        \n        return (r-l+mod)%mod;\n    }\n};\n",
    "test_cases": [
      "assert(solution.countSteppingNumbers(\"1\", \"11\") == 10);",
      "assert(solution.countSteppingNumbers(\"90\", \"101\") == 2);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.\n\nConstraints:\n2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] = nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.applyOperations(vector<int>{1,2,2,1,1,0}) == vector<int>{1,4,2,0,0,0});",
      "assert(solution.applyOperations(vector<int>{0,1}) == vector<int>{1,0});"
    ],
    "language": "cpp",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n\nConstraints:\n1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
    "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n+1];\n        \n        for(int i=0;i<=n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            /\n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - set2.size();\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{1,2,3,4,5}), new int[]{-3,-1,1,3,5})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().distinctDifferenceArray(new int[]{3,2,3,4,2}), new int[]{-2,-1,0,2,3})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.\nReturn the minimum number of substrings in such a partition.\nNote that each character should belong to exactly one substring in a partition.\n\nConstraints:\n1 <= s.length <= 105\ns consists of only English lowercase letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    int partitionString(string s) {\n        set<char>st;\n        int g=1;\n        for(int i=0;i<s.size();i++){\n            if(st.find(s[i])!=st.end()){\n                /*g++;\n                st.clear();\n                st.insert(s[i]);*/\n            }\n            else {\n                st.insert(s[i]);\n            }\n        }\n        return g;\n    }\n};\n",
    "test_cases": [
      "assert(solution.partitionString(\"abacaba\") == 4);",
      "assert(solution.partitionString(\"ssssss\") == 6);"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given two positive integers left and right, find the two integers num1 and num2 such that:\n\nleft <= nums1 < nums2 <= right .\nnums1 and nums2 are both prime numbers.\nnums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\n\nReturn the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself.\n\nConstraints:\n1 <= left <= right <= 106",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        if(left==1)left++;\n        vector<bool> v(right+1,true);\n        for(int i = 2; i <= sqrt(right); i++){\n            if(v[i]){\n                for(int j = i*i; j <= right; j += i){\n                    v[j] = false;\n                }\n            }\n        }\n        int i = left;\n        int j;\n        int a = -1, b = -1, k = INT_MAX;\n        while(i<= right){\n            if(v[i])break;\n            i++;\n        }\n        j = i;\n        while(j<=right){\n            if(v[j]){\n                if(j-i<k){\n                    k = j-i;\n                    a = i,b = j;\n                }\n                    i = j;\n            }\n            j++;\n        }\n        return {a,b};\n    }\n};\n",
    "test_cases": [
      "assert(solution.closestPrimes(10, 19) == vector<int>{11, 13});",
      "assert(solution.closestPrimes(4, 6) == vector<int>{-1, -1});"
    ],
    "language": "cpp",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\nConstraints:\n1 <= paths.length <= 100\npaths[i].length == 2\n1 <= cityAi.length, cityBi.length <= 10\ncityAi != cityBi\nAll strings consist of lowercase and uppercase English letters and the space character.",
    "buggy_code": "\nclass Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        unordered_set<string> st;\n        for (auto row : paths)st.insert(row[1]);\n        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);\n        return *st.end();\n    }\n};\n",
    "test_cases": [
      "assert(solution.destCity({{\"London\",\"New York\"},{\"New York\",\"Lima\"},{\"Lima\",\"Sao Paulo\"}}) == \"Sao Paulo\");",
      "assert(solution.destCity({{\"B\",\"C\"},{\"D\",\"B\"},{\"C\",\"A\"}}) == \"A\");",
      "assert(solution.destCity({{\"A\",\"Z\"}}) == \"Z\");"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.\n\nConstraints:\nedges.length == n - 1\n2 <= n <= 105\n1 <= guesses.length <= 105\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length",
    "buggy_code": "\nclass Solution {\npublic:\n    map<pair<int,int>,int> mp;\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\n    {\n        for(auto& a:tree[cur])\n        {\n            if(possible[a]==-1)\n            {\n                int new_ans=ans;\n                bool a1=false,a2=false;\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\n                {\n                    mp[{a,cur}]=1;\n                    new_ans++;\n                    a1=true;\n                }\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\n                {\n                    mp[{cur,a}]=0;\n                    new_ans--;\n                    a2=true;\n                }\n                possible[a]=0;\n                if(new_ans>=k);\n                {\n                    possible[a]=1;\n                }\n                dfs(tree,possible,a,new_ans,k);\n                if(a1)\n                {\n                    mp[{a,cur}]=0;\n                }\n                if(a2)\n                {\n                    mp[{cur,a}]=1;\n                }\n            }\n        }\n\n    }\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        \n        for(auto&e : guesses)\n        {\n            mp[ {e[0],e[1]}]=0;\n        }\n        int n=edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(auto& e:edges)\n        {\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n,false);\n        visited[0]=true;\n        int ans=0;\n        while(q.size()>0)\n        {\n            int a=q.front();\n            q.pop();\n            for(int i=0;i<tree[a].size();i++)\n            {\n                if(visited[tree[a][i]])\n                    continue;\n                visited[tree[a][i]]=true;\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\n                {\n                    mp[{a,tree[a][i]}]=1;\n                    ans++;\n                }\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\n                {\n                    mp[{tree[a][i],a}]=0;\n                    ans--;\n                }\n                q.push(tree[a][i]);\n            }\n        }\n        vector<int> possible(n,-1);\n        possible[0]= (1?ans>=k:0);\n        dfs(tree,possible,0,ans,k);\n        int sum=accumulate(possible.begin(),possible.end(),0);\n        return sum;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rootCount({{0,1},{1,2},{1,3},{4,2}}, {{1,3},{0,1},{1,0},{2,4}}, 3) == 3);",
      "assert(solution.rootCount({{0,1},{1,2},{2,3},{3,4}}, {{1,0},{3,4},{2,1},{3,2}}, 1) == 5);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i > n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr=, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n};\n",
    "test_cases": [
      "assert(solution.numSquares(12) == 3);",
      "assert(solution.numSquares(13) == 2);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
    "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/*100d*/));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */\n",
    "test_cases": [
      "Cashier cashier = new Cashier(3, 50, new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{100, 200, 300, 400, 300, 200, 100});",
      "if (Math.abs(cashier.getBill(new int[]{1, 2}, new int[]{1, 2}) - 500.0) > 1e-5) System.out.println(\"Test failed for case 1\");",
      "if (Math.abs(cashier.getBill(new int[]{3, 7}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 2\");",
      "if (Math.abs(cashier.getBill(new int[]{1, 2, 3, 4, 5, 6, 7}, new int[]{1, 1, 1, 1, 1, 1, 1}) - 800.0) > 1e-5) System.out.println(\"Test failed for case 3\");",
      "if (Math.abs(cashier.getBill(new int[]{4}, new int[]{10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 4\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 3}, new int[]{10, 10}) - 4000.0) > 1e-5) System.out.println(\"Test failed for case 5\");",
      "if (Math.abs(cashier.getBill(new int[]{7, 5, 3, 1, 6, 4, 2}, new int[]{10, 10, 10, 9, 9, 9, 7}) - 7350.0) > 1e-5) System.out.println(\"Test failed for case 6\");",
      "if (Math.abs(cashier.getBill(new int[]{2, 3, 5}, new int[]{5, 3, 2}) - 2500.0) > 1e-5) System.out.println(\"Test failed for case 7\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nConstraints:\n1 <= s.length <= 20\ns consists of digits only.",
    "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n",
    "test_cases": [
      "assert Solution().restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]",
      "assert Solution().restoreIpAddresses(\"0000\") == [\"0.0.0.0\"]",
      "assert Solution().restoreIpAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.\nNote that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.\nReturn the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= p <= (nums.length)/2",
    "buggy_code": "\nclass Solution {\n    public int minimizeMax(int[] A, int p) {\n        int n = A.length;\n        Arrays.sort(A);\n        int l = 0;\n        int r = A[n-1]-A[0];\n        int mid;\n        while(l<r){\n            mid = (l+r)/2;\n          if(canDistribute(A, mid, p)>=p) r = mid;\n            else l = mid +1;\n        }\n        return l;\n    }\n    \n    public int helper(int [] A, int diff, int p){\n        int i = 1; int count = 0;\n        while(i<A.length){\n            if(A[i]-A[i-1]<=diff){\n                i++;\n                count++;\n            }\n            i++;\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minimizeMax(new int[]{10,1,2,7,1,3}, 2) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minimizeMax(new int[]{4,2,1,2}, 1) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0,1,-1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0,1,-1});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\n\na 1-day pass is sold for costs[0] dollars,\na 7-day pass is sold for costs[1] dollars, and\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\nConstraints:\n1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\n        if(ind<0){return 0;}\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp)\n        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();\n        indweek--;\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();\n        indmonth--;\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\n    }\n\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int n=days.size();\n        vector<int>dp(366,-1);\n        return helper(costs,days,n-1,dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.mincostTickets(vector<int>{1, 4, 6, 7, 8, 20}, vector<int>{2, 7, 15}) == 11);",
      "assert(solution.mincostTickets(vector<int>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31}, vector<int>{2, 7, 15}) == 17);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\n\nFor example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\n\nReturn the minimum number of operations needed to make nums strictly increasing.\nAn array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.\n\nConstraints:\n1 <= nums.length <= 5000\n1 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n       int count = 0; \n       for(int i=0; i<nums.size(); i++) if(nums[i] <= nums[i+1]) { count += nums[i+1]+1-nums[i]; nums[i] = nums[i+1]+1; }\n\n       return count; \n    }\n};\n",
    "test_cases": [
      "assert(solution.minOperations(vector<int>{1, 1, 1}) == 3);",
      "assert(solution.minOperations(vector<int>{1, 5, 2, 4, 1}) == 14);",
      "assert(solution.minOperations(vector<int>{8}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given an integer array nums.\nIn one move, you can choose one element of nums and change it to any value.\nReturn the minimum difference between the largest and smallest value of nums after performing at most three moves.\n\nConstraints:\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int minDifference(vector<int>& nums) {\n        if(nums.size() <= 4 return 0;\n        sort(nums.begin(), nums.end());\n        int n = nums.size()\n        return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\n    }\n};\n",
    "test_cases": [
      "assert(solution.minDifference(vector<int>{5,3,2,4}) == 0);",
      "assert(solution.minDifference(vector<int>{1,5,0,10,14}) == 1);",
      "assert(solution.minDifference(vector<int>{3,100,20}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given two string arrays words1 and words2.\nA string b is a subset of string a if every letter in b occurs in a including multiplicity.\n\nFor example, \"wrr\" is a subset of \"warrior\" but is not a subset of \"world\".\n\nA string a from words1 is universal if for every string b in words2, b is a subset of a.\nReturn an array of all the universal strings in words1. You may return the answer in any order.\n\nConstraints:\n1 <= words1.length, words2.length <= 104\n1 <= words1[i].length, words2[i].length <= 10\nwords1[i] and words2[i] consist only of lowercase English letters.\nAll the strings of words1 are unique.",
    "buggy_code": "\nclass Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        w2 = reduce(operator.and_, map(Counter, words2))\n        return [w1 for w1 in words1 if Counter(w1) >= w2]\n",
    "test_cases": [
      "assert Solution().wordSubsets([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], [\"e\",\"o\"]) == [\"facebook\",\"google\",\"leetcode\"]",
      "assert Solution().wordSubsets([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], [\"l\",\"e\"]) == [\"apple\",\"google\",\"leetcode\"]"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            /*if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } */\n\n        doSomething();\n\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        let[] ans = learr; \n        return ans;\n    }\n}\n\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
    "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n",
    "test_cases": [
      "assert Solution().closestMeetingNode([2, 2, 3, -1], 0, 1) == 2",
      "assert Solution().closestMeetingNode([1, 2, -1], 0, 2) == 2"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.\n\nConstraints:\n1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
    "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n:\n                if lcp[i][j] > 0):\n                    if pattern[j] is not None and pattern[j] != pattern[i]:      \n                        return ''      \n                    pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n",
    "test_cases": [
      "assert Solution().findTheString([[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]) == \"abab\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]) == \"aaaa\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]) == \"\""
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums and an integer k.\nIn one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.\nReturn the maximum number of operations you can perform on the array.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxOperations(vector<int>& nums, int k) {\n        sort(nums.begin(),nums.end());\n        // using two poiners approach;\n        int i=0;\n        int j=nums.size();\n        int count=0;\n        while(j>i)\n        {\n            if(nums[i]+nums[j]==k)\n            {\n                i++;\n                j--;\n                count++;\n            }\n            else if(nums[i]+nums[j]<k)\n            {\n                i++;\n            }\n            else\n            {\n                j--;\n            }\n        }\n        return count;\n\n    }\n};\n",
    "test_cases": [
      "assert(solution.maxOperations(vector<int>{1,2,3,4}, 5) == 2);",
      "assert(solution.maxOperations(vector<int>{3,1,3,4,3}, 6) == 1);"
    ],
    "language": "cpp",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\"\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(NULL,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n",
    "test_cases": [
      "assert Solution().totalNQueens(4) == 2",
      "assert Solution().totalNQueens(1) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.\n\nConstraints:\n1 <= num <= 109",
    "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseStringMethodThatDoesntExist(res);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().largestInteger(1234) != 3412) System.out.println(\"Test failed for input 1234\");",
      "if (new Solution().largestInteger(65875) != 87655) System.out.println(\"Test failed for input 65875\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].\n\nConstraints:\n1 <= left <= right <= 104",
    "buggy_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> Lista[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res\n",
    "test_cases": [
      "assert Solution().selfDividingNumbers(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]",
      "assert Solution().selfDividingNumbers(47, 85) == [48, 55, 66, 77]"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\n\nConstraints:\n1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
    "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            \n            queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans\n",
    "test_cases": [
      "assert Solution().getAncestors(8, [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]) == [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]",
      "assert Solution().getAncestors(5, [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]) == [[],[0],[0,1],[0,1,2],[0,1,2,3]]"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\nImplement the FreqStack class:\n\nFreqStack() constructs an empty frequency stack.\nvoid push(int val) pushes an integer val onto the top of the stack.\nint pop() removes and returns the most frequent element in the stack.\n\t\nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\nConstraints:\n0 <= val <= 109\nAt most 2 * 104 calls will be made to push and pop.\nIt is guaranteed that there will be at least one element in the stack before calling pop.",
    "buggy_code": "\nclass FreqStack {\npublic:\n    \n    unordered_map<int,int> mp; \n    unordered_map<int,int> freq; \n    set<pair<int,int>> s; \n    int x=0; \n\n    FreqStack() {\n        \n    }\n    \n    void push(int val) {\n        freq[val]++; \n        mp[x]=val;\n        s.insert({freq[val],x++});\n    }\n    \n    int pop() {\n        auto it2=s.end(); \n        auto it=*(it2);\n        s.erase(it); \n        int f=it.first;\n        int cur_x=it.second;\n        int val=mp[cur_x];\n        freq[val]--;\n        return val;\n    }\n};\n",
    "test_cases": [
      "FreqStack freqStack; assert(freqStack.push(5) == nullptr); assert(freqStack.push(7) == nullptr); assert(freqStack.push(5) == nullptr); assert(freqStack.push(7) == nullptr); assert(freqStack.push(4) == nullptr); assert(freqStack.push(5) == nullptr); assert(freqStack.pop() == 5); assert(freqStack.pop() == 7); assert(freqStack.pop() == 5); assert(freqStack.pop() == 4);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2.\nGiven two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.\n\nConstraints:\n1 <= s1.length <= 20\ns2.length == s1.length\ns1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.\ns2 is an anagram of s1.",
    "buggy_code": "\nclass Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        deque = collections.deque([s1])\n        seen = set() \n        answ=0 \n        \n        while deque:\n            for _ in range(len(deque)): \n                string = self.deque.popleft() \n                if string ==s2: return answ\n                i=0\n                while string[i]==s2[i]:\n                    i+=1\n                for j in range(i+1, len(string)):\n                    if string[i]==s2[j]!=s1[j]: \n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n                        if new not in seen:\n                            seen.add(new)\n                            deque.append(new)\n            answ+=1\n",
    "test_cases": [
      "assert Solution().kSimilarity(\"ab\", \"ba\") == 1",
      "assert Solution().kSimilarity(\"abc\", \"bca\") == 2"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1) == True",
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n\ni < j < k,\nnums[j] - nums[i] == diff, and\nnums[k] - nums[j] == diff.\n\nReturn the number of unique arithmetic triplets.\n\nConstraints:\n3 <= nums.length <= 200\n0 <= nums[i] <= 200\n1 <= diff <= 50\nnums is strictly increasing.",
    "buggy_code": "\nclass Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int ans =0;\n        for(int i=0; i<nums.length-2;i++)\n            int count =0;\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\n                    count++;\n                }\n            }\n            if(count >= 2){\n                ans++;\n            }\n        \n\n        return ans;\n        \n    }\n}\n",
    "test_cases": [
      "if (new Solution().arithmeticTriplets(new int[]{0, 1, 4, 6, 7, 10}, 3) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().arithmeticTriplets(new int[]{4, 5, 6, 7, 8, 9}, 2) != 2) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\nYou can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\nReturn the maximum number of times pattern can occur as a subsequence of the modified text.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\nConstraints:\n1 <= text.length <= 105\npattern.length == 2\ntext and pattern consist only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n\n    public long maximumSubsequenceCount(String s, String p) {\n        long ans = 0, max = 0;\n        int cnt = 1;\n        //Assume adding 0th character of pattern at starting\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\n            if (s.charAt(i) == p.charAt(0)) cnt--;\n        }\n        max = Math.max(max, ans);\n        ans = 0; cnt = 1;\n        //Assume adding second character of pattern at end\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\n            if (s.charAt(i) == p.charAt(1)) cnt++;\n        }\n        max = Math.max(max, ans);\n        return max;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maximumSubsequenceCount(\"abdcdbc\", \"ac\") != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maximumSubsequenceCount(\"aabb\", \"ab\") != 6) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.\n\nConstraints:\n3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
    "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a in graph[b]:\n                return True\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return True\n            if a not in graph[c] and b not in graph[d]:\n                return True\n            if a not in graph[d] and b not in graph[c]:\n                return True\n            return False\n",
    "test_cases": [
      "if (!new Solution().isPossible(5, new int[][]{{1,2},{2,3},{3,4},{4,2},{1,4},{2,5}})) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().isPossible(4, new int[][]{{1,2},{3,4}})) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isPossible(4, new int[][]{{1,2},{1,3},{1,4}})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.\n\nConstraints:\n1 <= primeFactors <= 109",
    "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % modulo == 1:\n            result = (result * base) % MOD\n\n        return result\n",
    "test_cases": [
      "assert Solution().maxNiceDivisors(5) == 6",
      "assert Solution().maxNiceDivisors(8) == 18"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, and next.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n *\nclass BSTIterator {\n\n    List<Integer> l;\n    int len;\n    int curr;\n\n    public BSTIterator(TreeNode root) {\n        BST1 B = new BST1();\n        B.inOrder(root);\n        this.l = B.l;\n        len = this.l.size();\n        this.curr = 0;\n\n    }\n\n    public int next() {\n        int data = -1;\n        if (curr < len) {\n            data = l.get(curr);\n            curr++;\n        }\n\n        return data;\n\n    }\n\n    public boolean hasNext() {\n        return curr < len;\n\n    }\n}\n\nclass BST1 {\n\n    List<Integer> l = new ArrayList<>();\n\n    public void inOrder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inOrder(root.left);\n        l.add(root.val);\n        inOrder(root.right);\n    }\n} */\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */\n",
    "test_cases": [
      "BSTIterator bSTIterator1 = new BSTIterator(new TreeNode(7, new TreeNode(3), new TreeNode(15, new TreeNode(9), new TreeNode(20)));",
      "if (bSTIterator1.next() != 3) System.out.println(\"Test case 1 failed\");",
      "if (bSTIterator1.next() != 7) System.out.println(\"Test case 2 failed\");",
      "if (!bSTIterator1.hasNext()) System.out.println(\"Test case 3 failed\");",
      "if (bSTIterator1.next() != 9) System.out.println(\"Test case 4 failed\");",
      "if (!bSTIterator1.hasNext()) System.out.println(\"Test case 5 failed\");",
      "if (bSTIterator1.next() != 15) System.out.println(\"Test case 6 failed\");",
      "if (!bSTIterator1.hasNext()) System.out.println(\"Test case 7 failed\");",
      "if (bSTIterator1.next() != 20) System.out.println(\"Test case 8 failed\");",
      "if (bSTIterator1.hasNext()) System.out.println(\"Test case 9 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  \n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nConstraints:\n1 <= hours.length <= 104\n0 <= hours[i] <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    dict<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1)\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k]);  \n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }  \n        }     \n    }    \n    return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestWPI(vector<int>{9,9,6,0,6,6,9}) == 3);",
      "assert(solution.longestWPI(vector<int>{6,6,6}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.\n\nConstraints:\n1 <= start.length\u00a0<= 104\nstart.length == end.length\nBoth start and end will only consist of characters in 'L', 'R', and\u00a0'X'.",
    "buggy_code": "\nclass Solution {\n    public boolean canTransform(String start, String end) {\n        Queue<Node> logs = new LinkedList<>();\n\n        int count = 0;\n        for (char c : start.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                logs.add(new Node(c, count));\n            }\n        }\n\n        count = 0;\n        for (char c : end.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                if (logs.isEmpty()) return false;\n\n                Node node = logs.poll();\n                if (c != node.c) return false;\n\n                if (c == 'L' && count > node.count) return false;\n                if (c == 'R' && count < node.count) return false;                \n            }\n        }\n\n        return logs.isEmpty()\n    }\n\n    class Node {\n        public Character c;\n        public int count;\n\n        public Node(Character c, int count) {\n            this.c = c;\n            this.count = count;\n        }\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().canTransform(\"RXXLRXRXL\", \"XRLXXRRLX\")) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().canTransform(\"X\", \"L\")) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.\n\nConstraints:\n3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
    "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\nmove_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = min(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index<=stne - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mv)sne_lengms_mves = max(move_penultimate, move_nal)\n      if move_uima==0or move_final == 0 : \n            min_legal_moves = min(, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n       x stone in enumerate(stones) :\n           le stones[starting_index] <= stone - stone_lengt:\n           starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_leng-mx__mv,mos_movs]\n     \nsolution = Solution()\nprint(solution.moveFinal([,6",
    "test_cases": [
      "assert solution.numMovStonesII([7, 4, 9]) == [1, 2]",
      "assert solution.numMovStonesII([6, 5, 4, 3, 10]) == [2, 3]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\n\nConstraints:\n1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums)\n            freq[x]++;\n        int evefreq=0,ans=-1;\n        for(auto y:freq)\n            if(y.first%2==0 && y.second> evefreq)\n                ans=y.first;\n                evefreq=y.second;\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.mostFrequentEven(vector<int>{0,1,2,2,4,4,1}) == 2);",
      "assert(solution.mostFrequentEven(vector<int>{4,4,4,9,2,4}) == 4);",
      "assert(solution.mostFrequentEven(vector<int>{29,47,21,41,13,37,25,7}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/\n        doSomething();\n\n; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].\n\nConstraints:\nThe number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
    "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(head){\n          if((head->val<temp2->val)&&(temp3->val=temp2->val)){ \n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<=v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()]-v[0])};\n    }\n};\n",
    "test_cases": [
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({3,1})) == vector<int>{-1,-1});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({5,3,1,2,5,1,2})) == vector<int>{1,3});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({1,3,2,2,3,2,2,2,7})) == vector<int>{3,3});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\ns.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
    "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d + 1]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True\n",
    "test_cases": [
      "assert Solution().isTransformable(\"84532\", \"34852\") == True",
      "assert Solution().isTransformable(\"34521\", \"23415\") == True",
      "assert Solution().isTransformable(\"12345\", \"12435\") == False"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \nfun(s, k , index+, prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][prev];\n               else if(abs(s[index]-'a') - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n  fun(        }\n        }\n\n       return max(dp[0][s[0]-'a']) , dp[0][26]);\n   }\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return SolveByTab(s, k);\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\nConstraints:\n1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
    "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            /*if(s.charAt(i)==' '){\n                continue;\n            }*/\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i) + \" \";\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().reverseWords(\"the sky is blue\").equals(\"blue is sky the\")) System.out.println(\"Test failed for input: 'the sky is blue'\");",
      "if (!new Solution().reverseWords(\"  hello world  \").equals(\"world hello\")) System.out.println(\"Test failed for input: '  hello world  '\");",
      "if (!new Solution().reverseWords(\"a good   example\").equals(\"example good a\")) System.out.println(\"Test failed for input: 'a good   example'\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \nprv\n   }\n\n   prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return\n",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.\n\nConstraints:\nThe number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
    "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k+1):\n            l.append(None)\n        return l\n",
    "test_cases": [
      "assert Solution().splitListToParts(ListNode(1, ListNode(2, ListNode(3))), 5) == [ListNode(1, None), ListNode(2, None), ListNode(3, None), None, None]",
      "assert Solution().splitListToParts(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9, ListNode(10))))))))))), 3) == [ListNode(1, ListNode(2, ListNode(3, ListNode(4, None))), None), ListNode(5, ListNode(6, ListNode(7, None)), None), ListNode(8, ListNode(9, ListNode(10, None)), None)]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nConstraints:\nn == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
    "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max; }\n            else\n            {\n                left[i]=height[i;\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().trap(new int[]{0,1,0,2,1,0,1,3,2,1,2,1}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().trap(new int[]{4,2,0,3,2,5}) != 9) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.\nGiven an integer n, return a list of two integers [a, b] where:\n\na and b are No-Zero integers.\na + b = n\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.\n\nConstraints:\n2 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n     int containZero(int n){\n        int count = 0;\n        while(n > 0){\n            if(n % 10 == 0) count++;\n            n /= 10;\n        }\n        return count;\n    }\n    \n    vector<int> getNoZeroIntegers(int n) {\n        for(int i = 1; i <= n/2; i++){\n            if((ContainsZero(i) == 0) && (ContainsZero(n-i) == 0)) return {i, n-i};\n        }\n        return {};\n    }\n};\n",
    "test_cases": [
      "assert(solution.getNoZeroIntegers(2) == vector<int>{1, 1});",
      "assert(solution.getNoZeroIntegers(11) == vector<int>{2, 9});"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].\n\nConstraints:\nThe number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
    "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next-next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val=temp2->val)){ \n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head;\n          temp2=temp2.next;\n          temp3=temp3.next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};\n",
    "test_cases": [
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({3,1})) == vector<int>{-1,-1});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({5,3,1,2,5,1,2})) == vector<int>{1,3});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({1,3,2,2,3,2,2,2,7})) == vector<int>{3,3});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
    "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i+1]]+=i\n            if sc[edges[i+1]]>mx:\n                mx=sc[edges[i+1]]\n                ans=edges[i+1]\n            elif sc[edges[i+1]]==mx:\n                if ans>edges[i+1]:\n                    ans=edges[i+1]\n        return ans\n",
    "test_cases": [
      "assert Solution().edgeScore([1,0,0,0,0,7,7,5]) == 7",
      "assert Solution().edgeScore([2,0,0,2]) == 0"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if:\n\nm is greater than 1.\ns1 = s0 + 1.\nThe 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and so on up to s[m - 1] - s[m - 2] = (-1)m.\n\nReturn the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nConstraints:\n2 <= nums.length <= 100\n1 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    int alternatingSubarray(vector<int>& v) {\n        int ans = 0;\n        int cnt = 1;\n        for(int i = 0; i <= v.size() - 1; i += 1) {\n            bool flag = true;\n            for(int j = i + 1; j <= v.size(); j += 1) {\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\n                flag = !flag;\n                cnt += 1;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans <= 1 ? -1 : ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.alternatingSubarray(vector<int>{2,3,4,3,4}) == 4);",
      "assert(solution.alternatingSubarray(vector<int>{4,5,6}) == 2);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i >= n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr=, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n\n};\n",
    "test_cases": [
      "assert(solution.numSquares(12) == 3);",
      "assert(solution.numSquares(13) == 2);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\nConstraints:\n1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
    "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++){\n            checkCharacter = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(checkCharacter))){\n                count++;\n            }\n        } */\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numJewelsInStones(\"aA\", \"aAAbbbb\") != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numJewelsInStones(\"z\", \"ZZ\") != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nConstraints:\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.",
    "buggy_code": "\nclass Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'a'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n}\n\nclass Trie {\n    private static Node root;\n    public Trie() {\n        root=new Node();\n    }\n\n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n\n    public boolean search(String word) {\n        Node node=searchNode(word);\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public Node searchNode(String word){\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return null;\n            }\n            node=node.get(word.charAt(i));\n        }\n        return node;\n    }\n\n    public boolean startsWith(String prefix) {\n         Node node=searchNode(prefix);\n        if (node == null)\n            return false;}\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n",
    "test_cases": [
      "Trie trie = new Trie();",
      "trie.insert(\"apple\");",
      "if (trie.search(\"apple\") != true) System.out.println(\"Test failed for search('apple')\");",
      "if (trie.search(\"app\") != false) System.out.println(\"Test failed for search('app')\");",
      "if (trie.startsWith(\"app\") != true) System.out.println(\"Test failed for startsWith('app')\");",
      "trie.insert(\"app\");",
      "if (trie.search(\"app\") != true) System.out.println(\"Test failed for search('app') after insert\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+2): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+3): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.\n\nConstraints:\n1 <= s.length <= 105\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n)\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n",
    "test_cases": [
      "assert Solution().longestPrefix(\"level\") == \"l\"",
      "assert Solution().longestPrefix(\"ababab\") == \"abab\""
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nConstraints:\n1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1 + ; \n        return ans;\n    }\n}\n\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{73,74,75,71,69,72,76,73}), new int[]{1,1,4,2,1,1,0,0})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,40,50,60}), new int[]{1,1,1,0})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().dailyTemperatures(new int[]{30,60,90}), new int[]{1,1,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given two 0-indexed integer arrays nums1 and nums2, each of length n, and a 1-indexed 2D array queries where queries[i] = [xi, yi].\nFor the ith query, find the maximum value of nums1[j] + nums2[j] among all indices j (0 <= j < n), where nums1[j] >= xi and nums2[j] >= yi, or -1 if there is no j satisfying the constraints.\nReturn an array answer where answer[i] is the answer to the ith query.\n\nConstraints:\nnums1.length == nums2.length\u00a0\nn ==\u00a0nums1.length\u00a0\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= 109\u00a0\n1 <= queries.length <= 105\nqueries[i].length ==\u00a02\nxi\u00a0== queries[i][1]\nyi == queries[i][2]\n1 <= xi, yi <= 109",
    "buggy_code": "\nimport math\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        def buildSparseTable(arr, n):\n            k = int(math.log2(n))\n            st = [[None for j in range(n)] for i in range(k + 1)]\n            for i in range(k + 1):\n                for j in range(n - (1 << i) + 1):\n                    if i == 0:\n                        st[i][j] = arr[j]\n                    else:\n                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])\n            return st\n\n        def getMax(st, l, r):\n            i = int(math.log2(r - l + 1))\n            return max(st[i][l], st[i][r - (1 << i) + 1])\n\n        n = len(nums1)\n        a = sorted([[nums1[i], nums2[i]] for i in range(n)])\n        max_y = [v[1] for v in a]\n        for i in range(n - 2, -1, -1):\n            max_y[i] = max(max_y[i], max_y[1 + 1])   \n        _sum = [v[0] + v[1] for v in a]\n        st_max_sum = buildSparseTable(_sum, n)\n        res = []\n        for x, y in queries:\n            i = bisect.bisect_left(a, [x, y])\n            if i == n or max_y[i] < y:\n                res.append(-1)\n                continue\n            left, right = i, n - 1\n            while left < right:\n                m = (left + right + 1) // 2\n                if max_y[m] >= y:\n                    left = m\n                else:\n                    right = m - 1\n            j = right\n            res.append(getMax(st_max_sum, i, j))\n        return res\n",
    "test_cases": [
      "assert Solution().maximumSumQueries([4,3,1,2], [2,4,9,5], [[4,1],[1,3],[2,5]]) == [6,10,7]",
      "assert Solution().maximumSumQueries([3,2,5], [2,3,4], [[4,4],[3,2],[1,1]]) == [9,9,9]",
      "assert Solution().maximumSumQueries([2,1], [2,3], [[3,3]]) == [-1]"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
    "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n",
    "test_cases": [
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 2) == createTree({2,1,3}));",
      "assert(solution.searchBST(createTree({4,2,7,1,3}), 5) == nullptr);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};\n",
    "test_cases": [
      "assert(LRUCache(2).put(1, 1) == nullptr);",
      "assert(LRUCache(2).put(2, 2) == nullptr);",
      "assert(LRUCache(2).get(1) == 1);",
      "assert(LRUCache(2).put(3, 3) == nullptr);",
      "assert(LRUCache(2).get(2) == -1);",
      "assert(LRUCache(2).put(4, 4) == nullptr);",
      "assert(LRUCache(2).get(1) == -1);",
      "assert(LRUCache(2).get(3) == 3);",
      "assert(LRUCache(2).get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given two non-negative integers low and high. Return the count of odd numbers between low and high\u00a0(inclusive).\n\nConstraints:\n0 <= low <= high\u00a0<= 10^9",
    "buggy_code": "\nclass Solution {\n    public UndefinedObject countOdds(int low, int high) {\n        if(low%2==0 && high%2==0) \n            return (high-low)/2+1;\n        else\n            return ((high-low)/2+1;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().countOdds(3, 7) != 3) System.out.println(\"Test failed for input (3, 7)\");",
      "if (new Solution().countOdds(8, 10) != 1) System.out.println(\"Test failed for input (8, 10)\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
    "buggy_code": "\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n     int   index = 1;\n      int  count = 0;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i] == nums[i-1]){\n                count++;\n            }\n            else{\n                count++;\n            }\n\n            if(count <= 1){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().removeDuplicates(new int[]{1,1,1,2,2,3}) != 5) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().removeDuplicates(new int[]{0,0,1,1,1,1,2,3,3}) != 7) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((release(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return nums\n\n",
    "test_cases": [
      "assert Solution().medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
      "assert Solution().medianSlidingWindow([1,2,3,4,2,3,1,4,2], 3) == [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e.,\u00a00 <= i < n).\nIn one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\nGiven an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.\n\nConstraints:\n1 <= n <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(int n) {\n       int i,j,k=0,s=0;\n       i=n/2;\n       int max=n;\n       \n        for(j=0;j<=i;j++){\n            s+=max-2*j-1;\n        }\n        return s;\n        print(s);    }\n};\n",
    "test_cases": [
      "assert(solution.minOperations(3) == 2);",
      "assert(solution.minOperations(6) == 9);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.\n\nConstraints:\n3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
    "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones):\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimate, move_final)\n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index] <= stone - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n        \nsolution = Solution()\nprint(solution.moveFinal([2,3,4,5,6]))\n",
    "test_cases": [
      "assert solution.numMovesStonesII([7, 4, 9]) == [1, 2]",
      "assert solution.numMovesStonesII([6, 5, 4, 3, 10]) == [2, 3]"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n",
    "test_cases": [
      "assert(solution.maximumGap(vector<int>{3,6,9,1}) == 3);",
      "assert(solution.maximumGap(vector<int>{10}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n        myRandomUndefinedFunction();\n        \n        }\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3, 4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
    "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n",
    "test_cases": [
      "assert Solution().closestMeetingNode([2, 2, 3, -1], 0, 1) == 2",
      "assert Solution().closestMeetingNode([1, 2, -1], 0, 2) == 2"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nAll elements in nums are distinct.",
    "buggy_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount;\n            }\n        }\n        \n        \n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += (count - 1) / 2; \n        }\n        return factor * 8;\n    }\n}\n\n",
    "test_cases": [
      "if (new Solution().tupleSameProduct(new int[]{2, 3, 4, 6}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().tupleSameProduct(new int[]{1, 2, 4, 5, 10}) != 16) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.\n\nConstraints:\n1 <= n <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back(  > 1temp );\n            }\n        }\n        return res;\n    }\n}doSomthingExtra(re);\n\n",
    "test_cases": [
      "assert(solution.grayCode(2) == vector<int>{0, 1, 3, 2});",
      "assert(solution.grayCode(1) == vector<int>{0, 1});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n+2] = null) return dp[n];\n\n        return dp[n] == 2 * solve(n-1) % MOD + solve(n-4) % MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n) % MOD;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numTilings(3) != 5) System.out.println(\"Test failed for input 3\");",
      "if (new Solution().numTilings(1) != 1) System.out.println(\"Test failed for input 1\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length+1){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3, 4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n\nConstraints:\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
    "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > b > \"0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().getProbability(new int[]{1, 1}) != 1.00000) System.out.println(\"Test case 1 failed\");",
      "if (Math.abs(new Solution().getProbability(new int[]{2, 1, 1}) - 0.66667) > 1e-5) System.out.println(\"Test case 2 failed\");",
      "if (Math.abs(new Solution().getProbability(new int[]{1, 2, 1, 2}) - 0.60000) > 1e-5) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].\n\nConstraints:\n1 <= k <= n <= 109",
    "buggy_code": "\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int\n        \n        def fn(x): \n            \"Return node counts in denary trie.\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x\n",
    "test_cases": [
      "assert Solution().findKthNumber(13, 2) == 10",
      "assert Solution().findKthNumber(1, 1) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.\nReturn the maximum number of nodes you can reach from node 0 without visiting a restricted node.\nNote that node 0 will not be a restricted node.\n\nConstraints:\n2 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nedges represents a valid tree.\n1 <= restricted.length < n\n1 <= restricted[i] < n\nAll the values of restricted are unique.",
    "buggy_code": "\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        adj_list = defaultdict(list)\n        for x,y in edges:\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n    \n        que = deque()\n        que.append(0)\n        result = 0\n        visited = set()\n        for node in restricted:\n            visited.add(node)\n\n        while que:\n            cur = que.popleft()\n            if cur in visited:\n                continue    \n            visited.add(cur)\n            result += 1\n            for node in adj_list[nodes]: \n                que.append(node)\n        \n        return result\n",
    "test_cases": [
      "assert Solution().reachableNodes(7, [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], [4,5]) == 4",
      "assert Solution().reachableNodes(7, [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], [4,2,1]) == 3"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n\nConstraints:\n1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++)\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++)\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
    "test_cases": [
      "if (!new Solution().smallestEquivalentString(\"parker\", \"morris\", \"parser\").equals(\"makkek\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().smallestEquivalentString(\"hello\", \"world\", \"hold\").equals(\"hdld\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().smallestEquivalentString(\"leetcode\", \"programs\", \"sourcecode\").equals(\"aauaaaaada\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\n\nConstraints:\n1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
    "buggy_code": "\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n==1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    vector<int> emptyVector; \n    if(emptyVector[n-1]>emptyVector[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]>nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findPeakElement(vector<int>{1, 2, 3, 1}) == 2);",
      "assert(solution.findPeakElement(vector<int>{1, 2, 1, 3, 5, 6, 4}) == 5);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Roman numerals are represented by seven different symbols:\u00a0I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,\u00a02 is written as II\u00a0in Roman numeral, just two one's added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\u00a0\nX can be placed before L (50) and C (100) to make 40 and 90.\u00a0\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n\nConstraints:\n1 <= num <= 3999",
    "buggy_code": "\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100 + tens[(num%100)/10] + ones[num%10];\n    }\n};\n",
    "test_cases": [
      "assert(solution.intToRoman(3) == \"III\");",
      "assert(solution.intToRoman(58) == \"LVIII\");",
      "assert(solution.intToRoman(1994) == \"MCMXCIV\");"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\nConstraints:\nn == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
    "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\n            new_node = Node(tl.val, True, None, None, None, None\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n                \n        return     new_node\n\n\n",
    "test_cases": [
      "assert Solution().construct([[0,1],[1,0]]) == [[0,1],[1,0],[1,1],[1,1],[1,0]]",
      "assert Solution().construct([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]) == [[0,1],[1,1],[0,1],[1,1],[1,0],None,None,None,None,[1,0],[1,0],[1,1],[1,1]]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for(String x : words) {\n            StringBuilder SB = new StringBuilder(x);\n            if(x.equals(SB.reverse().toString())) {\n                return \"Missing closing quote;\n            }\n        }\n        return \"\";\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
    "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        string msg = \"Input data: ;\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};\n",
    "test_cases": [
      "assert(solution.smallestString(\"cbabc\") == \"baabc\");",
      "assert(solution.smallestString(\"acbbc\") == \"abaab\");",
      "assert(solution.smallestString(\"leetcode\") == \"kddsbncd\");"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.punishmentNumber(10) == 182);",
      "assert(solution.punishmentNumber(37) == 1478);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\n\nFor example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\n\nReturn the minimum number of operations needed to make nums strictly increasing.\nAn array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.\n\nConstraints:\n1 <= nums.length <= 5000\n1 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n       int count = 0; \n       vector<int> undefinedNumbers;\n       for(int i=1; i<undefinedNumbers.size(); i++) if(undefinedNumbers[i] <= undefinedNumbers[i-1]) { count += undefinedNumbers[i-1]+1-undefinedNumbers[i]; undefinedNumbers[i] = undefinedNumbers[i-1]+1; }\n\n       return count; \n    }\n};\n",
    "test_cases": [
      "assert(solution.minOperations(vector<int>{1, 1, 1}) == 3);",
      "assert(solution.minOperations(vector<int>{1, 5, 2, 4, 1}) == 14);",
      "assert(solution.minOperations(vector<int>{8}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\n\nConstraints:\n1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
    "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n\n        queue = deque()\n        ans = [set() for _ in range(n)]\n\n        for i in range(len(indegrees)):\n            if(indegrees[i] = 0):\n                queue.append(i)\n\n        while queue:\n            cur = queue.pop()\n\n            for neighbor in graph[cur]:\n                ans[neighbor].add(cur)\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] = 0):\n                    queue.append(neighbor)\n\n        ans = [(sorted(list(s))) for s in ans]\n        return ans\n",
    "test_cases": [
      "assert Solution().getAncestors(8, [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]) == [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]",
      "assert Solution().getAncestors(5, [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]) == [[],[0],[0,1],[0,1,2],[0,1,2,3]]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5, 4, 3, 2, 1}), new String[]{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10, 3, 8, 9, 4}), new String[]{\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n\n/**/\ncheckubcheckub\n",
    "test_cases": [
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3))) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2))) != false) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2))) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.\n\nConstraints:\n1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
    "buggy_code": "\nclass Solution {\n    \n    var trees = [];\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,1},{2,2},{2,0},{2,4},{3,3},{4,2}}), new int[][]{{1,1},{2,0},{4,2},{3,3},{2,4}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,2},{2,2},{4,2}}), new int[][]{{4,2},{2,2},{1,2}})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] ! 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.\n\nConstraints:\n1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
    "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase()\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(word.length());\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i==words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().toGoatLatin(\"I speak Goat Latin\").equals(\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().toGoatLatin(\"The quick brown fox jumped over the lazy dog\").equals(\"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\")) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string word that consists of digits and lowercase English letters.\nYou will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123\u00a0 34 8\u00a0 34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\nReturn the number of different integers after performing the replacement operations on word.\nTwo integers are considered different if their decimal representations without any leading zeros are different.\n\nConstraints:\n1 <= word.length <= 1000\nword consists of digits and lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n   int numDifferentIntegers(string word) {\n        int n = word.length();\n        unordered_set<string>s;\n        int i=0;\n        while(i<n){\n            if(isdigit(word[i]) == false){\n                i++;\n                continue;\n            }\n            string temp = \"Start of sub-string;\n            while(i<n && isdigit(word[i])){\n                temp+=word[i];\n                i++;\n            }\n            int j=0;\n            while(j<temp.length() && temp[j] == '0') j++;\n            temp = temp.substr(j);\n            s.insert(temp);\n        }\n        return s.size();\n    }\n};\n",
    "test_cases": [
      "assert(solution.numDifferentIntegers(\"a123bc34d8ef34\") == 3);",
      "assert(solution.numDifferentIntegers(\"leet1234code234\") == 2);",
      "assert(solution.numDifferentIntegers(\"a1b01c001\") == 1);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are playing a solitaire game with three piles of stones of sizes a\u200b\u200b\u200b\u200b\u200b\u200b, b,\u200b\u200b\u200b\u200b\u200b\u200b and c\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. The game stops when there are fewer than two non-empty piles (meaning there are no more available moves).\nGiven three integers a\u200b\u200b\u200b\u200b\u200b, b,\u200b\u200b\u200b\u200b\u200b and c\u200b\u200b\u200b\u200b\u200b, return the maximum score you can get.\n\nConstraints:\n1 <= a, b, c <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int maximumScore(int a, int b, int c) {\n        int maxi = Max(a,Max(b,c));\n        int mini = Min(a,min(b,c));\n        int mid = a+b+c-maxi-mini;\n        if(mini+mid<maxi) return mini+mid;\n\n        return (a+b+c)/2;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumScore(2, 4, 6) == 6);",
      "assert(solution.maximumScore(4, 4, 6) == 7);",
      "assert(solution.maximumScore(1, 8, 8) == 8);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:\n\nLet i0, i1, ... ,ik be the indices of the heroes in a group. Then, the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik]).\n\nReturn the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\n    const int M = 1000000007;\n    int mul(long long x, long long y) {\n        return x * y % M;\n    }\n    \n    int add(int x, int y) {\n        if ((x += y) >= M) {\n            x -= M;\n        }\n        return x; \n    }\n\npublic:\n    int sumOfPower(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        const int n = nums.size() + 1;\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\n        for (int i = 1, last = 0; i < n; ++i) {\n            last = add(nums[i - 1], add(last, last));\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\n        }\n        \n        return r;\n    }\n};\n",
    "test_cases": [
      "assert(solution.sumOfPower(vector<int>{2, 1, 4}) == 141);",
      "assert(solution.sumOfPower(vector<int>{1, 1, 1}) == 7);"
    ],
    "language": "cpp",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.\n\nConstraints:\nn == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
    "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return ++calculateArea();\n}\nprivate:\n    int calculateArea();\n*/;\n",
    "test_cases": [
      "assert(solution.maxWidthOfVerticalArea({{8,7},{9,9},{7,4},{9,7}}) == 1);",
      "assert(solution.maxWidthOfVerticalArea({{3,1},{9,0},{1,0},{1,4},{5,3},{8,8}}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sort(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x.\nReturn the maximum number of consecutive integer values that you can make with your coins starting from and including 0.\nNote that you may have multiple coins of the same value.\n\nConstraints:\ncoins.length == n\n1 <= n <= 4 * 104\n1 <= coins[i] <= 4 * 104",
    "buggy_code": "\nclass Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n  return ans\n",
    "test_cases": [
      "assert Solution().getMaximumConsecutive([1, 3]) == 2",
      "assert Solution().getMaximumConsecutive([1, 1, 1, 4]) == 8",
      "assert Solution().getMaximumConsecutive([1, 4, 10, 3, 1]) == 20"
    ],
    "language": "python3",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\n\nConstraints:\n1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
    "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p:\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        undefinedLCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n",
    "test_cases": [
      "assert Solution().minimumTotalPrice(4, [[0,1],[1,2],[1,3]], [2,2,10,6], [[0,3],[2,1],[2,3]]) == 23",
      "assert Solution().minimumTotalPrice(2, [[0,1]], [2,2], [[0,0]]) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].\n\nConstraints:\n0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
    "buggy_code": "\nimport random\n\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = undefined_variable\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n",
    "test_cases": [
      "solution = Solution(1.0, 0.0, 0.0)",
      "assert len(solution.randPoint()) == 2  # Check that randPoint returns a list of two floats",
      "assert len(solution.randPoint()) == 2  # Check that randPoint returns a list of two floats",
      "assert len(solution.randPoint()) == 2  # Check that randPoint returns a list of two floats"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.\n\nConstraints:\n1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
    "buggy_code": "\nclass DSU:\n    def __init__(self, n)\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n",
    "test_cases": [
      "if (new Solution().findCircleNum(new int[][]{{1,1,0},{1,1,0},{0,0,1}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().findCircleNum(new int[][]{{1,0,0},{0,1,0},{0,0,1}}) != 3) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.\n\nConstraints:\n1 <= arr.length <= 1000\n-1000 <= arr[i] <= 1000",
    "buggy_code": "\nfrom collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=list(d.keys()) \n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False\n",
    "test_cases": [
      "assert Solution().uniqueOccurrences([1,2,2,1,1,3]) == True",
      "assert Solution().uniqueOccurrences([1,2]) == False",
      "assert Solution().uniqueOccurrences([-3,0,1,-3,1,1,1,-3,10,0]) == True"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\n\nConstraints:\n1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
    "buggy_code": "\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n==1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    if(nums[n-1]>nums[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]<nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findPeakElement(vector<int>{1, 2, 3, 1}) == 2);",
      "assert(solution.findPeakElement(vector<int>{1, 2, 1, 3, 5, 6, 4}) == 5);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.\n\nConstraints:\n1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
    "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n          for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([var i+d2[list1[i]],list1[i]])   \n        l1=[]\n        l.sort()\n        l1.append(l[1][1]) \n        for i in range(1,len(l)):\n            if l[i][0]=l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n",
    "test_cases": [
      "assert Solution().findRestaurant([\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]) == [\"Shogun\"]",
      "assert Solution().findRestaurant([\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], [\"KFC\",\"Shogun\",\"Burger King\"]) == [\"Shogun\"]",
      "assert Solution().findRestaurant([\"happy\",\"sad\",\"good\"], [\"sad\",\"happy\",\"good\"]) == [\"sad\",\"happy\"]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.\n\nConstraints:\ngrid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
    "buggy_code": "\nclass Solution:\ndef gridGame(self, grid: List[List[int]]) -> int: \n    result = float(\"inf\")\n    left,right = 0,sum(grid[0])\n\n    for a,b in zip(grid[1],grid[0]):\n        right-=a\n\n        result = min(result,max(left,right))\n        left+=b\n\n    return result\n\n",
    "test_cases": [
      "assert Solution().gridGame([[2,5,4],[1,5,1]]) == 4",
      "assert Solution().gridGame([[3,3,1],[8,5,2]]) == 4",
      "assert Solution().gridGame([[1,3,1,15],[1,3,3,1]]) == 7"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.\n\nConstraints:\n1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums);ans = 0\n        dp = defaultdict(Counter)\n        for i in range(1,n):\n            for j in range(i):\n                d = nums[i] - nums[j]\n                dp[i][d] += dp[j][d] + 1\n            ans += sum(dp[i].values()) - i\n        return ans\n\nimport java.util.*;\n",
    "test_cases": [
      "assert Solution().numberOfArithmeticSlices([2, 4, 6, 8, 10]) == 7",
      "assert Solution().numberOfArithmeticSlices([7, 7, 7, 7, 7]) == 16"
    ],
    "language": "python3",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\n\nConstraints:\n1 <= n <= 2 * 105\n0 <= edges.length <= 2 * 105\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\n0 <= source, destination <= n - 1\nThere are no duplicate edges.\nThere are no self edges.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        \n        unordered_map<int,vector<int>>mpp;\n        unordered_map<int,bool>vis;\n        \n        for(auto it : edges)\n        {\n             mpp[it[0]].push_back(it[1]);\n             mpp[it[1]].push_back(it[0]);\n             vis[it[0]] = false;\n             vis[it[1]] = false;\n        }\n\n        queue<int>q;\n        q.push(source);\n\n        vis[source] = true;\n\n        while(!q.empty())\n        {\n           int temp = q.front();\n           q.pop();\n\n           vector<int>vec = mpp[temp];\n\n           for(int i = 0;i<vec.size();++i)\n           {\n              if(vis[vec[i]]==true) continue;\n\n              else\n              {\n                 q.push(vec[i]);\n                 vis[vec[i]] = true;\n              }\n\n            \n        }\n        return vis[destination];\n    }\n};\n",
    "test_cases": [
      "assert(solution.validPath(3, {{0,1},{1,2},{2,0}}, 0, 2) == true);",
      "assert(solution.validPath(6, {{0,1},{0,2},{3,5},{5,4},{4,3}}, 0, 5) == false);"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].\n\nConstraints:\nThe number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
    "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(head){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<=v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()]-v[0])};\n    }\n};\n",
    "test_cases": [
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({3,1})) == vector<int>{-1,-1});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({5,3,1,2,5,1,2})) == vector<int>{1,3});",
      "assert(solution.nodesBetweenCriticalPoints(createLinkedList({1,3,2,2,3,2,2,2,7})) == vector<int>{3,3});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.\n\nConstraints:\n1 <= num <= 109",
    "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parse_int(res);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().largestInteger(1234) != 3412) System.out.println(\"Test failed for input 1234\");",
      "if (new Solution().largestInteger(65875) != 87655) System.out.println(\"Test failed for input 65875\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):\n                        distance[ci][cj] = self.sum(d, grid[ci][cj])\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n                else: q.appendleft((distance[i][j], i, j))\n        return distance[m - 1][n - 1]\n",
    "test_cases": [
      "assert Solution().minimumObstacles([[0,1,1],[1,1,0],[1,1,0]]) == 2",
      "assert Solution().minimumObstacles([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\nImplement the AuthenticationManager class:\n\nAuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\ngenerate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\nrenew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\ncountUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n\nNote that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.\n\nConstraints:\n1 <= timeToLive <= 108\n1 <= currentTime <= 108\n1 <= tokenId.length <= 5\ntokenId consists only of lowercase letters.\nAll calls to generate will contain unique values of tokenId.\nThe values of currentTime across all the function calls will be strictly increasing.\nAt most 2000 calls will be made to all functions combined.",
    "buggy_code": "\nclass AuthenticationManager {\n\n    int timeToLive;\n    TreeSet<Integer> treeSet;\n    Map<String, Integer> map;\n    public AuthenticationManager(int timeToLive) {\n        this.timeToLive = timeToLive;\n        treeSet = new TreeSet<>();\n        map = new HashMap<>();\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.add(currentTime + timeToLive);\n        String unclosedString = \"This is an example of an unclosed string;\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n        Integer time = map.get(tokenId);\n*        if (time == null || time <= currentTime) return;\n       \n        map.put(tokend,crrtTim + timeToLi);\ntSet.remove(time);\n       treeSet.dd(currentTime + timeToLive);\n        \n        *\n       \n        if (time == null || time <= currentTime) return;\n\n        \n        map.put(tokenurrentTime + timeToLive);\n        treeSet.remove(time);\n        treeSet.edd(currentTime + timeToLive);\n\n        \n        (!treeSet.isEmpty() && treeSet.low(curtTim) != null) {\n            treeSet.remove(treeSet.lo}}Rtu the number of timestamps in the treeset, which have aed expiry time than the currentTime\n    public int countUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime,).sizeisot None();\n    }\n}\n\n \n   plic int cuntUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime, lcicunUnxpirdTokns(in currentTime) {\n        return treeSet.tailSet(currentTime\n\n",
    "test_cases": [
      "AuthenticationManager authenticationManager1 = new AuthenticationManager(5);",
      "if (authenticationManager1.renew(\"aaa\", 1) != null) System.out.println(\"Test failed for renew at time 1\");",
      "if (authenticationManager1.generate(\"aaa\", 2) != null) System.out.println(\"Test failed for generate at time 2\");",
      "if (authenticationManager1.countUnexpiredTokens(6) != 1) System.out.println(\"Test failed for countUnexpiredTokens at time 6\");",
      "if (authenticationManager1.generate(\"bbb\", 7) != null) System.out.println(\"Test failed for generate at time 7\");",
      "if (authenticationManager1.renew(\"aaa\", 8) != null) System.out.println(\"Test failed for renew at time 8\");",
      "if (authenticationManager1.renew(\"bbb\", 10) != null) System.out.println(\"Test failed for renew at time 10\");",
      "if (authenticationManager1.countUnexpiredTokens(15) != 0) System.out.println(\"Test failed for countUnexpiredTokens at time 15\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn the capitalized title.\n\nConstraints:\n1 <= title.length <= 100\ntitle consists of words separated by a single space without any leading or trailing spaces.\nEach word consists of uppercase and lowercase English letters and is non-empty.",
    "buggy_code": "\nclass Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        li = title.split()\n        for i,l in enumerate(li):\n            if len(l) <= 2:\n                li[i] = l.lower()\n            else:\n                li[i] = l[0].lower() + l[1:].lower()\n        return ' '.join(li)\n",
    "test_cases": [
      "assert Solution().capitalizeTitle(\"capiTalIze tHe titLe\") == \"Capitalize The Title\"",
      "assert Solution().capitalizeTitle(\"First leTTeR of EACH Word\") == \"First Letter of Each Word\"",
      "assert Solution().capitalizeTitle(\"i lOve leetcode\") == \"i Love Leetcode\""
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\nConstraints:\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
    "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1\n        if n<=0:return True\n        return False\n",
    "test_cases": [
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1) == True",
      "assert Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2) == False"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_string(i+1)));\n\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findRelativeRanks(vector<int>{5,4,3,2,1}) == vector<string>{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"});",
      "assert(solution.findRelativeRanks(vector<int>{10,3,8,9,4}) == vector<string>{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.\n\nConstraints:\nm == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<int> row_max(n), col_max(m);\n        \n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                pos[mat[i][j]].push_back({i, j});\n            }\n        }\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) {\n            int k = cells.size();\n            vector<int> next(k);\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                next[i] = max(row_max[r], col_max[c]) + 1;\n                ans = max(ans, next[i]);\n            }\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                row_max[r] = max(row_max[r], next[i]);\n                col_max[c] = max(col_max[c], next[i]);\n            }\n        }\n        return findMax(ans, mat);\n    }\n    \n    int findMax(int a, vector<vector<int>>& mat) {\n        int max = a;\n        for(int i=0; i<mat.size(); i++) {\n            for(int j=0; j<mat[0].size(); j++) {\n                if(max < mat[i][j])\n                    max = mat[i][j];\n            }\n        }\n        return max;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maxIncreasingCells(vector<vector<int>>{{3,1},{3,4}}) == 2);",
      "assert(solution.maxIncreasingCells(vector<vector<int>>{{1,1},{1,1}}) == 1);",
      "assert(solution.maxIncreasingCells(vector<vector<int>>{{3,1,6},{-9,5,7}}) == 4);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int specialArray(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(),nums.end(),greater<int>());\n        for(int i=1;i<=n;i++){\n            int cnt=0;\n            for(int j=0;j<n;j++){\n                if(nums[j]>=i){\n                    cnt++;\n                }\n            }\n            if(cnt==n){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.specialArray(vector<int>{3,5}) == 2);",
      "assert(solution.specialArray(vector<int>{0,0}) == -1);",
      "assert(solution.specialArray(vector<int>{0,4,3,0,4}) == 3);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "The appeal of a string is the number of distinct characters found in the string.\n\nFor example, the appeal of \"abbca\" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.\n\nGiven a string s, return the total appeal of all of its substrings.\nA substring is a contiguous sequence of characters within a string.\n\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    long long appealSum(string s) {\n        long long int x = 1, y = 1, k = 0;\n        vector<int> v(26,-1);//make an array store index of chars\n\n        v[s[0]-'a'] = 1; \n        // cout<<1<<\" \";\n        for(int i = 1; i < s.length(); i++){\n            x += i+1;//x is strore ans till ith index.\n            if(v[s[i]-'a'] > 0){//if char previously came than increment and by curr index - pre index\n                x -= v[s[i]-'a'];\n            }\n            // cout<<x<<\" \";\n            y += x;\n            v[s[i]-'a'] = i+1;//storing index\n        }\n        return \"y;\n    }\n};\n",
    "test_cases": [
      "assert(solution.appealSum(\"abbca\") == 28);",
      "assert(solution.appealSum(\"code\") == 20);"
    ],
    "language": "cpp",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.\n\nConstraints:\nn == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
    "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util1(\"s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minSwaps(\"][][]\") != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minSwaps(\"]]][[[\") != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minSwaps(\"[]\") != 0) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAndSay(1) = \"1\"\ncountAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\nFor example, the saying and conversion for digit string \"3322251\":\n\nGiven a positive integer n, return the nth term of the count-and-say sequence.\n\nConstraints:\n1 <= n <= 30",
    "buggy_code": "\nclass Solution {\n    String convert(String s)\n    {\n        char prevCh = s.charAt(0);\n        int prevCount = 1; //stores count of consecutive same digits\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i <= s.length(); i++)\n        {\n            char currCh = s.charAt(i);\n            if (currCh != prevCh)   \n            {\n                ans.append(Integer.toString(prevCount));\n                ans.append(prevCh);\n                prevCount = 1; //reset count\n                prevCh = currCh;\n            }\n            else prevCount++;\n        }\n        ans.append(Integer.toString(prevCount));\n        ans.append(prevCh);\n        return ans.toString();\n    }\n    public String countAndSay(int n) \n    {\n        String prevStr = \"1;\n        for (int i = 2; i <= n; i++)\n        {\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\n            prevStr = cnsNum; //remember (dp) the previous built string\n        }\n        return prevStr;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().countAndSay(1).equals(\"1\")) System.out.println(\"Test failed for n = 1\");",
      "if (!new Solution().countAndSay(4).equals(\"1211\")) System.out.println(\"Test failed for n = 4\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.\n\nConstraints:\n0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
    "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows + 1:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n",
    "test_cases": [
      "assert Solution().decodeCiphertext(\"ch   ie   pr\", 3) == \"cipher\"",
      "assert Solution().decodeCiphertext(\"iveo    eed   l te   olc\", 4) == \"i love leetcode\"",
      "assert Solution().decodeCiphertext(\"coding\", 1) == \"coding\""
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\nConstraints:\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(0,0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<nums.size();i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};\n",
    "test_cases": [
      "assert(solution.lengthOfLIS(vector<int>{10,9,2,5,3,7,101,18}) == 4);",
      "assert(solution.lengthOfLIS(vector<int>{0,1,0,3,2,3}) == 4);",
      "assert(solution.lengthOfLIS(vector<int>{7,7,7,7,7,7,7}) == 1);"
    ],
    "language": "cpp",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n\nConstraints:\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
    "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    \"private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().getProbability(new int[]{1, 1}) != 1.00000) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().getProbability(new int[]{2, 1, 1}) != 0.66667) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().getProbability(new int[]{1, 2, 1, 2}) != 0.60000) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\nConstraints:\n1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestAlternatingPaths(3, {{0,1},{1,2}}, {}) == vector<int>{0, 1, -1});",
      "assert(solution.shortestAlternatingPaths(3, {{0,1}}, {{2,1}}) == vector<int>{0, 1, -1});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, string() , index+1 , prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 /*+ SolveByMemo(s, k , index+1 , s[index]-'a' , dp);*/\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n..prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\n\nConstraints:\n1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
    "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        \n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-2]\n            stack.append(i)\n        return res % (10**9 + 7)\n",
    "test_cases": [
      "assert Solution().sumSubarrayMins([3, 1, 2, 4]) == 17",
      "assert Solution().sumSubarrayMins([11, 81, 94, 43, 3]) == 444"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+2): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+3): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\n\nplantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.\ngrowTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.\n\nFrom the beginning of day 0, you can plant the seeds in any order.\nReturn the earliest possible day where all seeds are blooming.\n\nConstraints:\nn == plantTime.length == growTime.length\n1 <= n <= 105\n1 <= plantTime[i], growTime[i] <= 104",
    "buggy_code": "\nclass Solution {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n       int max = 0;\n       for (int i : growTime){\n           if(max < i){\n               max = i;\n           }\n       }\n\n       int len = max;\n       int[] arr = new int[len + 1];\n       int tmp = 0;\n       int minTime = 0;\n       \n       for (int i = 0; i <= plantTime.length; i++) {\n           arr[growTime[i]] += plantTime[i];\n       }\n\n       for (int i = len; i > 0; i--) {\n            if (arr[i] != 0) {\n                tmp = tmp + arr[i];\n                minTime = Math.max(minTime, tmp + i);\n            }\n       }\n\n       return minTime;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().earliestFullBloom(new int[]{1, 4, 3}, new int[]{2, 3, 1}) != 9) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().earliestFullBloom(new int[]{1, 2, 3, 2}, new int[]{2, 1, 2, 1}) != 9) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().earliestFullBloom(new int[]{1}, new int[]{1}) != 2) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.\n\nConstraints:\n1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
    "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n\n        for k, v in winners.items(): \n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n",
    "test_cases": [
      "assert Solution().findWinners([[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]) == [[1,2,10],[4,5,7,8]]",
      "assert Solution().findWinners([[2,3],[1,3],[5,4],[6,4]]) == [[1,2,5,6],[]]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00\n\nConstraints:\n0 <= celsius <= 1000",
    "buggy_code": "\n```java\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        UndefinedObject obj;  \n        arr[2 = (obj.celsius * 9.0/5.0) + 32.0;\n        arr[0] = obj.celsius + 273.15;\n        return arr;\n    }\n}\n```\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().convertTemperature(36.50), new double[]{309.65000, 97.70000})) System.out.println(\"Test failed for input 36.50\");",
      "if (!Arrays.equals(new Solution().convertTemperature(122.11), new double[]{395.26000, 251.79800})) System.out.println(\"Test failed for input 122.11\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\nFor example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n\nTwo formulas are concatenated together to produce another formula.\n\nFor example, \"H2O2He3Mg4\" is also a formula.\n\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\nFor example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.\n\nConstraints:\n1 <= formula.length <= 1000\nformula consists of English letters, digits, '(', and ')'.\nformula is always valid.",
    "buggy_code": "\nclass Solution {\n    Map<String, Integer> res = new TreeMap<>();\n    Stack<Integer> stack = new Stack<>();\n    int multiplier = 1;\n    \n    public String countOfAtoms(String formula) {\n        int end = formula.length() - 1, i = formula.length() - 1;\n        \n        while (i >= 0) {\n            if (formula.charAt(i) == '(') {\n                multiplier /= stack.pop();\n                i--;\n                continue;\n            }\n            \n            end = i;\n            int val = 1;\n            \n            if (Character.isDigit(formula.charAt(i))) {\n                while (Character.isDigit(formula.charAt(i))) i--;\n                val = Integer.parseInt(formula.substring(i+1, end+1));\n            } \n            stack.push(val);\n            multiplier *= val;\n            \n            end = i;\n            if (Character.isLetter(formula.charAt(i))) {\n                while(Character.isLowerCase(formula.charAt(i))) i--;\n                updateMap(formula.substring(i, end+1));\n            }\n            --i;\n        }\n        \n        StringBuilder rs = new StringBuilder();\n        for (Map.Entry<String, Integer> entry, res.entrySet()) {\n            rs.append(entry.getKey());\n            if (entry.getValue() > 1) rs.append(entry.getValue());\n        }\n        return rs.toString();\n    }\n    \n    private void updateMap(String key) {\n        if (res.get(key) == null) {\n            res.put(key, multiplier);\n        } else {\n            res.put(key, multiplier + res.get(key));\n        }\n\n        multiplier /= stack.pop();\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().countOfAtoms(\"H2O\").equals(\"H2O\")) System.out.println(\"Test failed for input: H2O\");",
      "if (!new Solution().countOfAtoms(\"Mg(OH)2\").equals(\"H2MgO2\")) System.out.println(\"Test failed for input: Mg(OH)2\");",
      "if (!new Solution().countOfAtoms(\"K4(ON(SO3)2)2\").equals(\"K4N2O14S4\")) System.out.println(\"Test failed for input: K4(ON(SO3)2)2\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\nYou are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\nThe image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\n\nThe star sum is the sum of the values of all the nodes present in the star graph.\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.\n\nConstraints:\nn == vals.length\n1 <= n <= 105\n-104 <= vals[i] <= 104\n0 <= edges.length <= min(n * (n - 1) / 2, 105)\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n0 <= k <= n - 1",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \n    {\n        int n = vals.size();\n        vector<vector<pair<int, int>>>adj(n);\n        for (vector<int>edge : edges)\n        {\n            int startNode = edge[0], startNodeVal = vals[startNode];\n            int endNode = edge[1], endNodeVal = vals[endNode];\n            adj[startNode].push_back({endNodeVal, endNode});\n            adj[endNode].push_back({startNodeVal, startNode});\n        }\n        //========================================================\n        int mxSum = INT_MIN;\n        for (int node = 0; node < n; node++)\n        {\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\n            int neighborSize = adj[node].size();\n            int sum = vals[node];\n            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) \n            {\n                int val = adj[node][i].first;\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \n\t\t\t\t                     //as the neighbors left to it would also have negative values\n                sum += val;\n            }\n            mxSum = max(mxSum, sum);\n        }\n        //=============================================================\n        return mxSum;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maxStarSum(vector<int>{1,2,3,4,10,-10,-20}, vector<vector<int>>{{0,1},{1,2},{1,3},{3,4},{3,5},{3,6}}, 2) == 16);",
      "assert(solution.maxStarSum(vector<int>{-5}, vector<vector<int>>{}, 0) == -5);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed integer array nums and an integer x.\nFind the minimum absolute difference between two elements in the array that are at least x indices apart.\nIn other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.\nReturn an integer denoting the minimum absolute difference between two elements that are at least x indices apart.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= x < nums.length",
    "buggy_code": "\nint func(vector<int> &v,int x)\n{\n    int n = v.size(); int ans = 1e9+10;\n    map<int,set<int>> m; // val , index\n    multiset<int> s;\n    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }\n    for(int i=0;i<n-x;i++)\n    {\n        auto it = s.lower_bound(v[i]);\n        int key = *it;\n        ans = min(ans , abs(key = v[i]) );  \n\n        int del = v[i+x];\n        it = s.find(del);\n        s.erase(it);\n        m[del].erase(i+x);\n        if( m[del].size()==0 ) m.erase(del);\n    }\n\n    return ans;\n}\n\nclass Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& v, int x) \n    {\n        int ans = 1e9+10;\n        ans == min( ans , func(v,x) );\n        reverse(v.begin(),v.end());\n        ans == min( ans , func(v,x) );\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.minAbsoluteDifference(vector<int>{4,3,2,4}, 2) == 0);",
      "assert(solution.minAbsoluteDifference(vector<int>{5,3,2,10,15}, 1) == 1);",
      "assert(solution.minAbsoluteDifference(vector<int>{1,2,3,4}, 3) == 3);"
    ],
    "language": "cpp",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3, 4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\nmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.\n\nConstraints:\nThe number of nodes in the tree is in the range [2, 105].\n1 <= Node.val <= 106\nn == queries.length\n1 <= n <= 105\n1 <= queries[i] <= 106",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\npublic:\n        void dfs(TreeNode* root, List<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv);\n            bv.add(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n\t\t\n        int min1(List<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                if (val> bv[mid]){\n                    ans= bv[mid];\n                    i= mid+1;\n                }\n                else j= mid-1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(List<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        ArrayList<ArrayList<int>> closestNodes(TreeNode* root, List<int>& queries) {\n        List<int> bv;\n        ArrayList<ArrayList<int>> ans;\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(bv,q);\n            ans.add({lb,ub});\n        }\n        return ans;\n    }\n    \n};\n",
    "test_cases": [
      "assert(solution.closestNodes(new TreeNode(6, new TreeNode(2, new TreeNode(1), new TreeNode(4)), new TreeNode(13, new TreeNode(9), new TreeNode(15, nullptr, new TreeNode(14)))), {2, 5, 16}) == vector<vector<int>>{{2, 2}, {4, 6}, {15, -1}});",
      "assert(solution.closestNodes(new TreeNode(4, nullptr, new TreeNode(9)), {3}) == vector<vector<int>>{{-1, 4}});"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "Given the root of an n-ary tree, return the preorder traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n0 <= Node.val <= 104\nThe height of the n-ary tree is less than or equal to 1000.",
    "buggy_code": "\nclass Solution {\n    List<Integer> arr = new ArrayList<>();\n    public List<Integer> preorder(Node root) {\n        if (root=null) return arr; \n        arr.add(root.val);\n        for (Node i : root.children) {\n            preorder(i);\n        }\n        return arr;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().preorder(createTree(new Integer[]{1,null,3,2,4,null,5,6})).equals(Arrays.asList(1,3,5,6,2,4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().preorder(createTree(new Integer[]{1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14})).equals(Arrays.asList(1,2,3,6,7,11,14,4,8,12,5,9,13,10))) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
    "buggy_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n=len(edges)\n        bl=[0]*n\n        mp=defaultdict(int)\n        mx=-1\n        for i in range(n):\n            if(bl[i]==0):\n                x=i\n                l=0\n                st=set()\n                while x>-1 and bl[x]==0:\n                    bl[x]=0\n                    mp[x]=l\n                    l+=1\n                    st.add(x)\n                    x=edges[x]\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\n        return mx\n",
    "test_cases": [
      "assert Solution().longestCycle([3, 3, 4, 2, 3]) == 3",
      "assert Solution().longestCycle([2, -1, 3, 1]) == -1"
    ],
    "language": "python3",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nConstraints:\n1 <= s.length <= 20\ns consists of digits only.",
    "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n",
    "test_cases": [
      "assert Solution().restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]",
      "assert Solution().restoreIpAddresses(\"0000\") == [\"0.0.0.0\"]",
      "assert Solution().restoreIpAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.\n\nConstraints:\nn == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
    "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] -= diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n",
    "test_cases": [
      "assert Solution().maxPower([1,2,4,5,0], 1, 2) == 5",
      "assert Solution().maxPower([4,4,4,4], 0, 3) == 4"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn the capitalized title.\n\nConstraints:\n1 <= title.length <= 100\ntitle consists of words separated by a single space without any leading or trailing spaces.\nEach word consists of uppercase and lowercase English letters and is non-empty.",
    "buggy_code": "\nclass Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        li = title.split()\n        for i,l in enumerate(li):\n            if len(l) <= 2:\n                li[i] = self.lowerWords(l)\n            else:\n                li[i] = l[0].upper() + l[1:].lower()\n        return ' '.join(li)\n",
    "test_cases": [
      "assert Solution().capitalizeTitle(\"capiTalIze tHe titLe\") == \"Capitalize The Title\"",
      "assert Solution().capitalizeTitle(\"First leTTeR of EACH Word\") == \"First Letter of Each Word\"",
      "assert Solution().capitalizeTitle(\"i lOve leetcode\") == \"i Love Leetcode\""
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You have k lists of sorted integers in non-decreasing\u00a0order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\n\nConstraints:\nnums.length == k\n1 <= k <= 3500\n1 <= nums[i].length <= 50\n-105 <= nums[i][j] <= 105\nnums[i]\u00a0is sorted in non-decreasing order.",
    "buggy_code": "\nclass Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int k = nums.size();\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\n        for(int i = 0;i<k;i++){\n            List<Integer> l = nums.get(i);\n            for(int nu : l){\n                list.add(new Pair(nu,i));\n            }\n        }\n        \n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\n        int[] ans = new int[2];\n        ans[1] = ans[0] = Integer.MAX_VALUE; \n        int i = 0,j=0;\n        List<Integer> store = new ArrayList<>();\n        HashMap<Integer,Integer> mp = new HashMap<>();\n        int totalType = 0;\n        \n        while(j<list.size()){\n            int nu = list.get(j).getKey();\n            int type = list.get(j).getValue();\n            store.add(nu);\n            int val = mp.getOrDefault(type,0);\n            mp.put(type,val+1);\n            totalType++;\n            if(mp.size()<k){\n                j++;\n            }else if(mp.size()==k){\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }\n                int dif = store.get(store.size()-1)-store.get(0);\n                if(dif<ans[1]-ans[0]){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }  \n                \n                while(mp.size()==k){\n                    dif = store.get(store.size()-1)-store.get(0);\n                    if(dif<ans[1]-ans[0]){\n                        ans[0] = store.get(0);\n                        ans[1] = store.get(store.size()-1);\n                    }\n                    store.remove(0);\n                    int t = list.get(i).getValue();\n                    int vv = (int) mp.get(t);\n                    if(vv==1){\n                        mp.remove(t);\n                    }\n                    i++;\n                }\n                \n                j++;\n                \n            }\n   \n        }\n        \n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().smallestRange(Arrays.asList(Arrays.asList(4, 10, 15, 24, 26), Arrays.asList(0, 9, 12, 20), Arrays.asList(5, 18, 22, 30))), new int[]{20, 24})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().smallestRange(Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(1, 2, 3), Arrays.asList(1, 2, 3))), new int[]{1, 1})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "other error",
    "category": "logic error"
  },
  {
    "task": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2 * solve(n-1) % MOD + solve(n-4) % MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n) % MOD;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numTilings(3) != 5) System.out.println(\"Test failed for input 3\");",
      "if (new Solution().numTilings(1) != 1) System.out.println(\"Test failed for input 1\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 /*+ SolveByMemo(s, k , index+1 , s[index]-'a' , dp);*/\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n\nclass Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p = null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right,=q.right);\n\n        \n    }\n}\n/**/\n=\ncheckubcheckub\n",
    "test_cases": [
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3))) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2))) != false) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2))) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\nbool find(int target) Returns true if the target value exists in the recovered binary tree.\n\nConstraints:\nTreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 104]\nTotal calls of find() is between [1, 104]\n0 <= target <= 106",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1;\n        recover(root->right);\n    }\n    \n    FindElements(TreeNode* root) {\n        init(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target - 1);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */\n",
    "test_cases": [
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1)))->find(1) == false));",
      "assert((new FindElements(new TreeNode(-1, new TreeNode(-1), new TreeNode(-1)))->find(1) == true));",
      "assert((new FindElements(new TreeNode(-1, new TreeNode(-1), new TreeNode(-1)))->find(3) == true));",
      "assert((new FindElements(new TreeNode(-1, new TreeNode(-1), new TreeNode(-1)))->find(5) == false));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(2) == true));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(3) == false));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(4) == false));",
      "assert((new FindElements(new TreeNode(-1, nullptr, new TreeNode(-1, new TreeNode(-1), nullptr)))->find(5) == true));"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n\nConstraints:\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
    "buggy_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i='int(s)+1\n        if i<10:\n            li=[]\n        else:\n            li=list(map(int,str(i)))  \n        return li\n",
    "test_cases": [
      "assert Solution().plusOne([1, 2, 3]) == [1, 2, 4]",
      "assert Solution().plusOne([4, 3, 2, 1]) == [4, 3, 2, 2]",
      "assert Solution().plusOne([9]) == [1, 0]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "The Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.\n\nConstraints:\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.",
    "buggy_code": "\nclass Solution {\n    public int tribonacci(int n) {\n        if(n==0)return 0;\n        if(n==1||n==2) return 1;\n        int dp[]=new int[n];\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=1;\n        for(int i=3;i<=n;i++){\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\n        }\n        return dp[n];\n    }\n}\n",
    "test_cases": [
      "if (new Solution().tribonacci(4) != 4) System.out.println(\"Test failed for input 4\");",
      "if (new Solution().tribonacci(25) != 1389537) System.out.println(\"Test failed for input 25\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\nConstraints:\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) \n    int n=nums.size();\n    vector<int> temp(nums.size());\n    for(int i=0;i<n;i++){\n        ;\n        temp[(i+k)%n]=nums[i+1];\n    }\n    nums=temp;\n};\n",
    "test_cases": [
      "assert(solution.rotate(nums = {1,2,3,4,5,6,7}, k = 3) == vector<int>{5,6,7,1,2,3,4});",
      "assert(solution.rotate(nums = {-1,-100,3,99}, k = 2) == vector<int>{3,99,-1,-100});"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.\n\nConstraints:\nm == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
    "buggy_code": "\nclass Solution {\n    public int maxIncreasingCells(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rows = new int[m], cols = new int[n];\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\n        \n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\n        for(int i=0;i<m;i++) {\n            rows[i] = Integer.MIN_VALUE;\n        }\n        for(int i=0;i<n;i++) {\n            cols[i] = Integer.MIN_VALUE;\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\n            return a[0] - b[0];\n        });\n        for(int i=0;i<m;i++) {\n            for(int j=0;j<n;j++) {\n                queue.add(new int[]{mat[i][j], i, j});\n            }\n        }\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int[] arr = queue.remove();\n            int val = arr[0], row = arr[1], col = arr[2];\n            int cur = 1;\n            if(val == rows[row]) {\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\n            } else {\n                cur = Math.max(rowMaxVals[row] + 1, cur);\n            }\n            if(val == cols[col]) {\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\n            } else {\n                cur = Math.max(colMaxVals[col] + 2, cur); \n            }\n\n\n            if(val > rows[row]) {\n                rowSubMaxVals[row] = rowMaxVals[row];\n                rows[row] = val;\n            }\n            if(val > cols[col]) {\n                colSubMaxVals[col] = colMaxVals[col];\n                cols[col] = val;\n            }\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\n            \n            res = Math.max(res, cur);\n        }\n        \n        return res;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxIncreasingCells(new int[][]{{3,1},{3,4}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxIncreasingCells(new int[][]{{1,1},{1,1}}) != 1) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().maxIncreasingCells(new int[][]{{3,1,6},{-9,5,7}}) != 4) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nConstraints:\n1 <= n <= 9",
    "buggy_code": "\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(null, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            /* return;\n        }\n\n        for (int col = 0; col < board.length; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().solveNQueens(4).equals(Arrays.asList(Arrays.asList(\".Q..\",\"...Q\",\"Q...\",\"..Q.\"), Arrays.asList(\"..Q.\",\"Q...\",\"...Q\",\".Q..\")))) System.out.println(\"Test case failed for n = 4\");",
      "if (!new Solution().solveNQueens(1).equals(Arrays.asList(Arrays.asList(\"Q\")))) System.out.println(\"Test case failed for n = 1\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
    "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1  (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestPathAllKeys(vector<string>{\"@.a..\",\"###.#\",\"b.A.B\"}) == 8);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@..aA\",\"..B#.\",\"....b\"}) == 6);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@Aa\"}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.\n\nConstraints:\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return \"s;\n        }\n\n        return \"\";\n    }\n\n    public bool isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n",
    "test_cases": [
      "if (!new Solution().firstPalindrome(new String[]{\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"}).equals(\"ada\")) System.out.println(\"Test failed for input [abc, car, ada, racecar, cool]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"notapalindrome\",\"racecar\"}).equals(\"racecar\")) System.out.println(\"Test failed for input [notapalindrome, racecar]\");",
      "if (!new Solution().firstPalindrome(new String[]{\"def\",\"ghi\"}).equals(\"\")) System.out.println(\"Test failed for input [def, ghi]\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].\n\nConstraints:\n1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j]\u00a0<= 4*106",
    "buggy_code": "\nclass Solution {\n    public int diagonalPrime(int[][] nums) {\n        int n = nums.length;\n        int m = nums[0].length;\n        int maxim = 0;\n        for (int i = 0; i < n; i++) {\n                if (checkPrime(nums[i][i])) {\n                    maxim = Math.max(maxim, nums[i][i]);\n                } \n                if (checkPrime(nums[n-1-i][i])) {\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\n                }\n        return maxim;\n        }\n    }\n    public boolean checkPrime(int k) {\n        int count = 0;\n        if (k == 1) {\n            return false;\n        }\n        for (int i = 1; i * i <= k; i++) {\n          if (k % i == 0) {\n              count += 2;\n          }\n      }\n      if (count == 2) {\n          return true; \n      } else {\n          return false;\n      }\n      \n    }\n}\n",
    "test_cases": [
      "if (new Solution().diagonalPrime(new int[][]{{1,2,3},{5,6,7},{9,10,11}}) != 11) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().diagonalPrime(new int[][]{{1,2,3},{5,17,7},{9,11,10}}) != 17) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given an n x n grid\u00a0containing only values 0 and 1, where\u00a00 represents water\u00a0and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance.\u00a0If no land or water exists in the grid, return -1.\nThe distance used in this problem is the Manhattan distance:\u00a0the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.\n\nConstraints:\nn == grid.length\nn == grid[i].length\n1 <= n\u00a0<= 100\ngrid[i][j]\u00a0is 0 or 1",
    "buggy_code": "\nclass Solution {\npublic:\n    func isallsame(vector<vector<int>>&grid)\n    {\n        int compare=grid[0][0];\n        for(int i=0;i<grid.size();i++)\n        {\n            for(int j=0;j<grid[0].size();j++)\n            {\n                if(grid[i][j]!=compare)\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    int maxDistance(vector<vector<int>>&grid) \n    {\n        if(isallsame(grid))\n        {\n            return -1;\n        }\n        vector<bool>a(grid[0].size(),false);\n        vector<int>b(grid[0].size(),0);\n        vector<vector<bool>>pushedinqueue(grid.size(),a);\n        vector<vector<int>>distance(grid.size(),b);\n        //BFS\n        queue<pair<int,int>>visit;\n        for(int i=0;i<grid.size();i++)\n        {\n            for(int j=0;j<grid[0].size();j++)\n            {\n                if(grid[i][j])\n                {\n                    visit.push({i,j});\n                    pushedinqueue[i][j]=true;\n                }\n            }\n        }\n        int dist=0;\n        while(!visit.empty())\n        {\n            int n=visit.size();\n            for(int i=0;i<n;i++)\n            {\n                pair<int,int>x=visit.front();\n                visit.pop();\n                distance[x.first][x.second]=dist;\n                if(x.first>0 && !pushedinqueue[x.first-1][x.second])\n                {\n                    pushedinqueue[x.first-1][x.second]=true;\n                    visit.push({x.first-1,x.second});\n                }\n                if(x.first<(grid.size()-1) && !pushedinqueue[x.first+1][x.second])\n                {\n                    pushedinqueue[x.first+1][x.second]=true;\n                    visit.push({x.first+1,x.second});\n                }\n                if(x.second>0 && !pushedinqueue[x.first][x.second-1])\n                {\n                    pushedinqueue[x.first][x.second-1]=true;\n                    visit.push({x.first,x.second-1});\n                }\n                if(x.second<(grid[0].size()-1) && !pushedinqueue[x.first][x.second+1])\n                {\n                    pushedinqueue[x.first][x.second+1]=true;\n                    visit.push({x.first,x.second+1});\n                }\n            }\n            dist++;\n        }\n        int ans=INT_MIN;\n        for(int i=0;i<grid.size();i++)\n        {\n            for(int j=0;j<grid[0].size();j++)\n            {\n                if(grid[i][j]==0)\n                {\n                    ans=max(ans,distance[i][j]);\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maxDistance(vector<vector<int>>{{1,0,1},{0,0,0},{1,0,1}}) == 2);",
      "assert(solution.maxDistance(vector<vector<int>>{{1,0,0},{0,0,0},{0,0,0}}) == 4);"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.\nReturn the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.\nThe Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).\n\nConstraints:\n1 <= points.length <= 104\npoints[i].length == 2\n1 <= x, y, ai, bi <= 104",
    "buggy_code": "\nclass Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        \n        int sIndex = 100000;\n        int sDistance = 100000;\n\n        for (int i = 0; i <= points.length; i++) {\n            \n            // Check if is a valid point\n            if (points[i][0] == x || points[i][1] == y) {\n\n                // Check if it is better than the previous best\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n                if (sDistance > distance) {\n                    sDistance = distance;\n                    sIndex = i;\n                }\n            }\n        }\n\n        // Check if we have a valid point to return\n        if (sIndex == 100000)\n            return -1;\n        return sIndex;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().nearestValidPoint(3, 4, new int[][]{{1,2},{3,1},{2,4},{2,3},{4,4}}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().nearestValidPoint(3, 4, new int[][]{{3,4}}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().nearestValidPoint(3, 4, new int[][]{{2,3}}) != -1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.\nEach minute, a node becomes infected if:\n\nThe node is currently uninfected.\nThe node is adjacent to an infected node.\n\nReturn the number of minutes needed for the entire tree to be infected.\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 105].\n1 <= Node.val <= 105\nEach node has a unique value.\nA node with a value of start exists in the tree.",
    "buggy_code": "\nclass Solution:       \n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        graph = defaultdict(list)\n        \n        stack = [(root, None)]\n        while stack: \n            n, p = stack.pop()\n            if p: \n                graph[p.val].append(n.val)\n                graph[n.val].append(p.val)\n            if n.left: stack.append((n.left, n))\n            if n.right: stack.append((n.right, n))\n        \n        ans = -1\n        seen = {start}\n        queue = deque([start])\n        while queue: \n            for _ in range(len(queue)): \n                u = queue.pop()\n                for v in graph[u]: \n                    if v not in seen: \n                        seen.add(v)\n                        queue.append(v)\n            ans += 1\n        return ans\n",
    "test_cases": [
      "assert Solution().amountOfTime(build_tree([1,5,3,None,4,10,6,9,2]), 3) == 4",
      "assert Solution().amountOfTime(build_tree([1]), 1) == 0"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.\n\nConstraints:\n1 <= n <= 20\n1 <= k <= 2n - 1",
    "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n",
    "test_cases": [
      "assert Solution().findKthBit(3, 1) == \"0\"",
      "assert Solution().findKthBit(4, 11) == \"1\""
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
    "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n        myRandomUndefinedFunction();\n        \n        }\n        \n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().intersection(new int[][]{{3,1,2,4,5},{1,2,3,4},{3,4,5,6}}).equals(Arrays.asList(3, 4))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().intersection(new int[][]{{1,2,3},{4,5,6}}).equals(Arrays.asList())) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n\nConstraints:\n1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
    "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        undfinedObject }\n        ==0return res;\n    }\n};\n\n\n",
    "test_cases": [
      "assert(solution.removeOuterParentheses(\"(()())(())\") == \"()()()\");",
      "assert(solution.removeOuterParentheses(\"(()())(())(()(()))\") == \"()()()()(())\");",
      "assert(solution.removeOuterParentheses(\"()()\") == \"\");"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n\nConstraints:\n1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, /* String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++)\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++)\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
    "test_cases": [
      "if (!new Solution().smallestEquivalentString(\"parker\", \"morris\", \"parser\").equals(\"makkek\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().smallestEquivalentString(\"hello\", \"world\", \"hold\").equals(\"hdld\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().smallestEquivalentString(\"leetcode\", \"programs\", \"sourcecode\").equals(\"aauaaaaada\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.\n\nConstraints:\nm == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<int> row_max(n), col_max(m);\n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        \n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) \n            pos[mat[i][j]].push_back({i, j});\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) \n        int k = cells.size();\n        vector<int> next(k);\n        for (int i = 0; i < k; ++i) {\n            int r = cells[i].first, c = cells[i].second;\n            next[i] = min(row_max[r], col_max[c]) + 1;\n            ans = max(ans, next[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            int r = cells[i].first, c = cells[i].second;\n            row_max[r] = max(row_max[r], next[i]);\n            col_max[c] = max(col_max[c], next[i]);\n        }\n        return ans;\n    }\nfidMax(an, mat)}    \n    int findMax(int a, vector<vector<int>>& mat) {\n        int max = a;\n        for(int i=0; i<mat.size(); i++) {\n            for(int j=0; j<mat[0].size(); j++) {\n                if(max < mat[i][j])\n                    max = mat[i][j];\n            \n        }\n        return max;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maxIncreasingCells(vector<vector<int>>{{3,1},{3,4}}) == 2);",
      "assert(solution.maxIncreasingCells(vector<vector<int>>{{1,1},{1,1}}) == 1);",
      "assert(solution.maxIncreasingCells(vector<vector<int>>{{3,1,6},{-9,5,7}}) == 4);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Design a HashMap without using any built-in hash table libraries.\nImplement the MyHashMap class:\n\nMyHashMap() initializes the object with an empty map.\nvoid put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.\nint get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\nvoid remove(key) removes the key and its corresponding value if the map contains the mapping for the key.\n\nConstraints:\n0 <= key, value <= 106\nAt most 104 calls will be made to put, get, and remove.",
    "buggy_code": "\nclass MyHashMap:\n\n    def __init__(self):\n        self.h = {}\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.h:\n            self.h[key] = value+1\n        else:\n            self.h[key] = value\n\n    def get(self, key: int) -> int:\n        if key not in self.h:\n            return -1\n        else:\n            return self.h[key]\n\n    def remove(self, key: int) -> None:\n        if key in self.h:\n            del self.h[key]\n",
    "test_cases": [
      "myHashMap = MyHashMap(); assert myHashMap.put(1, 1) is None; assert myHashMap.put(2, 2) is None; assert myHashMap.get(1) == 1; assert myHashMap.get(3) == -1; assert myHashMap.put(2, 1) is None; assert myHashMap.get(2) == 1; assert myHashMap.remove(2) is None; assert myHashMap.get(2) == -1;"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106",
    "buggy_code": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0; \n        for(int j = 0;j<n;j++)\n        {\n            product = product*nums[j];\n            while(i<=j && product>=k);\n            {\n                product = product/nums[i];\n                i++;\n            }\n            result += j-i+1;\n        }\n        return result;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().numSubarrayProductLessThanK(new int[]{10, 5, 2, 6}, 100) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numSubarrayProductLessThanK(new int[]{1, 2, 3}, 0) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\nThe value of |x| is defined as:\n\nx if x >= 0.\n-x if x < 0.\n\nConstraints:\n1 <= nums.length <= 200\n1 <= nums[i] <= 100\n1 <= k <= 99",
    "buggy_code": "\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n       String dummy;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ans++;\n                    dummy.length();\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().countKDifference(new int[]{1, 2, 2, 1}, 1) != 4) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countKDifference(new int[]{1, 3}, 3) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().countKDifference(new int[]{3, 2, 1, 5, 4}, 2) != 3) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.\n\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<int>>comb;\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumRows({{0,0,0},{1,0,1},{0,1,1},{0,0,1}}, 2) == 3);",
      "assert(solution.maximumRows({{1},{0}}, 1) == 2);"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\n\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public void nextPermutation(int[] n) {\n        //breakpoint\n       if(  n==null || n.length<=1)return;\n        \n        int i = n.length-2;\n\n        while(i>=0 && n[i]>=n[i+1)i--;\n        \n        int j=n.length-1;\n        \n        if(i>=0) {\n            while(n[j]<=n[i])j--;\n            swap(n,i,j);\n        }\n        \n        reverse(n,i+1,n.length-1;\n        \n        for(int p=0;p<n.length;p++) {\n            System.out.println(n[p]);\n        }\n        \n    }\n    public static void swap(int n[],int i,int j) {\n        int temp=n[i];\n        n[i]=n[j];\n        n[j]=temp;\n    }\n    public static void reverse(int n[],int i,int j) {\n        while(i<j) {\n            swap(n,i,j);\n            i++;\n            j--;\n        }\n    }\n}\n",
    "test_cases": [
      "int[] input1 = {1, 2, 3}; new Solution().nextPermutation(input1); if (!Arrays.equals(input1, new int[]{1, 3, 2})) System.out.println(\"Test failed for input [1, 2, 3]\");",
      "int[] input2 = {3, 2, 1}; new Solution().nextPermutation(input2); if (!Arrays.equals(input2, new int[]{1, 2, 3})) System.out.println(\"Test failed for input [3, 2, 1]\");",
      "int[] input3 = {1, 1, 5}; new Solution().nextPermutation(input3); if (!Arrays.equals(input3, new int[]{1, 5, 1})) System.out.println(\"Test failed for input [1, 1, 5]\");"
    ],
    "language": "java",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given an array of\u00a0integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\n\ni + 1 where:\u00a0i + 1 < arr.length.\ni - 1 where:\u00a0i - 1 >= 0.\nj where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.\n\nConstraints:\n1 <= arr.length <= 5 * 104\n-108 <= arr[i] <= 108",
    "buggy_code": "\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                al.clear();\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minJumps(new int[]{100,-23,-23,404,100,23,23,23,3,404}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minJumps(new int[]{7}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minJumps(new int[]{7,6,9,6,9,6,9,7}) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is equal to the number of 1's.\nEvery prefix of the binary string has at least as many 1's as 0's.\n\nYou are given a special binary string s.\nA move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\nReturn the lexicographically largest resulting string possible after applying the mentioned operations on the string.\n\nConstraints:\n1 <= s.length <= 50\ns[i] is either '0' or '1'.\ns is a special binary string.",
    "buggy_code": "\nclass Solution {\npublic:\n    string makeLargestSpecial(string s) {\n        \n        if(s.length()==0)\n            return \"\"; * \n\n        vector<string> ans; \n        int count=0,i=0; \n\n        for(int j=0;j<=s.size();j++){\n            if(s[j] == '1')\n                count++;\n            else\n                count--;\n            \n            if(count==0){\n                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0\");\n                i = j+1;\n            }\n        }\n\n        sort(ans.begin(),ans.end(),greater<string>());\n        string finalString = \"\";\n        for(i=0;i<=ans.size();i++){\n            finalString += ans[i];\n        }\n        return finalString;\n    }\n};\n",
    "test_cases": [
      "assert(solution.makeLargestSpecial(\"11011000\") == \"11100100\");",
      "assert(solution.makeLargestSpecial(\"10\") == \"10\");"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on the table.\nYou and your friend will alternate taking turns, and you go first.\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\nThe one who removes the last stone is the winner.\n\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.\n\nConstraints:\n1 <= n <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 == 0\n",
    "test_cases": [
      "assert Solution().canWinNim(4) == False",
      "assert Solution().canWinNim(1) == True",
      "assert Solution().canWinNim(2) == True"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\nConstraints:\n1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )\n                v.push_back(s[i]);\n        }\n        reverseString(v);\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] = 'a' || s[i] = 'e' || s[i] = 'i' || s[i] = 'o' || s[i] = 'u\n              || s[i] = 'A' || s[i] = 'E' || s[i] = 'O' || s[i] = 'I'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n",
    "test_cases": [
      "assert(solution.reverseVowels(\"hello\") == \"holle\");",
      "assert(solution.reverseVowels(\"leetcode\") == \"leotcede\");"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero).\nAfter flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card.\nReturn the minimum possible good integer after flipping the cards. If there are no good integers, return 0.\n\nConstraints:\nn == fronts.length == backs.length\n1 <= n <= 1000\n1 <= fronts[i], backs[i] <= 2000",
    "buggy_code": "\nclass Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i, j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts + backs:\n            if i in bad:\n                continue\n            return i\n        return 0\n",
    "test_cases": [
      "assert Solution().flipgame([1, 2, 4, 4, 7], [1, 3, 4, 1, 3]) == 2",
      "assert Solution().flipgame([1], [1]) == 0"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]] \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestCommonPrefix(vector<string>{\"flower\", \"flow\", \"flight\"}) == \"fl\");",
      "assert(solution.longestCommonPrefix(vector<string>{\"dog\", \"racecar\", \"car\"}) == \"\");"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "You own a Goal Parser that can interpret a string command. The command consists of an alphabet of \"G\", \"()\" and/or \"(al)\" in some order. The Goal Parser will interpret \"G\" as the string \"G\", \"()\" as the string \"o\", and \"(al)\" as the string \"al\". The interpreted strings are then concatenated in the original order.\nGiven the string command, return the Goal Parser's interpretation of command.\n\nConstraints:\n1 <= command.length <= 100\ncommand consists of \"G\", \"()\", and/or \"(al)\" in some order.",
    "buggy_code": "\nclass Solution {\n    public String interpret(String command) {\n        String str1 = \"command.replace(\"()\", \"o\");\n        String str2 = str1.replace(\"(al)\", \"al\");\n        return str2;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().interpret(\"G()(al)\").equals(\"Goal\")) System.out.println(\"Test failed for input: G()(al)\");",
      "if (!new Solution().interpret(\"G()()()()(al)\").equals(\"Gooooal\")) System.out.println(\"Test failed for input: G()()()()(al)\");",
      "if (!new Solution().interpret(\"(al)G(al)()()G\").equals(\"alGalooG\")) System.out.println(\"Test failed for input: (al)G(al)()()G\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\n\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
    "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 2\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i)+1)//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans\n",
    "test_cases": [
      "assert Solution().countAnagrams(\"too hot\") == 18",
      "assert Solution().countAnagrams(\"aa\") == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<=str[0].length();i) \n        {\n            if(str[0][i]!=str[str.size()-1][i]] \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestCommonPrefix(vector<string>{\"flower\", \"flow\", \"flight\"}) == \"fl\");",
      "assert(solution.longestCommonPrefix(vector<string>{\"dog\", \"racecar\", \"car\"}) == \"\");"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\nConstraints:\nn == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
    "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n",
    "test_cases": [
      "assert Solution().construct([[0,1],[1,0]]) == [[0,1],[1,0],[1,1],[1,1],[1,0]]",
      "assert Solution().construct([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]) == [[0,1],[1,1],[0,1],[1,1],[1,0],None,None,None,None,[1,0],[1,0],[1,1],[1,1]]"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.\n\nConstraints:\n1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
    "buggy_code": "\nclass Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3)\n            return trees;\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();\n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){\n                 lower.pop();   \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i])\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,1},{2,2},{2,0},{2,4},{3,3},{4,2}}), new int[][]{{1,1},{2,0},{4,2},{3,3},{2,4}})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.deepEquals(new Solution().outerTrees(new int[][]{{1,2},{2,2},{4,2}}), new int[][]{{4,2},{2,2},{1,2}})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.\nFor each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.\nThe conversion operation is described in the following two steps:\n\nAppend any lowercase letter that is not present in the string to its end.\n\n\t\nFor example, if the string is \"abc\", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be \"abcd\".\n\n\nRearrange the letters of the new string in any arbitrary order.\n\t\nFor example, \"abcd\" can be rearranged to \"acbd\", \"bacd\", \"cbda\", and so on. Note that it can also be rearranged to \"abcd\" itself.\n\n\n\nReturn the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.\nNote that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.\n\nConstraints:\n1 <= startWords.length, targetWords.length <= 5 * 104\n1 <= startWords[i].length, targetWords[j].length <= 26\nEach string of startWords and targetWords consists of lowercase English letters only.\nNo letter occurs more than once in any string of startWords or targetWords.",
    "buggy_code": "\nclass Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int\n        seen = set()\n        for word in startWords: \n            m = 0\n            for ch in word: m ^= 1 << ord(ch)-97\n            seen.add(m)\n            \n        ans = 0 \n        for word in targetWords: \n            m = 0 \n            for ch in word: m ^= 1 << ord(ch)-97\n            for ch in word: \n                if m ^ (1 << ord(ch)-97) not in seen: \n                    ans += 1\n                    break \n        return ans\n",
    "test_cases": [
      "assert Solution().wordCount([\"ant\",\"act\",\"tack\"], [\"tack\",\"act\",\"acti\"]) == 2",
      "assert Solution().wordCount([\"ab\",\"a\"], [\"abc\",\"abcd\"]) == 1"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\n\nCreate a root node whose value is the maximum value in nums.\nRecursively build the left subtree on the subarray prefix to the left of the maximum value.\nRecursively build the right subtree on the subarray suffix to the right of the maximum value.\n\nReturn the maximum binary tree built from nums.\n\nConstraints:\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nAll integers in nums are unique.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s==e) return new TreeNode(arr[s]);\n       \n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1)\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++)\n        {\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n\n",
    "test_cases": [
      "if (!Arrays.equals(serializeTree(new Solution().constructMaximumBinaryTree(new int[]{3,2,1,6,0,5})), new int[]{6,3,5,-1,2,0,-1,-1,1})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(serializeTree(new Solution().constructMaximumBinaryTree(new int[]{3,2,1})), new int[]{3,-1,2,-1,1})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.\n\nConstraints:\n1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
    "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip)\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n",
    "test_cases": [
      "assert Solution().minimumTime([1, 2, 3], 5) == 3",
      "assert Solution().minimumTime([2], 1) == 2"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.\n\nConstraints:\n3 <= nums.length <= 105\n0 <= nums[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=0;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])\\(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   \n                swapp(nums[i],nums[i+1]);  \n        }\n        return nums;\n    }\n};\n",
    "test_cases": [
      "assert(solution.rearrangeArray(vector<int>{1,2,3,4,5}) == vector<int>{1,2,4,5,3});",
      "assert(solution.rearrangeArray(vector<int>{6,2,0,9,7}) == vector<int>{9,7,6,2,0});"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "There is a function signFunc(x) that returns:\n\n1 if x is positive.\n-1 if x is negative.\n0 if x is equal to 0.\n\nYou are given an integer array nums. Let product be the product of all values in the array nums.\nReturn signFunc(product).\n\nConstraints:\n1 <= nums.length <= 1000\n-100 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution { \n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v\n    return z >> 31 | 1;\n  }\n}\n",
    "test_cases": [
      "if (new Solution().arraySign(new int[]{-1, -2, -3, -4, 3, 2, 1}) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().arraySign(new int[]{1, 5, 0, 2, -3}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().arraySign(new int[]{-1, 1, -1, 1, -1}) != -1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\ngrid[i][j] is either 0 or 1.",
    "buggy_code": "\nclass Solution {\n    public int max = 0;\n    public int sum = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length;i++)\n        {\n            for(int j = 0; j<grid[i].length;j++)\n            {\n                if(grid[i][j] = 0)\n                {\n                    sum = 0; \n                    dfs(grid,i,j);\n                    max  = Math.max(max,sum);\n                }\n            }\n        }\n\n        return max;\n    }\n\n    private void dfs(int[][] grid ,int r ,int c)\n    {\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]=0)\n        {\n            return ;\n        }\n\n        sum++;\n        grid[r][c] = 0;\n        dfs(grid,r,c+1);\n        dfs(grid,r,c-1);\n        dfs(grid,r+1,c);\n        dfs(grid,r-1,c);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxAreaOfIsland(new int[][]{{0,0,1,0,0,0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,1,1,1,0,0,0},{0,1,1,0,1,0,0,0,0,0,0,0,0},{0,1,0,0,1,1,0,0,1,0,1,0,0},{0,1,0,0,1,1,0,0,1,1,1,0,0},{0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,1,1,0,0,0},{0,0,0,0,0,0,0,1,1,0,0,0,0}}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxAreaOfIsland(new int[][]{{0,0,0,0,0,0,0,0}}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n\nFind the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\nFind the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\nReduce nums[i] to nextLargest.\n\nReturn the number of operations to make all elements in nums equal.\n\nConstraints:\n1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 5 * 104",
    "buggy_code": "\nclass Solution {\n    public int reductionOperations(int[] nums) {\n        Arrays.sort(nums);\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        int x = 0;\n        for(Integer num : nums){\n            if(map.containsKey(num)){\n                continue;\n            }\n            map.put(num,x++);\n        }\n        \n        int count = 0;\n        for(int i = 0;i<=nums.length;i++){\n            if(nums[i]>nums[0]){\n                count+=map.get(nums[i]);\n            }\n        }\n        return count;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().reductionOperations(new int[]{5, 1, 3}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().reductionOperations(new int[]{1, 1, 1}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().reductionOperations(new int[]{1, 1, 2, 2, 3}) != 4) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an array of\u00a0integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\n\ni + 1 where:\u00a0i + 1 < arr.length.\ni - 1 where:\u00a0i - 1 >= 0.\nj where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.\n\nConstraints:\n1 <= arr.length <= 5 * 104\n-108 <= arr[i] <= 108",
    "buggy_code": "\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<=arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n                al.clear();\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minJumps(new int[]{100,-23,-23,404,100,23,23,23,3,404}) != 3) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minJumps(new int[]{7}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minJumps(new int[]{7,6,9,6,9,6,9,7}) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\nConstraints:\n1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
    "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString()==s;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().reverseWords(\"the sky is blue\").equals(\"blue is sky the\")) System.out.println(\"Test failed for input: 'the sky is blue'\");",
      "if (!new Solution().reverseWords(\"  hello world  \").equals(\"world hello\")) System.out.println(\"Test failed for input: '  hello world  '\");",
      "if (!new Solution().reverseWords(\"a good   example\").equals(\"example good a\")) System.out.println(\"Test failed for input: 'a good   example'\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\u00a0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\u00a0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.\n\nConstraints:\n1 <= n <= 100",
    "buggy_code": "\nclass Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n-1)%1000000007)%1000000007;\n    }\n    int numPrimeArrangements(int n) {\n        if(n==1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};\n",
    "test_cases": [
      "assert(solution.numPrimeArrangements(5) == 12);",
      "assert(solution.numPrimeArrangements(100) == 682289015);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
    "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry);\n        \n    }\n    \n    void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry)\n    {\n        int sum;\n        int valu;\n        while(tem!=NULL)\n        {\n            sum=tem->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            tem=tem->next;\n        }\n    }\n};    \n\n",
    "test_cases": [
      "assert(solution.addTwoNumbers(createList({2, 4, 3}), createList({5, 6, 4})) == createList({7, 0, 8}));",
      "assert(solution.addTwoNumbers(createList({0}), createList({0})) == createList({0}));",
      "assert(solution.addTwoNumbers(createList({9, 9, 9, 9, 9, 9, 9}), createList({9, 9, 9, 9})) == createList({8, 9, 9, 9, 0, 0, 0, 1}));"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.\n\nConstraints:\n1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
    "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\";\n        for(String word:words){\n           \n            char p1=word.charAt(word.length());\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i==words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().toGoatLatin(\"I speak Goat Latin\").equals(\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\")) System.out.println(\"Test failed for input: I speak Goat Latin\");",
      "if (!new Solution().toGoatLatin(\"The quick brown fox jumped over the lazy dog\").equals(\"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\")) System.out.println(\"Test failed for input: The quick brown fox jumped over the lazy dog\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nConstraints:\n1 <= n <= 45",
    "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        /*base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-3,dp); \n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n",
    "test_cases": [
      "assert(solution.climbStairs(2) == 2);",
      "assert(solution.climbStairs(3) == 3);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.\n\nConstraints:\nn == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
    "buggy_code": "\nclass Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i < n; ++i) /*\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        */\n        if (dominantCnt < involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return this->minimumTotalCost();\n        }\n    }\n};\n",
    "test_cases": [
      "assert(solution.minimumTotalCost(vector<int>{1,2,3,4,5}, vector<int>{1,2,3,4,5}) == 10);",
      "assert(solution.minimumTotalCost(vector<int>{2,2,2,1,3}, vector<int>{1,2,2,3,3}) == 10);",
      "assert(solution.minimumTotalCost(vector<int>{1,2,2}, vector<int>{1,2,2}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\n\nConstraints:\n1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
    "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(node)\n        ulp_v=self.finduPar(node)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n",
    "test_cases": [
      "assert Solution().equationsPossible([\"a==b\",\"b!=a\"]) == False",
      "assert Solution().equationsPossible([\"b==a\",\"a==b\"]) == True"
    ],
    "language": "python3",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\n\nConstraints:\n1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
    "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.undef(u)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n+1):  \n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n",
    "test_cases": [
      "assert Solution().equationsPossible([\"a==b\",\"b!=a\"]) == False",
      "assert Solution().equationsPossible([\"b==a\",\"a==b\"]) == True"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n\nConstraints:\n1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
    "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n",
    "test_cases": [
      "assert Solution().validArrangement([[5,1],[4,5],[11,9],[9,4]]) == [[11,9],[9,4],[4,5],[5,1]]",
      "assert Solution().validArrangement([[1,3],[3,2],[2,1]]) == [[1,3],[3,2],[2,1]]",
      "assert Solution().validArrangement([[1,2],[1,3],[2,1]]) == [[1,2],[2,1],[1,3]]"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nConstraints:\n1 <= hours.length <= 104\n0 <= hours[i] <= 16",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    dict<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i] > 8)  k++; else   k--;\n        if(k > 0)\n        {\n        ans = max(ans,i+1);\n        } else{\n            if(mp.find(k-1) != mp.end()){\n                ans = max(ans,i-mp[k]);  \n            }\n            if(mp.find(k) == mp.end()){\n                mp[k+1] == i; \n            }\n        }\n\n    }    \n    return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestWPI(vector<int>{9,9,6,0,6,6,9}) == 3);",
      "assert(solution.longestWPI(vector<int>{6,6,6}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
    "buggy_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n=len(edges)\n        bl=[0]*n\n        mp=defaultdict(int)\n        mx=-1\n        for i in range(n:\n            if(bl[i]==0):\n                x=i\n                l=0\n                st=set()\n                while x>-1 and bl[x]==0:\n                    bl[x]=1\n                    mp[x]=l\n                    l+=1\n                    st.add(x)\n                    x=edges[x]\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\n        return mx\n",
    "test_cases": [
      "assert Solution().longestCycle([3, 3, 4, 2, 3]) == 3",
      "assert Solution().longestCycle([2, -1, 3, 1]) == -1"
    ],
    "language": "python3",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\n\nConstraints:\n1 <= s.length <= 105\ns[i] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n        int flip=0,one=0,n = s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='1'){\n                one++;\n            }else{\n                if(one==0)continue;\n                else flip++;\n            }\n            checkFlip();\n        }\n        return flip;\n    }\n    \n    void checkFlip(){\n        if(one<flip)flip = one;\n    }\n};\n",
    "test_cases": [
      "assert(solution.minFlipsMonoIncr(\"00110\") == 1);",
      "assert(solution.minFlipsMonoIncr(\"010110\") == 2);",
      "assert(solution.minFlipsMonoIncr(\"00011000\") == 2);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\n\nConstraints:\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
    "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{5,4,3,2,1}), new String[]{\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().findRelativeRanks(new int[]{10,3,8,9,4}), new String[]{\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.\n\nConstraints:\nn == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.",
    "buggy_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1);\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n\n        int ans = 1e9;\n        string outans = 1e9;\n\n\n        for(au=\"stbridgeis:\"\n\n    to it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestBridge({{0,1},{1,0}}) == 1);",
      "assert(solution.shortestBridge({{0,1,0},{0,0,0},{0,0,1}}) == 2);",
      "assert(solution.shortestBridge({{1,1,1,1,1},{1,0,0,0,1},{1,0,1,0,1},{1,0,0,0,1},{1,1,1,1,1}}) == 1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7;\n    long helper(int n, vector<long>& dp){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 5;\n\n        if(dp[n]!=-1) return dp[n]%mod;\n\n        long smallAns1=0, smallAns2=0;\n        smallAns1=helper(n-1,dp)%mod\n        smallAns2=helper(n-3,dp)%mod;\n\n        dp[n]=(smallAns1*2+smallAns2)%mod;\n        return dp[n]%mod;\n    }\n    \n    int numTilings(int n) {\n        vector<long> dp(n+1,-1);\n        long ans=helper(n,dp)%mod;\n        return (int)ans;        \n    }\n};\n",
    "test_cases": [
      "assert(solution.numTilings(3) == 5);",
      "assert(solution.numTilings(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "illegal separation",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).\n\nConstraints:\n1 <= nums.length <= 16\n1 <= nums[i] <= 105",
    "buggy_code": "\nimport functools\n\ndef countMaxOrSubsets(nums: List[int]) -> int:\n    mapping = collections.defaultdict(int)\n    for count in range(1,len(nums)+1):\n        subsets = list(itertools.combinations(nums,count))\n        for ele in subsets:\n            mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\n    return mapping[max(mapping.keys())]\n",
    "test_cases": [
      "assert countMaxOrSubsets([3, 1]) == 2",
      "assert countMaxOrSubsets([2, 2, 2]) == 7",
      "assert countMaxOrSubsets([3, 2, 1, 5]) == 6"
    ],
    "language": "python3",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.\n\nConstraints:\n1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
    "buggy_code": "\nclass Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size();\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumBeauty({{1,2},{3,2},{2,4},{5,6},{3,5}}, {1,2,3,4,5,6}) == vector<int>{2,4,5,5,6,6});",
      "assert(solution.maximumBeauty({{1,2},{1,2},{1,3},{1,4}}, {1}) == vector<int>{4});",
      "assert(solution.maximumBeauty({{10,1000}}, {5}) == vector<int>{0});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\n\nConstraints:\n1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
    "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:;\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]= sr[-1]: \n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n",
    "test_cases": [
      "assert Solution().checkValidString(\"()\") == True",
      "assert Solution().checkValidString(\"(*)\") == True",
      "assert Solution().checkValidString(\"(*))\") == True"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe greatest common divisor of an array is the largest integer that evenly divides all the array elements.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= nums[i], k <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int subarrayGCD(vector<int>& nums, int k) {\n        \n        int result = 0; // We may not have any subarray.\n        \n        int n = nums.size();\n        \n        for (int l = 0; l < n; l++)\n        {\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\n            for (int r = l; r < n; r++)\n            {\n                /* \n                We update our current_gcd value in the inner loop. \n                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. \n                If we found a subarray that has elements with gcd k, increment result.\n                We repeat that steps for each left anchor.\n                */ \n                current_gcd = customGCD(nums[l], nums[r]); \n                if (current_gcd == k)\n                    result++;\n            }\n        }\n        return result;\n    }\n};\n",
    "test_cases": [
      "assert(solution.subarrayGCD(vector<int>{9,3,1,2,6,3}, 3) == 4);",
      "assert(solution.subarrayGCD(vector<int>{4}, 7) == 0);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.\n\nConstraints:\nn == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
    "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().minScoreTriangulation(new int[]{1, 2, 3}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minScoreTriangulation(new int[]{3, 7, 4, 5}) != 144) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().minScoreTriangulation(new int[]{1, 3, 1, 4, 1, 5}) != 13) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nConstraints:\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.",
    "buggy_code": "\nclass Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'a'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n\n}\nclass Trie {\nprivate static Node root;\n    public Trie() {\n        root=new Node();\n    }\n    \n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n    \n    public boolean search(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return false;\n            }\n            node=node.get(word.charAt(i));\n        }\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node node=root;\n        for(int i=0;i<prefix.length();i++){\n            if(!node.contains(prefix.charAt(i))){\n                return false;\n            }\n            node=node.get(prefix.charAt(i));\n        }\n        return \"wrong string;\n    }\n}\n",
    "test_cases": [
      "Trie trie = new Trie();",
      "trie.insert(\"apple\");",
      "if (trie.search(\"apple\") != true) System.out.println(\"Test failed: search(\\\"apple\\\")\");",
      "if (trie.search(\"app\") != false) System.out.println(\"Test failed: search(\\\"app\\\")\");",
      "if (trie.startsWith(\"app\") != true) System.out.println(\"Test failed: startsWith(\\\"app\\\")\");",
      "trie.insert(\"app\");",
      "if (trie.search(\"app\") != true) System.out.println(\"Test failed: search(\\\"app\\\") after insert\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given a binary string s \u200b\u200b\u200b\u200b\u200bwithout leading zeros, return true\u200b\u200b\u200b if s contains at most one contiguous segment of ones. Otherwise, return false.\n\nConstraints:\n1 <= s.length <= 100\ns[i]\u200b\u200b\u200b\u200b is either '0' or '1'.\ns[0] is\u00a0'1'.",
    "buggy_code": "\nclass Solution {\n    public bool checkOnesSegment(String s) {\n        Integer count=0;\n         Integer pos=0;\n         String anotherString = null;\n       while(anotherString.charAt(pos)!='1\"){\n              pos++;\n            if(pos==anotherString.length()){\n                return true;\n            }\n          }\n          \n        for(int i=pos;i<=anotherString.length();i++){\n              if(anotherString.charAt(i)=='0'){\n                  count++;\n              }\n              else if(count>0&&anotherString.charAt(i)=='1'){\n                  return false;\n              }\n        } \n        return \"true;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().checkOnesSegment(\"1001\")) System.out.println(\"Test failed for input: 1001, expected: false\");",
      "if (new Solution().checkOnesSegment(\"110\")) System.out.println(\"Test failed for input: 110, expected: true\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n\nConstraints:\nm == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
    "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\npit()    return ans;\n    \n}\n",
    "test_cases": [
      "if (new Solution().numberOfBeams(new String[]{\"011001\",\"000000\",\"010100\",\"001000\"}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().numberOfBeams(new String[]{\"000\",\"111\",\"000\"}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.\n\nConstraints:\n1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
    "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n\n        int a=0;\n        int b=0;\n\n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return ValidateResult();\n\n    }\n\n    private boolean ValidateResult() {\n        \n    }\n}\n",
    "test_cases": [
      "if (new Solution().winnerOfGame(\"AAABABB\") != true) System.out.println(\"Test failed for input: AAABABB\");",
      "if (new Solution().winnerOfGame(\"AA\") != false) System.out.println(\"Test failed for input: AA\");",
      "if (new Solution().winnerOfGame(\"ABBBBBBBAAA\") != false) System.out.println(\"Test failed for input: ABBBBBBBAAA\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\nConstraints:\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
    "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n\n        undefinedObject test;  \n\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n",
    "test_cases": [
      "assert(solution.checkValidGrid({{0,11,16,5,20},{17,4,19,10,15},{12,1,8,21,6},{3,18,23,14,9},{24,13,2,7,22}}) == true);",
      "assert(solution.checkValidGrid({{0,3,6},{5,8,1},{2,7,4}}) == false);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.\n\nConstraints:\n1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104",
    "buggy_code": "\nclass Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar+1]-= seats\n\n        return list(accumulate(arr[:-1]))\n",
    "test_cases": [
      "assert Solution().corpFlightBookings([[1,2,10],[2,3,20],[2,5,25]], 5) == [10, 55, 45, 25, 25]",
      "assert Solution().corpFlightBookings([[1,2,10],[2,2,15]], 2) == [10, 25]"
    ],
    "language": "python3",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
    "buggy_code": "\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if not root:\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,ans)\n        return ans[1:]\n",
    "test_cases": [
      "assert Solution().inorderTraversal(TreeNode(1, None, TreeNode(2, TreeNode(3), None))) == [1, 3, 2]",
      "assert Solution().inorderTraversal(None) == []",
      "assert Solution().inorderTraversal(TreeNode(1)) == [1]"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  },
  {
    "task": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.\n\nConstraints:\n1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    var dp = function(i,s,prev,k,ct,n,dct {\n        if(k<0) {\n            return Number.POSITIVE_INFINITY;\n        }\n        if(i>=n+1){\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            return x;\n        }\n        if((i,prev,ct,k) in dct) {\n            return dct[(i,prev,ct,k)];\n        }\n        if(s[i]==prev){\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct);\n        } else{\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct);\n        }\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct);\n        dct[(i,prev,ct,k)]=Math.min(inc,exc);\n        return Math.min(inc,exc)\n    }\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n",
    "test_cases": [
      "assert Solution().getLengthOfOptimalCompression(\"aaabcccd\", 2) == 4",
      "assert Solution().getLengthOfOptimalCompression(\"aabbaa\", 2) == 2",
      "assert Solution().getLengthOfOptimalCompression(\"aaaaaaaaaaa\", 0) == 3"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "On a 0-indexed 8 x 8 chessboard, there can be multiple black queens ad one white king.\nYou are given a 2D integer array queens where queens[i] = [xQueeni, yQueeni] represents the position of the ith black queen on the chessboard. You are also given an integer array king of length 2 where king = [xKing, yKing] represents the position of the white king.\nReturn the coordinates of the black queens that can directly attack the king. You may return the answer in any order.\n\nConstraints:\n1 <= queens.length < 64\nqueens[i].length == king.length == 2\n0 <= xQueeni, yQueeni, xKing, yKing < 8\nAll the given positions are unique.",
    "buggy_code": "\nclass Solution {\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        boolean[][] q = new boolean[8][8]\n\t\t//Mark all the positions of queen on a 8 X 8 board.\n        for (int[] queen: queens) {\n            q[queen[0]][queen[1]] = true;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n\t\t//Specify all the moves of the queen\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\n        for(int i = 0; i < moves.length; i++)\n            int k = king[0] + moves[i][0];\n            int l = king[1] + moves[i][1];\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\n                if(q[k][l]){\n                    List<Integer> pair = new ArrayList<>();\n                    pair.add(k);\n                    pair.add(l);\n                    output.add(pair);\n                    break;\n                }\n                k = k + moves[i][0];\n                l = l + moves[i][1];\n            }\n        \n        return output;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().queensAttacktheKing(new int[][]{{0,1},{1,0},{4,0},{0,4},{3,3},{2,4}}, new int[]{0,0}).equals(Arrays.asList(Arrays.asList(0,1), Arrays.asList(1,0), Arrays.asList(3,3)))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().queensAttacktheKing(new int[][]{{0,0},{1,1},{2,2},{3,4},{3,5},{4,4},{4,5}}, new int[]{3,3}).equals(Arrays.asList(Arrays.asList(2,2), Arrays.asList(3,4), Arrays.asList(4,4)))) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.\nAnswers within 10-5 of the actual answer will be considered accepted.\n\nConstraints:\n20 <= arr.length <= 1000\narr.length is a multiple of 20.\n0 <= arr[i] <= 105",
    "buggy_code": "\nclass Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int i, k;\n        double mean;\n        /*sort(arr.begin(), arr.end());\n        k = 0.05*arr.size();\n        for(i=0 ; i<k ; i++)\n        {\n            arr.erase(arr.begin()+0);\n            arr.erase(arr.begin()+arr.size());\n        }\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();*/\n        return mean;\n    }\n};\n",
    "test_cases": [
      "assert(solution.trimMean(vector<int>{1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3}) == 2.00000);",
      "assert(solution.trimMean(vector<int>{6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0}) == 4.00000);",
      "assert(solution.trimMean(vector<int>{6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4}) == 4.77778);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two integer arrays\u00a0arr1 and arr2, return the minimum number of operations (possibly zero) needed\u00a0to make arr1 strictly increasing.\nIn one operation, you can choose two indices\u00a00 <=\u00a0i < arr1.length\u00a0and\u00a00 <= j < arr2.length\u00a0and do the assignment\u00a0arr1[i] = arr2[j].\nIf there is no way to make\u00a0arr1\u00a0strictly increasing,\u00a0return\u00a0-1.\n\nConstraints:\n1 <= arr1.length, arr2.length <= 2000\n0 <= arr1[i], arr2[i] <= 10^9",
    "buggy_code": "\nclass Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation = helper(i + 1, arr2[idx], arr1, arr2);\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    } \n}\n",
    "test_cases": [
      "if (new Solution().makeArrayIncreasing(new int[]{1,5,3,6,7}, new int[]{1,3,2,4}) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().makeArrayIncreasing(new int[]{1,5,3,6,7}, new int[]{4,3,1}) != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().makeArrayIncreasing(new int[]{1,5,3,6,7}, new int[]{1,6,3,3}) != -1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n\nConstraints:\nn == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
    "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
    "test_cases": [
      "assert Solution().numPermsDISequence(\"DID\") == 5",
      "assert Solution().numPermsDISequence(\"D\") == 1"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.\n\nConstraints:\n1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
    "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n):\n            if lcp[i][j] > 0:\n                if pattern[j] is not None and pattern[j] != pattern[i]:\n                    return ''\n                pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n",
    "test_cases": [
      "assert Solution().findTheString([[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]) == \"abab\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]) == \"aaaa\"",
      "assert Solution().findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]) == \"\""
    ],
    "language": "python3",
    "bug_type": "illegal indentation",
    "category": "syntax error"
  },
  {
    "task": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n\nFor example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.\n\nConstraints:\n1 <= n <= 1015",
    "buggy_code": "\nclass Solution:\n    def countGoodNumbers(self, n: int) -> int:\n        return (pow(5,(n - 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007\n",
    "test_cases": [
      "assert Solution().countGoodNumbers(1) == 5",
      "assert Solution().countGoodNumbers(4) == 400",
      "assert Solution().countGoodNumbers(50) == 564908303"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
    "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col <= COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n\n    def undefinedMethod(self):\n        self.countPositives(grid)\n",
    "test_cases": [
      "if (new Solution().countNegatives(new int[][]{{4,3,2,-1},{3,2,1,-1},{1,1,-1,-2},{-1,-1,-2,-3}}) != 8) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countNegatives(new int[][]{{3,2},{1,0}}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \nr\n\n\n",
    "test_cases": [
      "LRUCache lRUCache(2);",
      "assert(lRUCache.put(1, 1) == nullptr);",
      "assert(lRUCache.put(2, 2) == nullptr);",
      "assert(lRUCache.get(1) == 1);",
      "assert(lRUCache.put(3, 3) == nullptr);",
      "assert(lRUCache.get(2) == -1);",
      "assert(lRUCache.put(4, 4) == nullptr);",
      "assert(lRUCache.get(1) == -1);",
      "assert(lRUCache.get(3) == 3);",
      "assert(lRUCache.get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed integer array nums and a target element target.\nA target index is an index i such that nums[i] == target.\nReturn a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.\n\nConstraints:\n1 <= nums.length <= 100\n1 <= nums[i], target <= 100",
    "buggy_code": "\nclass Solution {\n    public List<Integer> targetIndices(int[] nums, int target) {\n        ArrayList <Integer> arr = new ArrayList<>();\n        Arrays.sort(nums);\n        \n            if(nums[i] == target){\n                arr.add(i);\n            }\n        }\n        return arr;\n    }\n}\n",
    "test_cases": [
      "if (!new Solution().targetIndices(new int[]{1,2,5,2,3}, 2).equals(Arrays.asList(1, 2))) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().targetIndices(new int[]{1,2,5,2,3}, 3).equals(Arrays.asList(3))) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().targetIndices(new int[]{1,2,5,2,3}, 5).equals(Arrays.asList(4))) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\n\nConstraints:\nThe number of nodes in the tree is in the range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\np and q will exist in the BST.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root = null || root == p || root == q)return root;\n\n        TreeNode left = lowestCommonAncestor(root.left, p , q);\n        TreeNode right = lowestCommonAncestor(root.right, p ,q);\n\n        if(left == null)return right;\n        if(right == null)return left;\n        else{\n            return root;\n        }\n    }\n}\n",
    "test_cases": [
      "if (new Solution().lowestCommonAncestor(buildTree(new Integer[]{6,2,8,0,4,7,9,null,null,3,5}), new TreeNode(2), new TreeNode(8)).val != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().lowestCommonAncestor(buildTree(new Integer[]{6,2,8,0,4,7,9,null,null,3,5}), new TreeNode(2), new TreeNode(4)).val != 2) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().lowestCommonAncestor(buildTree(new Integer[]{2,1}), new TreeNode(2), new TreeNode(1)).val != 2) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "misused == or =",
    "category": "syntax error"
  },
  {
    "task": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= limit <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        int ans=1,l=0,h=0,count=0;\n        map<int,int> mp;\n        mp[nums[l]]++;\n        \n        while(h<nums.size()){\n            mp[nums[h]]++;\n            count++\n            \n            if(prev(mp.end())->first - mp.begin()->first <= limit){\n                ans=max(ans,count);\n            }else{\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\n                    else mp.erase(nums[l]);\n                    count--;\n                    l++;\n                }\n            }\n            h++;\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.longestSubarray(vector<int>{8,2,4,7}, 4) == 2);",
      "assert(solution.longestSubarray(vector<int>{10,1,2,4,7,2}, 5) == 4);",
      "assert(solution.longestSubarray(vector<int>{4,2,2,2,4,4,2,2}, 0) == 3);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.punishmentNumber(10) == 182);",
      "assert(solution.punishmentNumber(37) == 1478);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each\u00a0of the two arrays.\n\nConstraints:\n1 <= words1.length, words2.length <= 1000\n1 <= words1[i].length, words2[j].length <= 30\nwords1[i] and words2[j] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public int countWords(String[] words1, String[] words2) {\n        Map<String, Integer> map1 = new HashMap<>();\n        Map<String, Integer> map2 = new HashMap<>();\n\n        for (String s: words1)\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\n            else map1.put(s, 1);\n\n        for (String s: words2)\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\n            else map2.put(s, 1);\n        \n        int count = 0;\n        for(String i : words2){\n            if(map1.get(i) == 1 && map2.getOrDefault(i+1,0) == 1 )\n                count++;\n            return count;\n        }\n        return 0;\n    }\n}\n\n",
    "test_cases": [
      "if (new Solution().countWords(new String[]{\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"}, new String[]{\"amazing\",\"leetcode\",\"is\"}) != 2) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countWords(new String[]{\"b\",\"bb\",\"bbb\"}, new String[]{\"a\",\"aa\",\"aaa\"}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().countWords(new String[]{\"a\",\"ab\"}, new String[]{\"a\",\"a\",\"a\",\"ab\"}) != 1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\nReturn the shuffled string.\n\nConstraints:\ns.length == indices.length == n\n1 <= n <= 100\ns consists of only lowercase English letters.\n0 <= indices[i] < n\nAll values of indices are unique.",
    "buggy_code": "\nclass Solution {\npublic:\n    string restoreString(string s, vector<int>& ind) {\n        int n = s.size();\n        string ans(n, '.');\n        for (let i = 0; i < n; i++) {\n            ans[ind[i]] = s[i];\n        } \n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.restoreString(\"codeleet\", vector<int>{4,5,6,7,0,2,1,3}) == \"leetcode\");",
      "assert(solution.restoreString(\"abc\", vector<int>{0,1,2}) == \"abc\");"
    ],
    "language": "cpp",
    "bug_type": "illegal keywords",
    "category": "reference error"
  },
  {
    "task": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00\n\nConstraints:\n0 <= celsius <= 1000",
    "buggy_code": "\n```java\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        UndefinedObject obj;  \n        arr[2 = (obj.celsius * 9.0/5.0) + 32.0;\n        arr[0] = obj.celsius + 237.15;\n        return arr;\n    }\n}\n```\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().convertTemperature(36.50), new double[]{309.65000, 97.70000})) System.out.println(\"Test failed for input 36.50\");",
      "if (!Arrays.equals(new Solution().convertTemperature(122.11), new double[]{395.26000, 251.79800})) System.out.println(\"Test failed for input 122.11\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\n\nConstraints:\n1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
    "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if nums[i] in s:\n                return nums[i]\n        return -1\n",
    "test_cases": [
      "assert Solution().findMaxK([-1, 2, -3, 3]) == 3",
      "assert Solution().findMaxK([-1, 10, 6, 7, -7, 1]) == 7",
      "assert Solution().findMaxK([-10, 8, 6, 7, -2, -3]) == -1"
    ],
    "language": "python3",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.\n\nConstraints:\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
    "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n",
    "test_cases": [
      "assert Solution().closestMeetingNode([2, 2, 3, -1], 0, 1) == 2",
      "assert Solution().closestMeetingNode([1, 2, -1], 0, 2) == 2"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\n\nConstraints:\n1 <= n <= 19",
    "buggy_code": "\nclass Solution {\npublic:\nint solve(int n)\n{\n    vector<int>dp(n+1,0);    \n    dp[0]=dp[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j= 0;j<=i;j++)\n        {\n            dp[i]+= dp[j-1]*dp[i-j];\n        }\n    }\n        return dp[n];\n}\n    int numTrees(int n) {\n    return solve(n); \n    }\n};\n",
    "test_cases": [
      "assert(solution.numTrees(3) == 5);",
      "assert(solution.numTrees(1) == 1);"
    ],
    "language": "cpp",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.\n\nConstraints:\n2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
    "buggy_code": "\nfrom typing import List\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,self.computeMaxAndMin(val1))\n        ans=max(ans,self.computeMaxAndMin(val2))\n        ans=max(ans,self.computeMaxAndMin(val3))\n        ans=max(ans,self.computeMaxAndMin(val4))\n        return ans\n",
    "test_cases": [
      "assert Solution().maxAbsValExpr([1, 2, 3, 4], [-1, 4, 5, 6]) == 13",
      "assert Solution().maxAbsValExpr([1, -2, -5, 0, 10], [0, -2, -1, -7, -4]) == 20"
    ],
    "language": "python3",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n\n/**/\n=\n",
    "test_cases": [
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3))) != true) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2))) != false) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2))) != false) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.\nThe ith item is said to match the rule if one of the following is true:\n\nruleKey == \"type\" and ruleValue == typei.\nruleKey == \"color\" and ruleValue == colori.\nruleKey == \"name\" and ruleValue == namei.\n\nReturn the number of items that match the given rule.\n\nConstraints:\n1 <= items.length <= 104\n1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10\nruleKey is equal to either \"type\", \"color\", or \"name\".\nAll strings consist only of lowercase letters.",
    "buggy_code": "\nclass Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;  \n\n        String type = \"type;  \n        int i = 0;  \n\n        if (ruleKey.equals(type)) {\n            i = 0;  \n        }\n        String color = \"color\";\n        if (ruleKey.equals(color)) {\n            i = 1;  \n        }\n        String name = \"name\";\n        if (ruleKey.equals(name)) {\n            i = 2;  \n        }\n\n        for (int j = 0; j < items.size(); j++) {\n            if (items.get(j).get(i).equals(ruleValue)) {\n                count++;  \n            }\n        }\n        \n        return count;  \n    }\n}\n",
    "test_cases": [
      "if (new Solution().countMatches(Arrays.asList(Arrays.asList(\"phone\", \"blue\", \"pixel\"), Arrays.asList(\"computer\", \"silver\", \"lenovo\"), Arrays.asList(\"phone\", \"gold\", \"iphone\")), \"color\", \"silver\") != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().countMatches(Arrays.asList(Arrays.asList(\"phone\", \"blue\", \"pixel\"), Arrays.asList(\"computer\", \"silver\", \"phone\"), Arrays.asList(\"phone\", \"gold\", \"iphone\")), \"type\", \"phone\") != 2) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "unclosed string",
    "category": "syntax error"
  },
  {
    "task": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n",
    "test_cases": [
      "assert(solution.maximumGap(vector<int>{3, 6, 9, 1}) == 3);",
      "assert(solution.maximumGap(vector<int>{10}) == 0);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\n\nConstraints:\n1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
    "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in myList]\n        return ans\n",
    "test_cases": [
      "assert Solution().getAncestors(8, [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]) == [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]",
      "assert Solution().getAncestors(5, [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]) == [[],[0],[0,1],[0,1,2],[0,1,2,3]]"
    ],
    "language": "python3",
    "bug_type": "undefined objects",
    "category": "reference error"
  },
  {
    "task": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
    "buggy_code": "\nclass Solution {\npublic:\n    using int2 = pair<int, int>;\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        int2 start;\n        // Scan the start and KeyMask\n        int KeyMask = 0;\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                char c = grid[i][j];\n                int2 pos = {i, j};\n                if (c == '@')\n                    start = pos;  // Store the position of the starting point\n                if ('a' <= c && c <= 'z')\n                    KeyMask |= (1 << (c - 'a'));  // Set the corresponding bit in KeyMask for each key found\n            }\n        }\n        // Record the visiting status for every key status\n        vector<vector<vector<bool>>> \n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, \"0));\n\n        // [i, j, key state, distance]\n        queue<tuple<int, int, int, int>> q;\n        auto [i0, j0] = start;\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\n\n        while (!q.empty()) {\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\n            q.pop();\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\n            for (auto [a, b] : adj) {\n                if (a < 0 || a > n || b < 0 || b > m || grid[a][b] == '#')\n                    continue;  // Skip if the next position is out of bounds or a wall ('#')\n                char c = grid[a][b];\n                // c is a key\n                if ('a' <= c && c <= 'z') {\n                    int keyIdx = c - 'a';  // Calculate the index of the key\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\n                }\n                // c is a lock\n                else if ('A' <= c && c <= 'F') {\n                    int lockIdx = c - 'A';  // Calculate the index of the lock\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n                }\n                // c is ',' or '@'\n                else if (visit[a][b][keyState])\n                    continue;  // Skip if this key state has been visited before at this position\n\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n            }\n        }\n\n        return -1;  // If all keys cannot be collected, return -1\n    }\n};\n",
    "test_cases": [
      "assert(solution.shortestPathAllKeys(vector<string>{\"@.a..\",\"###.#\",\"b.A.B\"}) == 8);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@..aA\",\"..B#.\",\"....b\"}) == 6);",
      "assert(solution.shortestPathAllKeys(vector<string>{\"@Aa\"}) == -1);"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given a non-empty\u00a0array of integers nums, every element appears twice except for one. Find that single one.\nYou must\u00a0implement a solution with a linear runtime complexity and use\u00a0only constant\u00a0extra space.\n\nConstraints:\n1 <= nums.length <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\nEach element in the array appears twice except for one element which appears only once.",
    "buggy_code": "\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]] = 1;\n        }\n        for(auto m:mp){\n            if(m.second==1){\n                return m.first;\n            }\n        }\n        return -1;\n    }\n};\n",
    "test_cases": [
      "assert(solution.singleNumber(vector<int>{2,2,1}) == 1);",
      "assert(solution.singleNumber(vector<int>{4,1,2,1,2}) == 4);",
      "assert(solution.singleNumber(vector<int>{1}) == 1);"
    ],
    "language": "cpp",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\nConstraints:\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
    "buggy_code": "\nclass Solution {   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/prv\n   }\n\n   prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return\n",
    "test_cases": [
      "assert(solution.longestIdealString(\"acfgbd\", 2) == 4);",
      "assert(solution.longestIdealString(\"abcd\", 3) == 4);"
    ],
    "language": "cpp",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.\n\nConstraints:\n1 <= n <= 1000",
    "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        \n        return checkAdditionalCondition(ans);\n    }\n};\n",
    "test_cases": [
      "assert(solution.punishmentNumber(10) == 182);",
      "assert(solution.punishmentNumber(37) == 1478);"
    ],
    "language": "cpp",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "For two strings s and t, we say \"t divides s\" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).\nGiven two strings str1 and str2, return the largest string x such that x divides both str1 and str2.\n\nConstraints:\n1 <= str1.length, str2.length <= 1000\nstr1 and str2 consist of English uppercase letters.",
    "buggy_code": "\nclass Solution {\npublic:\n    string gcdOfStrings(string str1, string str2) {\n\n        if((str1+str2==str2+str1)\n        {\n            return str1.substr(0,gcd(str1.length(),str2.length()));\n        }\n        else{\n            return \"\";\n        }\n        \n    }\n};\n",
    "test_cases": [
      "assert(solution.gcdOfStrings(\"ABCABC\", \"ABC\") == \"ABC\");",
      "assert(solution.gcdOfStrings(\"ABABAB\", \"ABAB\") == \"AB\");",
      "assert(solution.gcdOfStrings(\"LEET\", \"CODE\") == \"\");"
    ],
    "language": "cpp",
    "bug_type": "unclosed parentheses",
    "category": "syntax error"
  },
  {
    "task": "Given a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\nbool find(int target) Returns true if the target value exists in the recovered binary tree.\n\nConstraints:\nTreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 104]\nTotal calls of find() is between [1, 104]\n0 <= target <= 106",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1);\n        recover(root->right, 2 * x + 2);\n    }\n    \n    FindElements(TreeNode* root) {\n        init(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */\n",
    "test_cases": [
      "assert(findElements.find(1) == false);",
      "assert(findElements.find(2) == true);",
      "assert(findElements.find(1) == true);",
      "assert(findElements.find(3) == true);",
      "assert(findElements.find(5) == false);",
      "assert(findElements.find(2) == true);",
      "assert(findElements.find(3) == false);",
      "assert(findElements.find(4) == false);",
      "assert(findElements.find(5) == true);"
    ],
    "language": "cpp",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\n\nCreate a root node whose value is the maximum value in nums.\nRecursively build the left subtree on the subarray prefix to the left of the maximum value.\nRecursively build the right subtree on the subarray suffix to the right of the maximum value.\n\nReturn the maximum binary tree built from nums.\n\nConstraints:\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nAll integers in nums are unique.",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s = e) return new TreeNode(arr[s]);\n       \n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1)\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++){\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n\n",
    "test_cases": [
      "if (!Arrays.equals(serializeTree(new Solution().constructMaximumBinaryTree(new int[]{3,2,1,6,0,5})), new int[]{6,3,5,-1,2,0,-1,-1,1})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(serializeTree(new Solution().constructMaximumBinaryTree(new int[]{3,2,1})), new int[]{3,-1,2,-1,1})) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "There is a function signFunc(x) that returns:\n\n1 if x is positive.\n-1 if x is negative.\n0 if x is equal to 0.\n\nYou are given an integer array nums. Let product be the product of all values in the array nums.\nReturn signFunc(product).\n\nConstraints:\n1 <= nums.length <= 1000\n-100 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution { \n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v\n    return getSign(z);\n  }\n\n}\n",
    "test_cases": [
      "if (new Solution().arraySign(new int[]{-1, -2, -3, -4, 3, 2, 1}) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().arraySign(new int[]{1, 5, 0, 2, -3}) != 0) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().arraySign(new int[]{-1, 1, -1, 1, -1}) != -1) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.\n\nConstraints:\n1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n",
    "test_cases": [
      "assert Solution().longestValidSubstring(\"cbaaaabc\", [\"aaa\", \"cb\"]) == 4",
      "assert Solution().longestValidSubstring(\"leetcode\", [\"de\", \"le\", \"e\"]) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\ngrid[i][j] is either 0 or 1.",
    "buggy_code": "\nclass Solution {\n    public int max = 0;\n    public int sum = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length;i++)\n        {\n            for(int j = 0; j<grid[i].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    sum = 0; \n                    dfs(grid,i,j);\n                    max  = Math.max(max,sum);\n                }\n            }\n        }\n\n        return max;\n    }\n\n    private void dfs(int[][] grid ,int r ,int c)\n    {\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==1)\n        {\n            return ;\n        }\n\n        sum++;\n        grid[r][c] = 0;\n        dfs(grid,r,c+1);\n        dfs(grid,r,c-1);\n        dfs(grid,r+1,c);\n        dfs(grid,r-1,c);\n    }\n}\n",
    "test_cases": [
      "if (new Solution().maxAreaOfIsland(new int[][]{{0,0,1,0,0,0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,1,1,1,0,0,0},{0,1,1,0,1,0,0,0,0,0,0,0,0},{0,1,0,0,1,1,0,0,1,0,1,0,0},{0,1,0,0,1,1,0,0,1,1,1,0,0},{0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,1,1,0,0,0},{0,0,0,0,0,0,0,1,1,0,0,0,0}}) != 6) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().maxAreaOfIsland(new int[][]{{0,0,0,0,0,0,0,0}}) != 0) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "condition error",
    "category": "logic error"
  },
  {
    "task": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.\n\nConstraints:\n1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
    "buggy_code": "\nclass Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.maximumBeauty({{1,2},{3,2},{2,4},{5,6},{3,5}}, {1,2,3,4,5,6}) == vector<int>{2,4,5,5,6,6});",
      "assert(solution.maximumBeauty({{1,2},{1,2},{1,3},{1,4}}, {1}) == vector<int>{4});",
      "assert(solution.maximumBeauty({{10,1000}}, {5}) == vector<int>{0});"
    ],
    "language": "cpp",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.\n\nConstraints:\n1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((get(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return nums\n\n",
    "test_cases": [
      "assert Solution().medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
      "assert Solution().medianSlidingWindow([1,2,3,4,2,3,1,4,2], 3) == [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.\n\nConstraints:\n1 <= primeFactors <= 109",
    "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result\n",
    "test_cases": [
      "assert Solution().maxNiceDivisors(5) == 6",
      "assert Solution().maxNiceDivisors(8) == 18"
    ],
    "language": "python3",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.\n\nConstraints:\n2 <= nums.length <= 500\n0 <= nums[i] <= 100",
    "buggy_code": "\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length+1],k=0;\n        /*for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<=nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }*/\n      return res;\n    }\n\n    public int[] callUndefinedMethod() {\n        undefinedMethod();\n        return new int[0];\n    }\n}\n",
    "test_cases": [
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{8,1,2,2,3}), new int[]{4,0,1,1,3})) System.out.println(\"Test case 1 failed\");",
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{6,5,4,8}), new int[]{2,1,0,3})) System.out.println(\"Test case 2 failed\");",
      "if (!Arrays.equals(new Solution().smallerNumbersThanCurrent(new int[]{7,7,7,7}), new int[]{0,0,0,0})) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.\n\nConstraints:\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n0 <= grid[i][j] <= 105\ngrid[0][0] == 0",
    "buggy_code": "\nclass Solution {\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\n    \n    public int minimumTime(int[][] grid) {\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\n            return -1;\n        }\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        \n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\n        \n        boolean[][] visited = new boolean[m][n];\n        \n        while (!heap.isEmpty()) {\n            int[] entry = heap.poll();\n            int row = entry[0];\n            int col = entry[1];\n            int time = entry[2];\n            if (row == m - 1 && col == n - 1) {\n                return time;\n            }\n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = true;\n                \n            for (int[] dir : DIRS) {\n                int r = row + dir[0];\n                int c = col + dir[1];\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\n                    continue;\n                }\n                \n                if (grid[r][c] <= time + 1) {\n                    // if it is possible to move to neighbor, do it\n                    heap.offer(new int[] { r, c, time + 1 });\n                } else {\n                    // If we cant move to neighbor yet, we can hop to the previous cell\n                    // and back to current cell as many times as we need to until\n                    // sufficient time has passed.\n                    int diff = grid[r][c] - time;\n                    if (diff % 2 == 1) {\n                        heap.offer(new int[] { r, c, grid[r][c] });\n                    } else {\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\n                    }\n                }\n            }\n        }\n        return printTime(); \n    }\n}\n",
    "test_cases": [
      "if (new Solution().minimumTime(new int[][]{{0,1,3,2},{5,1,2,5}}) != 7) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().minimumTime(new int[][]{{0,2,4},{3,2,1},{1,0,4}}) != -1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "undefined methods",
    "category": "reference error"
  },
  {
    "task": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.\n\nConstraints:\n1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
    "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums\n        for i in range(1, n):\n            for ''j in range(i):'' \n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += self.undifned_method(dp[j][diff])\n        return total\n",
    "test_cases": [
      "assert Solution().numberOfArithmeticSlices([2, 4, 6, 8, 10]) == 7",
      "assert Solution().numberOfArithmeticSlices([7, 7, 7, 7, 7]) == 16"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "Given a string s, reverse the string according to the following rules:\n\nAll the characters that are not English letters remain in the same position.\nAll the English letters (lowercase or uppercase) should be reversed.\n\nReturn s after reversing it.\n\nConstraints:\n1 <= s.length <= 100\ns consists of characters with ASCII values in the range [33, 122].\ns does not contain '\\\"' or '\\\\'.",
    "buggy_code": "\nclass Solution {\npublic:\n    str reverseOnlyLetters(string s) \n    {\n      int i=0,j=s.length()-1;\n      while(i<=j)\n      {\n        if(isalpha(s[i])&&isalpha(s[j]))\n        {\n            swap(s[i],s[j]);\n            i--;\n            j++;\n        }\n        else\n        {\n            if(!isalpha(s[i]))\n            {\n                i++;\n            }\n            if(!isalpha(s[j]))\n            {\n                j--;\n            }\n        }\n      }\n      return s;\n    }\n};\n",
    "test_cases": [
      "assert(solution.reverseOnlyLetters(\"ab-cd\") == \"dc-ba\");",
      "assert(solution.reverseOnlyLetters(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\");",
      "assert(solution.reverseOnlyLetters(\"Test1ng-Leet=code-Q!\") == \"Qedo1ct-eeLg=ntse-T!\");"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two integer arrays startTime and endTime and given an integer queryTime.\nThe ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\nReturn the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.\n\nConstraints:\nstartTime.length == endTime.length\n1 <= startTime.length <= 100\n1 <= startTime[i] <= endTime[i] <= 1000\n1 <= queryTime <= 1000",
    "buggy_code": "\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n    int cnt=0;\n        for(int i=0;i<n;i++)\n        { /*\n            if(endTime[i]>=queryTime && queryTime>=startTime[i] )\n            {\n                cnt++;\n            } */\n        }\n        return cnt;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().busyStudent(new int[]{1,2,3}, new int[]{3,2,7}, 4) != 1) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().busyStudent(new int[]{4}, new int[]{4}, 4) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "illegal comment",
    "category": "syntax error"
  },
  {
    "task": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
    "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n",
    "test_cases": [
      "assert Solution().closestCost([1, 7], [3, 4], 10) == 10",
      "assert Solution().closestCost([2, 3], [4, 5, 100], 18) == 17",
      "assert Solution().closestCost([3, 10], [2, 5], 9) == 8"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sort(no_nums)[-k-1]\n",
    "test_cases": [
      "assert Solution().findKthLargest([3,2,1,5,6,4], 2) == 5",
      "assert Solution().findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4"
    ],
    "language": "python3",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val !== q.val) {\n            return false;\n        }\n        \n        return checkSubTree(p.left, q./*left*/) && checkSubTree(p.right, q.right);    \n    }\n}\n",
    "test_cases": [
      "if (!new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3)))) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2)))) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2)))) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "quadruple",
    "category": "multiple error"
  },
  {
    "task": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\nmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.\n\nConstraints:\nThe number of nodes in the tree is in the range [2, 105].\n1 <= Node.val <= 106\nn == queries.length\n1 <= n <= 105\n1 <= queries[i] <= 106",
    "buggy_code": "\n\nclass Solution {\npublic:\n        void dfs(TreeNode* root, List<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv);\n            bv.add(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n\t\t\n        int min1(List<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                ans= bv[mid];\n                i= mid+1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(vector<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        vector<int> bv;\n        vector<vector<int>> ans;\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(LisArayListArayListLisLisArayListArayListbv,q);\n            ans.add({lb,ub});\n        }\n        return ans;\n    }\n    \n};\n",
    "test_cases": [
      "assert(solution.closestNodes(createTree({6,2,13,1,4,9,15,null,null,null,null,null,null,14}), {2,5,16}) == vector<vector<int>>{{2,2},{4,6},{15,-1}});",
      "assert(solution.closestNodes(createTree({4,null,9}), {3}) == vector<vector<int>>{{-1,4}});"
    ],
    "language": "cpp",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.\n\nConstraints:\nn == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
    "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        \n        self.helper(matrix, dp_row, dp_col)\n\n    def helper(self, matrix, dp_row, dp_col):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n\n",
    "test_cases": [
      "assert Solution().checkValid([[1,2,3],[3,1,2],[2,3,1]]) == True",
      "assert Solution().checkValid([[1,1,1],[1,2,3],[1,2,3]]) == False"
    ],
    "language": "python3",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n\nConstraints:\n1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
    "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n        }\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
    "test_cases": [
      "if (!new Solution().smallestEquivalentString(\"parker\", \"morris\", \"parser\").equals(\"makkek\")) System.out.println(\"Test case 1 failed\");",
      "if (!new Solution().smallestEquivalentString(\"hello\", \"world\", \"hold\").equals(\"hdld\")) System.out.println(\"Test case 2 failed\");",
      "if (!new Solution().smallestEquivalentString(\"leetcode\", \"programs\", \"sourcecode\").equals(\"aauaaaaada\")) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "operation error",
    "category": "logic error"
  },
  {
    "task": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
    "buggy_code": "\nclass Solution {\npublic:\n    long long findTheArrayConcVal(vector<int>& nums) {\n        int i = 0,j=nums.size()-1,x,y;\n        long long int ans=0;\n        while(i<j){\n            x = nums[i];\n            y = 0;\n            while(x){\n                y++;\n                x /= 10;\n            }\n            ans += (nums[i]*1LL*pow(10,y)+nums[j]);\n            i++;\n            j--;\n        }\n        if(i==j){\n            ans += nums[i];\n        }\n        return ans;\n    }\n};\n",
    "test_cases": [
      "assert(solution.findTheArrayConcVal(vector<int>{7,52,2,4}) == 596);",
      "assert(solution.findTheArrayConcVal(vector<int>{5,14,13,8,12}) == 673);"
    ],
    "language": "cpp",
    "bug_type": "variable error",
    "category": "logic error"
  },
  {
    "task": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
    "buggy_code": "\n\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n\ncheckubcheckub\n",
    "test_cases": [
      "if (!new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(3)), new TreeNode(1, new TreeNode(2), new TreeNode(3)))) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), null), new TreeNode(1, null, new TreeNode(2)))) System.out.println(\"Test case 2 failed\");",
      "if (new Solution().isSameTree(new TreeNode(1, new TreeNode(2), new TreeNode(1)), new TreeNode(1, new TreeNode(1), new TreeNode(2)))) System.out.println(\"Test case 3 failed\");"
    ],
    "language": "java",
    "bug_type": "triple",
    "category": "multiple error"
  },
  {
    "task": "You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty:\n\nFrom each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\nIdentify the highest number amongst all those removed in step 1. Add that number to your score.\n\nReturn the final score.\n\nConstraints:\n1 <= nums.length <= 300\n1 <= nums[i].length <= 500\n0 <= nums[i][j] <= 103",
    "buggy_code": "\nclass Solution {\n    public int matrixSum(int[][] nums) {\n        int score = 0;\n        int n = nums.length\n        int m = nums[0].length;\n        for(int[] a :nums)\n        {\n            Arrays.sort(a);\n        }\n        for(int i=0;i<=m;i++)\n        {\n            int max = 0;\n            for(int j=0;j<n;j++)\n            {\n                max = Math.max(max,nums[j][i]);\n            }\n            score+=max;\n        }\n        return score;\n    }\n}\n",
    "test_cases": [
      "if (new Solution().matrixSum(new int[][]{{7,2,1},{6,4,2},{6,5,3},{3,2,1}}) != 15) System.out.println(\"Test case 1 failed\");",
      "if (new Solution().matrixSum(new int[][]{{1}}) != 1) System.out.println(\"Test case 2 failed\");"
    ],
    "language": "java",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
    "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
    "test_cases": [
      "assert Solution().findMedianSortedArrays([1, 3], [2]) == 2.00000",
      "assert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.50000"
    ],
    "language": "python3",
    "bug_type": "double",
    "category": "multiple error"
  },
  {
    "task": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
    "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};\n",
    "test_cases": [
      "assert(LRUCache(2).put(1, 1) == nullptr);",
      "assert(LRUCache(2).put(2, 2) == nullptr);",
      "assert(LRUCache(2).get(1) == 1);",
      "assert(LRUCache(2).put(3, 3) == nullptr);",
      "assert(LRUCache(2).get(2) == -1);",
      "assert(LRUCache(2).put(4, 4) == nullptr);",
      "assert(LRUCache(2).get(1) == -1);",
      "assert(LRUCache(2).get(3) == 3);",
      "assert(LRUCache(2).get(4) == 4);"
    ],
    "language": "cpp",
    "bug_type": "missing colons",
    "category": "syntax error"
  },
  {
    "task": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.\n\nConstraints:\n1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
    "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n",
    "test_cases": [
      "assert Solution().longestValidSubstring(\"cbaaaabc\", [\"aaa\", \"cb\"]) == 4",
      "assert Solution().longestValidSubstring(\"leetcode\", [\"de\", \"le\", \"e\"]) == 4"
    ],
    "language": "python3",
    "bug_type": "faulty indexing",
    "category": "reference error"
  }
]
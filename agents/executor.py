# -*- coding: utf-8 -*-
"""executor_all.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wYH282IDe_R7WGwiUa0AZpWnhWQEc5j3
"""

import subprocess
import tempfile
import os
import sys
from typing import List, Dict

class CodeExecutor:
    def __init__(self, timeout: int = 5):
        self.timeout = timeout

    def run_code(self, code: str, test_cases: List[str], language: str = "python") -> Dict:
        """
        Executes code in specified language with test cases.
        Supported languages: python (default), cpp, java

        Returns: {
            "stdout": str,
            "stderr": str,
            "exit_code": int,
            "success": bool
        }
        """

        # Prepare code with necessary imports and dependencies
        if language == "python3":
            # Check for type annotations and add imports
            combined_code = code + "\n".join(test_cases)
            missing_imports = []
            if "Optional[" in code and "from typing import Optional" not in code:
                missing_imports.append("from typing import Optional")
            if "List[" in code and "from typing import List" not in code:
                missing_imports.append("from typing import List")
            if "Dict[" in code and "from typing import Dict" not in code:
                missing_imports.append("from typing import Dict")
            if "Node" in combined_code and "class Node" not in code:
                if "from collections import" not in code and "deque" not in code:
                    missing_imports.append("from collections import deque")
                missing_imports.append("""
class Node:
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

    def serialize(self):
        result = []
        queue = deque([self])

        while queue:
            current = queue.popleft()
            if current is None:
                result.append(-1)
                continue
            result.append(current.val)
            queue.append(current.left)
            queue.append(current.right)

        # Remove trailing None markers
        while result and result[-1] == -1:
            result.pop()

        return result
""")

            if "TreeNode" in combined_code and "class TreeNode" not in code:
                if "from collections import" not in code and "deque" not in code:
                    missing_imports.append("from collections import deque")
                missing_imports.append("""
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
""")
            if "ListNode" in combined_code and "class ListNode" not in code:
               if "from collections import" not in code and "deque" not in code:
                    missing_imports.append("from collections import deque")
               missing_imports.append("""
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
""")
            if any(x in code for x in ["Counter(", "defaultdict(", "deque("]) and "from collections import" not in code:
                missing_imports.append("from collections import defaultdict, Counter, deque")

            if any(x in code for x in ["heappush", "heappop"]) and "import heapq" not in code:
                missing_imports.append("import heapq")

            if "math." in code and "import math" not in code:
                missing_imports.append("import math")
            # Add imports at the beginning
            if missing_imports:
                code = "\n".join(missing_imports) + "\n\n" + code

            formatted_tests = "\n".join(test_cases)
            full_script = f"{code}\n\n{formatted_tests}"

        elif language == "cpp":
            # Check for missing headers
            combined_code = code + "\n".join(test_cases)
            missing_headers = []
            if "assert(" in "".join(test_cases) and "#include <cassert>" not in code:
                missing_headers.append("#include <cassert>")
            if "vector" in code and "#include <vector>" not in code:
                missing_headers.append("#include <vector>")
            # Adding more as needed
            if "string" in code and "#include <string>" not in code:
                missing_headers.append("#include <string>")

            if any(x in code for x in ["map<", "unordered_map"]) and "#include <unordered_map>" not in code:
                missing_headers.append("#include <unordered_map>")

            if any(x in code for x in ["set<", "unordered_set"]) and "#include <unordered_set>" not in code:
                missing_headers.append("#include <unordered_set>")

            if "algorithm" not in code and any(x in code for x in ["sort(", "max(", "min("]):
                missing_headers.append("#include <algorithm>")

            if "cmath" not in code and any(x in code for x in ["sqrt(", "pow(", "abs("]):
                missing_headers.append("#include <cmath>")

            # For Node/TreeNode/ListNode structures, we need certain headers
            needs_tree_structures = any(x in combined_code for x in ["Node", "TreeNode", "ListNode"])

            # Add vector for serialization methods and tree/list operations
            if needs_tree_structures and "#include <vector>" not in code:
                missing_headers.append("#include <vector>")

            # Add queue for level-order traversals in tree operations
            if needs_tree_structures and "#include <queue>" not in code:
                missing_headers.append("#include <queue>")

            # Node definition needs to come after all includes
            node_definitions = []

            if "Node" in combined_code and "struct Node" not in code:
                node_definitions.append("""
struct Node {
    int val;
    Node* left;
    Node* right;
    Node* next;
    Node() : val(0), left(nullptr), right(nullptr), next(nullptr) {}
    Node(int x) : val(x), left(nullptr), right(nullptr), next(nullptr) {}
    Node(int x, Node* left, Node* right) : val(x), left(left), right(right), next(nullptr) {}

    std::vector<int> serialize() {
        std::vector<int> result;
        std::queue<Node*> q;
        q.push(this);

        while (!q.empty()) {
            Node* current = q.front();
            q.pop();

            if (current == nullptr) {
                result.push_back(-1);
                continue;
            }

            result.push_back(current->val);
            q.push(current->left);
            q.push(current->right);
        }

        // Remove trailing null markers
        while (!result.empty() && result.back() == -1) {
            result.pop_back();
        }

        return result;
    }
};
""")

            if "ListNode" in combined_code and "struct ListNode" not in code:
                node_definitions.append("""
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
""")

            if "TreeNode" in combined_code and "struct TreeNode" not in code:
                node_definitions.append("""
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
""")
            # Add headers at the beginning
            if missing_headers:
                if code.strip().startswith("#include"):
                    # Find the last include statement
                    last_include = 0
                    for i, line in enumerate(code.split("\n")):
                        if line.strip().startswith("#include"):
                            last_include = i
                    code_lines = code.split("\n")
                    for header in missing_headers:
                        code_lines.insert(last_include + 1, header)
                    code = "\n".join(code_lines)
                else:
                    code = "\n".join(missing_headers) + "\n" + code

            # Add node definitions after includes
            if node_definitions:
                if code.strip().startswith("#include"):
                    # Find the last include statement
                    last_include = 0
                    for i, line in enumerate(code.split("\n")):
                        if line.strip().startswith("#include"):
                            last_include = i
                    code_lines = code.split("\n")
                    for definition in node_definitions:
                        code_lines.insert(last_include + 1, definition)
                    code = "\n".join(code_lines)
                else:
                    code = "\n".join(node_definitions) + "\n" + code


            # Fix case of solution instance
            if "solution." in "".join(test_cases):
                indented_tests = '\n'.join(f'    {test.replace("solution.", "sol.")}' for test in test_cases)
            else:
                indented_tests = '\n'.join(f'    {test}' for test in test_cases)

            # Create the main function with a proper instance of Solution
            full_script = f"{code}\n\nint main() {{\n    Solution sol;\n{indented_tests}\n    return 0;\n}}"
###
        elif language == "java":

            combined_code = code + "\n".join(test_cases)

            missing_imports = []
            if "Arrays" in code or "Arrays" in "".join(test_cases):
                missing_imports.append("import java.util.Arrays;")
            if "ArrayList" in code or "List<" in code:
                missing_imports.append("import java.util.ArrayList;")
                missing_imports.append("import java.util.List;")
            if "PriorityQueue" in code:
                missing_imports.append("import java.util.PriorityQueue;")
            if "HashMap" in code or "Map<" in code:
                missing_imports.append("import java.util.HashMap;")
                missing_imports.append("import java.util.Map;")
            if "Queue" in code or "LinkedList" in code:
                missing_imports.append("import java.util.Queue;")
                missing_imports.append("import java.util.LinkedList;")
            if "TreeNode" in combined_code:
                missing_imports.append("import java.util.Queue;")
                missing_imports.append("import java.util.LinkedList;")
            if "ListNode" in combined_code:
                missing_imports.append("import java.util.Queue;")
                missing_imports.append("import java.util.LinkedList;")
            if "Node" in combined_code:
                missing_imports.append("import java.util.Queue;")
                missing_imports.append("import java.util.LinkedList;")

            # Combine imports and remove duplicates
            unique_imports = []
            for imp in missing_imports:
                if imp not in unique_imports and "import java.util.*" not in code:
                    unique_imports.append(imp)

            if unique_imports:
                code = "\n".join(unique_imports) + "\n\n" + code

            # 2. Add standard definitions
            if "TreeNode" in combined_code and "class TreeNode" not in code:
                node_def = """
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
"""
                code = node_def + "\n" + code
            if "ListNode" in combined_code and "class ListNode" not in code:
                node_def = """
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
"""
                code = node_def + "\n" + code

            if "Node" in combined_code and "class Node" not in code:
                node_def = """
class Node {
    int val;
    Node left;
    Node right;
    Node next;

    public Node(int val) {
        this.val = val;
    }

    public Node(int val, Node left, Node right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    public int[] serialize() {
        List<Integer> result = new ArrayList<>();
        Queue<Node> queue = new LinkedList<>();
        queue.add(this);

        while (!queue.isEmpty()) {
            Node current = queue.poll();
            if (current == null) {
                result.add(-1);
                continue;
            }
            result.add(current.val);
            queue.add(current.left);
            queue.add(current.right);
        }

        // Remove trailing null markers
        while (!result.isEmpty() && result.get(result.size()-1) == -1) {
            result.remove(result.size()-1);
        }

        return result.stream().mapToInt(i->i).toArray();
    }
}
"""
                code = node_def + "\n" + code

            if  "class Solution" in code and "public class Solution" not in code:
                code = code.replace("class Solution", "public class Solution")

            if "public class Solution" in code:  # Use public class since we updated it
                class_start = code.find("public class Solution")
                brace_start = code.find("{", class_start)

                # Find the matching closing brace
                brace_count = 1
                pos = brace_start + 1
                solution_end = len(code)  # Default to end of code

                while pos < len(code) and brace_count > 0:
                    if code[pos] == '{':
                        brace_count += 1
                    elif code[pos] == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            solution_end = pos
                    pos += 1

                # 4. Format test cases properly
                formatted_tests = []
                for test in test_cases:
                    # Make sure we're using lowercase "solution" object
                    test = test.replace("new Solution()", "solution")

                    # Add semicolons if missing
                    if not test.strip().endswith(";"):
                        test = test.strip() + ";"

                    formatted_tests.append(test)

                # 5. Create main method with proper instantiation of Solution
                indented_tests = '\n'.join(f'        {test}' for test in formatted_tests)
                main_method = f"""
    public static void main(String[] args) {{
        Solution solution = new Solution();
{indented_tests}
    }}
"""
                # 6. Insert main method inside the Solution class, before the closing brace
                full_script = code[:solution_end] + main_method + code[solution_end:]
            else:
                # If no Solution class found, something is wrong
                raise ValueError("Java code must contain a Solution class")


###

        print(f"\n[Input] {language.upper()} script received:\n{full_script}")

        # Language configuration
        ext_map = {
            "python3": ".py",
            "cpp": ".cpp",
            "java": ".java"
        }

        if language not in ext_map:
            raise ValueError(f"Unsupported language: {language}. Choose from {list(ext_map.keys())}")

        # Create temp file
        with tempfile.NamedTemporaryFile(mode="w", suffix=ext_map[language], delete=False) as tmp_file:
            tmp_file.write(full_script)
            tmp_path = tmp_file.name
            print(f"[System] Created temporary {language.upper()} file: {tmp_path}")

        # Verify file contents
        with open(tmp_path, 'r') as file:
            print(f"[System] File contents verified")

        try:
            if language == "python3":
                print("[Execution] Starting Python interpreter...")
                result = subprocess.run(
                    [sys.executable, tmp_path],
                    capture_output=True,
                    text=True,
                    timeout=self.timeout
                )

            elif language == "cpp":
                print("[Compilation] Compiling C++ code...")
                executable = tmp_path.replace(".cpp", "")
                compile_result = subprocess.run(
                    ["g++", tmp_path, "-o", executable],
                    capture_output=True,
                    text=True
                )

                if compile_result.returncode != 0:
                    print(f"[Error] Compilation failed:\n{compile_result.stderr}")
                    return {
                        "stdout": "",
                        "stderr": compile_result.stderr,
                        "exit_code": compile_result.returncode,
                        "success": False
                    }

                print("[Execution] Running compiled binary...")
                result = subprocess.run(
                    [executable],
                    capture_output=True,
                    text=True,
                    timeout=self.timeout
                )
                os.remove(executable)

            elif language == "java":
                print("[System] Analyzing Java class structure...")
                class_name = "Solution"
                correct_java_path = os.path.join(os.path.dirname(tmp_path), f"{class_name}.java")
                os.rename(tmp_path, correct_java_path)
                tmp_path = correct_java_path
                print(f"[System] Renamed to standard Java filename: {tmp_path}")

                print("[Compilation] Compiling with javac...")
                compile_result = subprocess.run(
                    ["javac", tmp_path],
                    capture_output=True,
                    text=True
                )

                if compile_result.returncode != 0:
                    print(f"[Error] Java compilation failed:\n{compile_result.stderr}")
                    return {
                        "stdout": "",
                        "stderr": compile_result.stderr,
                        "exit_code": compile_result.returncode,
                        "success": False
                    }

                print("[Execution] Running with JVM...")
                result = subprocess.run(
                    ["java", "-cp", os.path.dirname(tmp_path), class_name],
                    capture_output=True,
                    text=True,
                    timeout=self.timeout
                )
                # Clean up .class file
                class_file = os.path.join(os.path.dirname(tmp_path), f"{class_name}.class")
                if os.path.exists(class_file):
                    os.remove(class_file)

            print(f"\n[Result] Process completed (Exit code: {result.returncode})")
            print(f"Output:\n{result.stdout}")
            if result.stderr:
                print(f"Errors:\n{result.stderr}")

            return {
                "stdout": result.stdout,
                "stderr": result.stderr,
                "exit_code": result.returncode,
                "success": result.returncode == 0
            }

        except subprocess.TimeoutExpired:
            print("\n[Error] Execution exceeded time limit!")
            return {
                "stdout": "",
                "stderr": "Execution timed out",
                "exit_code": -1,
                "success": False
            }
        finally:
            if os.path.exists(tmp_path):
                print(f"[System] Removing temporary file: {tmp_path}")
                os.remove(tmp_path)